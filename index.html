<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tableau de Bord SUBIAKRO</title>
  <meta name="description" content="Paramètres Hydrometriques / Agrométéorologiques">
  <!-- Font Awesome pour les icônes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <!-- Socket.io -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
  <!-- Chart.js pour les graphiques -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
<!-- Plugin Zoom pour Chart.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.0/chartjs-plugin-zoom.min.js"></script>
<!-- Hammer.js pour la gestion tactile avec le zoom -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <!-- SheetJS pour l'export Excel -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<style>
    /* Reset et base */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background-color: #f9fafb;
      color: #1f2937;
      min-height: 100vh;
    }

    
    a {
      text-decoration: none;
      color: inherit;
    }
    
    ul {
      list-style: none;
    }
    
    /* Layout */
    .flex {
      display: flex;
    }
    
    .flex-col {
      flex-direction: column;
    }
    
    .items-center {
      align-items: center;
    }
    
    .items-start {
      align-items: flex-start;
    }
    
    .justify-center {
      justify-content: center;
    }
    
    .justify-between {
      justify-content: space-between;
    }
    
    .justify-start {
      justify-content: flex-start;
    }
    
    .gap-2 {
      gap: 0.5rem;
    }
    
    .gap-4 {
      gap: 1rem;
    }
    
    .gap-6 {
      gap: 1.5rem;
    }
    
    .flex-1 {
      flex: 1;
    }
    
    .flex-shrink-0 {
      flex-shrink: 0;
    }
    
    /* Grid */
    .grid {
      display: grid;
    }
    
    .grid-cols-1 {
      grid-template-columns: repeat(1, minmax(0, 1fr));
    }
    
    @media (min-width: 768px) {
      .md\:grid-cols-2 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    
    @media (min-width: 1024px) {
      .lg\:grid-cols-2 {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
    
    /* Spacing */
    .p-0 {
      padding: 0;
    }
    
    .p-2 {
      padding: 0.5rem;
    }
    
    .p-4 {
      padding: 1rem;
    }
    
    .p-5 {
      padding: 1.25rem;
    }
    
    .p-6 {
      padding: 1.5rem;
    }
    
    .px-3 {
      padding-left: 0.75rem;
      padding-right: 0.75rem;
    }
    
    .px-4 {
      padding-left: 1rem;
      padding-right: 1rem;
    }
    
    .px-6 {
      padding-left: 1.5rem;
      padding-right: 1.5rem;
    }
    
    .py-2 {
      padding-top: 0.5rem;
      padding-bottom: 0.5rem;
    }
    
    .py-3 {
      padding-top: 0.75rem;
      padding-bottom: 0.75rem;
    }
    
    .py-4 {
      padding-top: 1rem;
      padding-bottom: 1rem;
    }
    
    .py-6 {
      padding-top: 1.5rem;
      padding-bottom: 1.5rem;
    }
    
    .py-8 {
      padding-top: 2rem;
      padding-bottom: 2rem;
    }
    
    .pt-6 {
      padding-top: 1.5rem;
    }
    
    .mb-0 {
      margin-bottom: 0;
    }
    
    .mb-2 {
      margin-bottom: 0.5rem;
    }
    
    .mb-3 {
      margin-bottom: 0.75rem;
    }
    
    .mb-4 {
      margin-bottom: 1rem;
    }
    
    .mb-6 {
      margin-bottom: 1.5rem;
    }
    
    .mb-8 {
      margin-bottom: 2rem;
    }
    
    .ml-0 {
      margin-left: 0;
    }
    
    .ml-1 {
      margin-left: 0.25rem;
    }
    
    .ml-3 {
      margin-left: 0.75rem;
    }
    
    .mr-0 {
      margin-right: 0;
    }
    
    .mr-2 {
      margin-right: 0.5rem;
    }
    
    .mr-3 {
      margin-right: 0.75rem;
    }
    
    .mt-0 {
      margin-top: 0;
    }
    
    .mt-4 {
      margin-top: 1rem;
    }
    
    .mt-6 {
      margin-top: 1.5rem;
    }
    
    .mx-auto {
      margin-left: auto;
      margin-right: auto;
    }
    
    /* Typography */
    .text-xs {
      font-size: 0.75rem;
    }
    
    .text-sm {
      font-size: 0.875rem;
    }
    
    .text-base {
      font-size: 1rem;
    }
    
    .text-lg {
      font-size: 1.125rem;
    }
    
    .text-xl {
      font-size: 1.25rem;
    }
    
    .text-2xl {
      font-size: 1.5rem;
    }
    
    .text-3xl {
      font-size: 1.875rem;
    }
    
    .font-medium {
      font-weight: 500;
    }
    
    .font-semibold {
      font-weight: 600;
    }
    
    .font-bold {
      font-weight: 700;
    }
    
    .uppercase {
      text-transform: uppercase;
    }
    
    .tracking-wider {
      letter-spacing: 0.05em;
    }
    
    .text-left {
      text-align: left;
    }
    
    .text-center {
      text-align: center;
    }
    
    .text-right {
      text-align: right;
    }
    
    /* Colors */
    .text-white {
      color: white;
    }
    
    .text-gray-400 {
      color: #9ca3af;
    }
    
    .text-gray-600 {
      color: #4b5563;
    }
    
    .text-gray-700 {
      color: #374151;
    }
    
    .text-gray-800 {
      color: #1f2937;
    }
    
    .text-blue-600 {
      color: #2563eb;
    }
    
    .text-emerald-500 {
      color: #10b981;
    }
    
    .text-emerald-600 {
      color: #059669;
    }
    
    .text-amber-500 {
      color: #f59e0b;
    }
    
    .text-amber-600 {
      color: #d97706;
    }
    
    .text-sky-500 {
      color: #0ea5e9;
    }
    
    .text-sky-600 {
      color: #0284c7;
    }
    
    .text-green-800 {
      color: #166534;
    }
    
    .text-yellow-800 {
      color: #854d0e;
    }
    
    .bg-white {
      background-color: white;
    }
    
    .bg-gray-50 {
      background-color: #f9fafb;
    }
    
    .bg-gray-100 {
      background-color: #f3f4f6;
    }
    
    .bg-gray-200 {
      background-color: #e5e7eb;
    }
    
    .bg-blue-50 {
      background-color: #eff6ff;
    }
    
    .bg-emerald-50 {
      background-color: #ecfdf5;
    }
    
    .bg-amber-50 {
      background-color: #fffbeb;
    }
    
    .bg-sky-50 {
      background-color: #f0f9ff;
    }
    
    .bg-green-100 {
      background-color: #dcfce7;
    }
    
    .bg-yellow-100 {
      background-color: #fef9c3;
    }
    
    /* Borders */
    .border {
      border-width: 1px;
      border-style: solid;
    }
    
    .border-b {
      border-bottom-width: 1px;
      border-bottom-style: solid;
    }
    
    .border-r {
      border-right-width: 1px;
      border-right-style: solid;
    }
    
    .border-gray-100 {
      border-color: #f3f4f6;
    }
    
    .border-gray-200 {
      border-color: #e5e7eb;
    }
    
    .border-emerald-500 {
      border-color: #10b981;
    }
    
    .border-collapse {
      border-collapse: collapse;
    }
    
    .rounded-lg {
      border-radius: 0.5rem;
    }
    
    .rounded-xl {
      border-radius: 0.75rem;
    }
    
    .rounded-full {
      border-radius: 9999px;
    }
    
    /* Shadows */
    .shadow-sm {
      box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }
    
    .shadow-md {
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }
    
    .shadow-lg {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    
    .shadow-xl {
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    /* Effects */
    .transition-all {
      transition-property: all;
    }
    
    .transition-transform {
      transition-property: transform;
    }
    
    .transition-shadow {
      transition-property: box-shadow;
    }
    
    .duration-200 {
      transition-duration: 200ms;
    }
    
    .duration-300 {
      transition-duration: 300ms;
    }
    
    .ease-in-out {
      transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .hover\:-translate-y-1:hover {
      transform: translateY(-0.25rem);
    }
    
    .hover\:bg-gray-50:hover {
      background-color: #f9fafb;
    }
    
    .hover\:bg-gray-100:hover {
      background-color: #f3f4f6;
    }
    
    .hover\:text-gray-800:hover {
      color: #1f2937;
    }
    
    .hover\:shadow-lg:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    
    .hover\:shadow-xl:hover {
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
    }
    
    /* Layout Specifics */
    .w-full {
      width: 100%;
    }
    
    .w-10 {
      width: 2.5rem;
    }
    
    .w-12 {
      width: 3rem;
    }
    
    .w-9 {
      width: 2.25rem;
    }
    
    .h-10 {
      height: 2.5rem;
    }
    
    .h-12 {
      height: 3rem;
    }
    
    .h-9 {
      height: 2.25rem;
    }
    
    .h-screen {
      height: 100vh;
    }
    
    .h-72 {
      height: 18rem;
    }
    
    .max-h-60 {
      max-height: 15rem;
    }
    
    .min-h-screen {
      min-height: 100vh;
    }
    
    .max-w-7xl {
      max-width: 80rem;
    }
    
    .overflow-hidden {
      overflow: hidden;
    }
    
    .overflow-y-auto {
      overflow-y: auto;
    }
    
    .overflow-x-auto {
      overflow-x: auto;
    }
    
    .whitespace-nowrap {
      white-space: nowrap;
    }
    
    /* Positionning */
    .fixed {
      position: fixed;
    }
    
    .absolute {
      position: absolute;
    }
    
    .relative {
      position: relative;
    }
    
    .sticky {
      position: sticky;
    }
    
    .top-0 {
      top: 0;
    }
    
    .top-3 {
      top: 0.75rem;
    }
    
    .right-3 {
      right: 0.75rem;
    }
    
    .left-0 {
      left: 0;
    }
    
    .z-50 {
      z-index: 50;
    }
    
    /* Display */
    .hidden {
      display: none;
    }
    
    .block {
      display: block;
    }
    
    /* Opacity */
    .opacity-70 {
      opacity: 0.7;
    }
    
    /* Gradient Backgrounds */
    .bg-gradient-to-br {
      background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));
    }
    
    .from-blue-500 {
      --tw-gradient-stops: #3b82f6, var(--tw-gradient-to, rgba(59, 130, 246, 0));
    }
    
    .to-blue-700 {
      --tw-gradient-to: #1d4ed8;
    }
    
    .from-emerald-500 {
      --tw-gradient-stops: #10b981, var(--tw-gradient-to, rgba(16, 185, 129, 0));
    }
    
    .to-emerald-700 {
      --tw-gradient-to: #047857;
    }
    
    .from-amber-500 {
      --tw-gradient-stops: #f59e0b, var(--tw-gradient-to, rgba(245, 158, 11, 0));
    }
    
    .to-amber-700 {
      --tw-gradient-to: #b45309;
    }
    
    .from-sky-500 {
      --tw-gradient-stops: #0ea5e9, var(--tw-gradient-to, rgba(14, 165, 233, 0));
    }
    
    .to-sky-700 {
      --tw-gradient-to: #0369a1;
    }
    
    /* Responsive */
    .w-18 {
      width: 4.5rem;
    }
    
    .ml-18 {
      margin-left: 4.5rem;
    }
    
    @media (min-width: 768px) {
      .md\:flex-row {
        flex-direction: row;
      }
      
      .md\:items-center {
        align-items: center;
      }
      
      .md\:justify-start {
        justify-content: flex-start;
      }
      
      .md\:w-72 {
        width: 18rem;
      }
      
      .md\:ml-72 {
        margin-left: 18rem;
      }
      
      .w-\[calc\(100\%-4\.5rem\)\] {
        width: calc(100% - 4.5rem);
      }
      
      .md\:px-0 {
        padding-left: 0;
        padding-right: 0;
      }
      
      .md\:px-6 {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }
      
      .md\:p-6 {
        padding: 1.5rem;
      }
      
      .md\:mr-3 {
        margin-right: 0.75rem;
      }
      
      .md\:mr-4 {
        margin-right: 1rem;
      }
      
      .md\:mx-0 {
        margin-left: 0;
        margin-right: 0;
      }
      
      .md\:text-2xl {
        font-size: 1.5rem;
      }
      
      .md\:text-sm {
        font-size: 0.875rem;
      }
      
      .md\:hidden {
        display: none;
      }
      
      .md\:block {
        display: block;
      }
      
      .md\:inline {
        display: inline;
      }
      
      .md\:items-start {
        align-items: flex-start;
      }
    }
    
    @media (min-width: 1024px) {
      .lg\:px-8 {
        padding-left: 2rem;
        padding-right: 2rem;
      }
    }
   
    /* Chart Container */
    .chart-container {
      width: 100%;
      height: 100%;
    }
   
  
    #water-level-chart {
  width: 100%;
  height: 300px; /* Hauteur fixe importante */
  position: relative;
}

#water-level-chart canvas {
  width: 100% !important;
  height: 100% !important;
}
#chartContainer {
  height: 100% !important; 
  width: 100% !important;
}
#chartContainer:hover {
    box-shadow: 0 4px 20px rgba(0,0,0,0.12);
}
/* Styles pour la modale et les boutons */
.fixed {
  position: fixed;
}

.inset-0 {
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

.z-50 {
  z-index: 50;
}

.bg-black\/50 {
  background-color: rgba(0, 0, 0, 0.5);
}

.max-h-\[90vh\] {
  max-height: 90vh;
}

/* Animation pour la modale */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.fixed {
  animation: fadeIn 0.3s ease-out;
}

/* Styles pour les boutons */
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

button:disabled:hover {
  transform: none !important;
}
/* Styles pour les boutons noirs */
.btn-gestion {
  background-color: #000000;
  color: white;
  border: none;
  border-radius: 8px;
  padding: 10px 15px;
  font-size: 14px;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.btn-gestion:hover {
  background-color: #333333;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.btn-gestion:active {
  transform: translateY(0);
}

.btn-gestion i {
  font-size: 16px;
}
/* Zoom controls */
.chart-zoom-controls {
  position: absolute;
  bottom: 5px;
  right: 5px;
  z-index: 10;
  display: flex;
  gap: 5px;
}

.chart-zoom-btn {
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 5px;
  padding: 5px 8px;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: all 0.2s;
}

.chart-zoom-btn:hover {
  background-color: #f3f4f6;
  transform: translateY(-1px);
  box-shadow: 0 2px 5px rgba(0,0,0,0.15);
}

/* Info zoom */
.zoom-info {
  position: absolute;
  top: 5px;
  left: 5px;
  font-size: 12px;
  color: #6b7280;
  background-color: rgba(255,255,255,0.8);
  padding: 2px 5px;
  border-radius: 3px;
  z-index: 5;
}

#water-level-chart {
  width: 100%;
  height: 350px; /* Augmenter la hauteur */
  position: relative;
}

/* Style spécifique pour le bouton Réinitialiser */
.bg-red-600 {
  background-color: #dc2626 !important;
}
.bg-red-600:hover {
  background-color: #b91c1c !important;
}
/* Conteneur des boutons */
.flex-wrap {
  gap: 0.75rem;
}
/* Modification uniquement de la carte principale de pluviométrie en bleu ciel */
#rain-section .rounded-xl.shadow-lg.text-white.p-6.relative.bg-gradient-to-br {
    background-image: linear-gradient(to bottom right, #7dd3fc, #0ea5e9) !important; /* Dégradé bleu ciel */
}

/* Ajustement du texte et des icônes pour une meilleure lisibilité sur fond bleu ciel */
#rain-section .rounded-xl.shadow-lg.text-white.p-6.relative.bg-gradient-to-br .uppercase.tracking-wider.text-sm.font-medium.mb-2,
#rain-section .rounded-xl.shadow-lg.text-white.p-6.relative.bg-gradient-to-br .fas.fa-wifi {
    color: rgba(255, 255, 255, 0.9) !important; /* Texte blanc légèrement transparent */
}

/* Ajustement de la valeur affichée pour qu'elle soit bien visible */
#rain-section .rounded-xl.shadow-lg.text-white.p-6.relative.bg-gradient-to-br .text-3xl.font-bold {
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2); /* Légère ombre pour améliorer la lisibilité */
}


/* CSS complet pour la section Climat Ambiant - Thème noir */

/* Styles de base pour la section */
#ambient-section {
  background-color: #f9fafb;
  border-radius: 12px;
  padding: 1.5rem;
  margin-bottom: 2rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

#ambient-section h2 {
  color: #1f2937;
  font-size: 1.5rem;
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
}

#ambient-section .icon-container {
  width: 2.5rem;
  height: 2.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.75rem;
  background-color: #f3f4f6;
  color: #000000;
  margin-right: 0.75rem;
  flex-shrink: 0;
}

/* Cartes de données */
.data-card {
  border-radius: 0.75rem;
  padding: 1.5rem;
  color: white;
  position: relative;
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.data-card:hover {
  transform: translateY(-0.25rem);
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
}

.temperature-card {
  background: linear-gradient(to bottom right, #000000, #333333);
  border: 1px solid #555555;
}

.humidity-card {
  background: linear-gradient(to bottom right, #222222, #111111);
  border: 1px solid #444444;
}

.data-card i.fa-wifi {
  position: absolute;
  top: 0.75rem;
  right: 0.75rem;
  opacity: 0.7;
}

.data-card p.label {
  text-transform: uppercase;
  letter-spacing: 0.05em;
  font-size: 0.75rem;
  font-weight: 500;
  margin-bottom: 0.5rem;
}

.data-card .value {
  font-size: 1.875rem;
  font-weight: 700;
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  margin-top: 1rem;
}

.data-card .value span.unit {
  font-size: 1.125rem;
  margin-left: 0.25rem;
}

.data-card .trend {
  font-size: 1.5rem;
}

/* Visualisation 3D */
#ambient-3d-scene {
  position: relative;
  width: 100%;
  height: 20rem;
  border-radius: 0.5rem;
  overflow: hidden;
  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
  background: linear-gradient(to bottom, #a5b4fc, #818cf8);
  border: 2px solid #e5e7eb;
}

/* Environnement extérieur */
#environment {
  position: absolute;
  inset: 0;
}

#sky {
  position: absolute;
  inset: 0;
  background: linear-gradient(to bottom, #a5b4fc, #c7d2fe);
  transition: all 1s ease-in-out;
}

#celestial-body {
  position: absolute;
  border-radius: 50%;
  width: 3.75rem;
  height: 3.75rem;
  background: #fde047;
  box-shadow: 0 0 40px rgba(253, 224, 71, 0.6);
  top: 2.5rem;
  left: 80%;
  transform: translateX(-50%);
  transition: all 1s ease-in-out;
}

#stars {
  position: absolute;
  inset: 0;
  opacity: 0;
  transition: opacity 1s ease-in-out;
}

#ground {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  height: 25%;
  background: linear-gradient(to bottom, #10b981, #047857);
  transition: all 1s ease-in-out;
}

/* Arbres */
#ambient-3d-scene .tree {
  position: absolute;
  bottom: 25%;
  background: linear-gradient(to top, #166534, #15803d);
  border-radius: 50% 50% 0 0;
  transition: all 1s ease-in-out;
}

/* Modèle 3D */
#room-model {
  width: 100%;
  height: 100%;
  position: relative;
  perspective: 1000px;
}

#room-container {
  width: 100%;
  height: 100%;
  position: relative;
  transform-style: preserve-3d;
  transform: rotateX(20deg) rotateY(30deg);
}

/* Abri météorologique */
#sensor-housing {
  position: absolute;
  width: 5rem;
  height: 6.25rem;
  transform: translate(-50%, -50%) translateZ(-1.25rem);
  left: 50%;
  top: 50%;
}

#sensor-housing .housing {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: white;
  border: 2px solid #d1d5db;
  border-radius: 0.25rem;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  transform: translateZ(0);
}

#sensor-housing .vents {
  position: absolute;
  left: 0;
  top: 20%;
  width: 100%;
  height: 66.67%;
  display: flex;
  flex-direction: column;
  justify-content: space-around;
}

#sensor-housing .vent-line {
  height: 2px;
  background-color: #d1d5db;
  margin: 0 -0.125rem;
}

#sensor-housing .roof {
  position: absolute;
  width: 6.25rem;
  height: 1.25rem;
  background-color: #d1d5db;
  border: 1px solid #9ca3af;
  border-radius: 0.1875rem;
  transform: translate(-0.625rem, -1.25rem);
}

#sensor-housing .pole {
  position: absolute;
  width: 0.625rem;
  height: 6.25rem;
  background-color: #9ca3af;
  left: 50%;
  transform: translate(-50%, 100%);
}

/* Capteur DHT22 */
#dht22-sensor {
  position: absolute;
  width: 1.875rem;
  height: 3.75rem;
  transform: translate(-50%, -50%);
  left: 50%;
  top: 50%;
}

#dht22-sensor .sensor-body {
  height: 100%;
  width: 100%;
  border-radius: 0.375rem;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 0.0625rem;
  background-color: #000000;
  border: 2px solid #333333;
  box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
}

#dht22-sensor .sensor-label {
  width: 75%;
  height: 50%;
  background-color: white;
  border-radius: 0.25rem 0.25rem 0 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.5rem;
  color: #374151;
  font-weight: 700;
}

#dht22-sensor .sensor-base {
  width: 75%;
  height: 50%;
  background-color: black;
  border-radius: 0 0 0.25rem 0.25rem;
  position: relative;
}

#dht22-sensor .sensor-pin {
  position: absolute;
  width: 0.0625rem;
  height: 0.25rem;
  background-color: #9ca3af;
  bottom: -0.25rem;
}

#dht22-sensor .sensor-pin.left {
  left: 25%;
}

#dht22-sensor .sensor-pin.right {
  right: 25%;
}

/* Nuages */
.cloud {
  position: absolute;
  animation: float 30s infinite ease-in-out;
}

.cloud .cloud-part {
  position: absolute;
  border-radius: 50%;
  opacity: 0.9;
  background-color: rgba(255, 255, 255, 0.9);
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
}

/* Précipitations */
.raindrop {
  position: absolute;
  background: linear-gradient(45deg, #000000, #555555);
  border-radius: 50% 50% 50% 0;
  transform: rotate(45deg);
  filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));
  animation: raindropFall 2s linear infinite;
}

/* Indicateurs de valeur */
.value-indicator {
  position: absolute;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
}

.value-indicator .indicator-box {
  padding: 0.125rem 0.5rem;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  font-weight: 700;
  background-color: white;
  border: 2px solid rgba(0, 0, 0, 0.6);
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
  color: #000000;
}

/* Contrôles de rotation */
.rotation-controls {
  position: absolute;
  bottom: 0.75rem;
  right: 0.75rem;
  display: flex;
  gap: 0.5rem;
}

.rotation-controls button {
  padding: 0.5rem;
  border-radius: 50%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);
  background-color: rgba(0, 0, 0, 0.1);
  border: 2px solid rgba(0, 0, 0, 0.5);
  color: #000000;
}

/* Indicateur d'heure */
.time-display {
  position: absolute;
  top: 0.75rem;
  left: 0.75rem;
  padding: 0.125rem 0.75rem;
  border-radius: 0.5rem;
  font-size: 0.75rem;
  font-weight: 500;
  background-color: rgba(255, 255, 255, 0.8);
  color: #000000;
  border: 1px solid rgba(0, 0, 0, 0.3);
}

/* Points de confort */
.comfort-gauge {
  background-color: white;
  border-radius: 0.5rem;
  padding: 1rem;
  border: 1px solid rgba(0, 0, 0, 0.3);
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
}

.comfort-gauge h4 {
  font-size: 0.875rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
  color: #000000;
}

.gauge-container {
  position: relative;
  height: 1.5rem;
  background: linear-gradient(to right, #3b82f6, #22c55e, #ef4444);
  border-radius: 0.75rem;
  overflow: hidden;
}

#comfort-marker {
  position: absolute;
  top: 0;
  width: 1rem;
  height: 1.5rem;
  background-color: white;
  border: 3px solid #000000;
  box-shadow: 0 0 8px #000000;
  transform: translateX(-50%);
}

.gauge-labels {
  display: flex;
  justify-content: space-between;
  margin-top: 0.25rem;
  font-size: 0.75rem;
  color: #4b5563;
}

.comfort-text {
  margin-top: 0.5rem;
  text-align: center;
  font-weight: 500;
  font-size: 0.875rem;
  color: #000000;
}

/* Graphiques */
.ambient-theme #ambient-temp-chart,
.ambient-theme #ambient-humidity-chart {
    transition: all 0.3s ease;
    background-color: white !important;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2) !important; /* Ombre noire */
    border-radius: 8px !important;
    border: 1px solid rgba(0, 0, 0, 0.3) !important; /* Bordure noire */
    padding: 8px !important;
}

.ambient-theme #ambient-temp-chart:hover,
.ambient-theme #ambient-humidity-chart:hover {
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3) !important;
}

/* Historiques */
.history-table {
  width: 100%;
  font-size: 0.875rem;
  color: #4b5563;
  border-collapse: collapse;
}

.history-table thead {
  background-color: #f9fafb;
  text-transform: uppercase;
  font-size: 0.75rem;
  color: #374151;
  position: sticky;
  top: 0;
}

.history-table th {
  padding: 0.5rem;
  text-align: left;
  border-bottom: 1px solid #e5e7eb;
}

.history-table td {
  padding: 0.5rem;
  border-bottom: 1px solid #e5e7eb;
}

.history-table .text-center {
  text-align: center;
}

/* Modification des styles de tableau pour le thème noir */
#ambient-section tr.hover\:bg-purple-50 {
  transition: background-color 0.2s ease-in-out;
}

#ambient-section tr.hover\:bg-purple-50:hover {
  background-color: rgba(0, 0, 0, 0.05) !important; /* Gris très léger au survol */
}

#ambient-section .border-purple-100 {
  border-color: rgba(0, 0, 0, 0.1) !important; /* Bordure grise légère */
}

#ambient-section td.border-b.border-purple-100,
#ambient-section th.border-b.border-purple-100 {
  border-color: rgba(0, 0, 0, 0.1) !important;
}

#ambient-section span.px-2.py-1.rounded-full.text-xs.font-medium[style*="background-color"] {
  background-color: rgba(0, 0, 0, 0.1) !important;
  color: #000000 !important;
}

/* Gestion des données */
.data-management {
  background-color: white;
  border-radius: 0.75rem;
  padding: 1.25rem;
  margin-top: 1.5rem;
  border: 1px solid #e5e7eb;
}

.data-management h3 {
  font-size: 1rem;
  font-weight: 600;
  color: #4b5563;
  margin-bottom: 1rem;
}

.btn-gestion {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border-radius: 0.5rem;
  background-color: #f3f4f6;
  border: 1px solid #e5e7eb;
  color: #4b5563;
  font-size: 0.875rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn-gestion:hover {
  background-color: #e5e7eb;
}

/* Animations */
@keyframes raindropFall {
  0% {
    transform: rotate(45deg) translateY(0) scale(0.8);
    opacity: 0.7;
  }
  80% {
    opacity: 0.7;
  }
  100% {
    transform: rotate(45deg) translateY(400px) scale(0.8);
    opacity: 0;
  }
}

@keyframes float {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(20px); }
}

@keyframes twinkle {
  0%, 100% { opacity: 0.1; }
  50% { opacity: 0.7; }
}

@keyframes sensorPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); box-shadow: 0 0 15px rgba(0, 0, 0, 0.7); }
}

/* Application des animations */
#ambient-section .cloud {
  animation: float 30s infinite ease-in-out;
}

#ambient-section #cloud-container > div:nth-child(2) {
  animation-duration: 40s;
  animation-direction: reverse;
}

#ambient-section .raindrop {
  animation: raindropFall 2s linear infinite;
}

#ambient-section .raindrop:nth-child(2) {
  animation-delay: 0.5s;
}

#ambient-section .raindrop:nth-child(3) {
  animation-delay: 1s;
}

#ambient-section .raindrop:nth-child(4) {
  animation-delay: 1.5s;
}

#ambient-section .raindrop:nth-child(5) {
  animation-delay: 0.7s;
}

#ambient-section #dht22-sensor .h-full.w-full {
  animation: sensorPulse 4s infinite ease-in-out;
}

#ambient-section .star {
  position: absolute;
  width: 2px;
  height: 2px;
  background-color: white;
  border-radius: 50%;
}

#ambient-section .star-1 {
  animation: twinkle 2s infinite ease-in-out;
}

#ambient-section .star-2 {
  animation: twinkle 3s infinite ease-in-out;
}

#ambient-section .star-3 {
  animation: twinkle 4s infinite ease-in-out;
}

/* Adaptation responsive */
@media (max-width: 640px) {
  #ambient-section .btn-gestion {
    padding: 0.5rem;
    font-size: 0.8rem;
  }
  #ambient-section .btn-gestion span {
    display: none;
  }
  #ambient-section .btn-gestion i {
    margin-right: 0;
    font-size: 1rem;
  }
  
  #ambient-section #ambient-3d-scene {
    height: 15rem;
  }
}

@media (max-width: 768px) {
  #ambient-section .flex-col.lg\:flex-row {
    flex-direction: column;
  }
  
  #ambient-section .w-full.lg\:w-2\/3,
  #ambient-section .w-full.lg\:w-1\/3 {
    width: 100%;
  }
}


/* Adaptation responsive */
@media (max-width: 640px) {
  .btn-gestion {
    padding: 0.5rem;
    font-size: 0.8rem;
  }
  .btn-gestion span {
    display: none;
  }
  .btn-gestion i {
    margin-right: 0;
    font-size: 1rem;
  }
}
/* Styles spécifiques pour la section retenue */
#retenue-section .grid {
  display: grid;
}

#retenue-section .grid-cols-3 {
  grid-template-columns: repeat(3, minmax(0, 1fr));
}

#retenue-section .gap-6 {
  gap: 1.5rem;
}

#retenue-section .gap-4 {
  gap: 1rem;
}

#retenue-section .gap-3 {
  gap: 0.75rem;
}

#retenue-section .gap-2 {
  gap: 0.5rem;
}

/* Styles pour les cartes principales */
#retenue-section .rounded-xl {
  border-radius: 0.75rem;
}

#retenue-section .shadow-lg {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

#retenue-section .shadow-md {
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}

#retenue-section .p-6 {
  padding: 1.5rem;
}

#retenue-section .p-5 {
  padding: 1.25rem;
}

#retenue-section .p-4 {
  padding: 1rem;
}

#retenue-section .p-3 {
  padding: 0.75rem;
}

#retenue-section .mb-6 {
  margin-bottom: 1.5rem;
}

#retenue-section .mb-4 {
  margin-bottom: 1rem;
}

#retenue-section .mb-3 {
  margin-bottom: 0.75rem;
}

#retenue-section .mb-2 {
  margin-bottom: 0.5rem;
}

#retenue-section .mt-4 {
  margin-top: 1rem;
}

#retenue-section .mt-6 {
  margin-top: 1.5rem;
}

/* Styles pour les dimensions */
#retenue-section .w-full {
  width: 100%;
}

#retenue-section .h-72 {
  height: 18rem;
}

#retenue-section .h-96 {
  height: 24rem;
}

#retenue-section .w-40 {
  width: 10rem;
}

#retenue-section .h-40 {
  height: 10rem;
}

#retenue-section .w-2\/3 {
  width: 66.666667%;
}

#retenue-section .w-1\/3 {
  width: 33.333333%;
}

/* Styles pour le texte */
#retenue-section .text-xl {
  font-size: 1.25rem;
  line-height: 1.75rem;
}

#retenue-section .text-3xl {
  font-size: 1.875rem;
  line-height: 2.25rem;
}

#retenue-section .text-2xl {
  font-size: 1.5rem;
  line-height: 2rem;
}

#retenue-section .text-base {
  font-size: 1rem;
  line-height: 1.5rem;
}

#retenue-section .text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}

#retenue-section .text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}

#retenue-section .font-bold {
  font-weight: 700;
}

#retenue-section .font-semibold {
  font-weight: 600;
}

#retenue-section .font-medium {
  font-weight: 500;
}

#retenue-section .uppercase {
  text-transform: uppercase;
}

#retenue-section .tracking-wider {
  letter-spacing: 0.05em;
}

#retenue-section .text-center {
  text-align: center;
}

#retenue-section .text-left {
  text-align: left;
}

/* Couleurs de texte */
#retenue-section .text-white {
  color: white;
}

#retenue-section .text-gray-800 {
  color: #1f2937;
}

#retenue-section .text-gray-700 {
  color: #374151;
}

#retenue-section .text-gray-600 {
  color: #4b5563;
}

#retenue-section .text-gray-500 {
  color: #6b7280;
}

#retenue-section .text-blue-600 {
  color: #2563eb;
}

#retenue-section .text-teal-600 {
  color: #0d9488;
}

#retenue-section .text-emerald-600 {
  color: #059669;
}

#retenue-section .text-indigo-600 {
  color: #4f46e5;
}

#retenue-section .text-green-600 {
  color: #16a34a;
}

#retenue-section .text-red-800 {
  color: #991b1b;
}

/* Couleurs de fond */
#retenue-section .bg-white {
  background-color: white;
}

#retenue-section .bg-gray-50 {
  background-color: #f9fafb;
}

#retenue-section .bg-teal-50 {
  background-color: #f0fdfa;
}

#retenue-section .bg-red-100 {
  background-color: #fee2e2;
}

#retenue-section .bg-blue-600 {
  background-color: #2563eb;
}

#retenue-section .bg-gray-600 {
  background-color: #4b5563;
}

/* Gradients */
#retenue-section .bg-gradient-to-br {
  background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));
}

#retenue-section .from-teal-500 {
  --tw-gradient-from: #14b8a6;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(20, 184, 166, 0));
}

#retenue-section .to-teal-700 {
  --tw-gradient-to: #0f766e;
}

#retenue-section .from-blue-500 {
  --tw-gradient-from: #3b82f6;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(59, 130, 246, 0));
}

#retenue-section .to-blue-700 {
  --tw-gradient-to: #1d4ed8;
}

#retenue-section .from-green-500 {
  --tw-gradient-from: #22c55e;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(34, 197, 94, 0));
}

#retenue-section .to-green-700 {
  --tw-gradient-to: #15803d;
}

#retenue-section .from-amber-500 {
  --tw-gradient-from: #f59e0b;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(245, 158, 11, 0));
}

#retenue-section .to-amber-700 {
  --tw-gradient-to: #b45309;
}

#retenue-section .from-indigo-500 {
  --tw-gradient-from: #6366f1;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(99, 102, 241, 0));
}

#retenue-section .to-indigo-700 {
  --tw-gradient-to: #4338ca;
}

#retenue-section .from-red-500 {
  --tw-gradient-from: #ef4444;
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to, rgba(239, 68, 68, 0));
}

#retenue-section .to-red-700 {
  --tw-gradient-to: #b91c1c;
}

/* Bordures */
#retenue-section .border {
  border-width: 1px;
}

#retenue-section .border-2 {
  border-width: 2px;
}

#retenue-section .border-gray-100 {
  border-color: #f3f4f6;
}

#retenue-section .border-gray-200 {
  border-color: #e5e7eb;
}

#retenue-section .border-gray-300 {
  border-color: #d1d5db;
}

#retenue-section .border-t {
  border-top-width: 1px;
}

#retenue-section .border-b {
  border-bottom-width: 1px;
}

#retenue-section .rounded-lg {
  border-radius: 0.5rem;
}

#retenue-section .rounded-md {
  border-radius: 0.375rem;
}

#retenue-section .rounded {
  border-radius: 0.25rem;
}

#retenue-section .rounded-full {
  border-radius: 9999px;
}

#retenue-section .rounded-b-lg {
  border-bottom-right-radius: 0.5rem;
  border-bottom-left-radius: 0.5rem;
}

/* Flexbox et Grid */
#retenue-section .flex {
  display: flex;
}

#retenue-section .flex-col {
  flex-direction: column;
}

#retenue-section .flex-wrap {
  flex-wrap: wrap;
}

#retenue-section .items-center {
  align-items: center;
}

#retenue-section .justify-center {
  justify-content: center;
}

#retenue-section .justify-between {
  justify-content: space-between;
}

#retenue-section .flex-shrink-0 {
  flex-shrink: 0;
}

#retenue-section .flex-1 {
  flex: 1 1 0%;
}

/* Position */
#retenue-section .relative {
  position: relative;
}

#retenue-section .absolute {
  position: absolute;
}

#retenue-section .inset-0 {
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

#retenue-section .inset-y-0 {
  top: 0;
  bottom: 0;
}

#retenue-section .top-0 {
  top: 0;
}

#retenue-section .top-2 {
  top: 0.5rem;
}

#retenue-section .top-3 {
  top: 0.75rem;
}

#retenue-section .right-2 {
  right: 0.5rem;
}

#retenue-section .right-3 {
  right: 0.75rem;
}

#retenue-section .bottom-0 {
  bottom: 0;
}

#retenue-section .left-0 {
  left: 0;
}

#retenue-section .left-3 {
  left: 0.75rem;
}

/* Transitions et animations */
#retenue-section .transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

#retenue-section .transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

#retenue-section .transition-colors {
  transition-property: background-color, border-color, color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

#retenue-section .duration-200 {
  transition-duration: 200ms;
}

#retenue-section .duration-500 {
  transition-duration: 500ms;
}

#retenue-section .ease-in-out {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

/* Hover effects */
#retenue-section .hover\:-translate-y-1:hover {
  transform: translateY(-0.25rem);
}

#retenue-section .hover\:shadow-xl:hover {
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
}

#retenue-section .hover\:bg-blue-700:hover {
  background-color: #1d4ed8;
}

#retenue-section .hover\:bg-purple-50:hover {
  background-color: #faf5ff;
}

/* Other utilities */
#retenue-section .overflow-hidden {
  overflow: hidden;
}

#retenue-section .overflow-x-auto {
  overflow-x: auto;
}

#retenue-section .opacity-70 {
  opacity: 0.7;
}

#retenue-section .-ml-0\.5 {
  margin-left: -0.125rem;
}

#retenue-section .ml-2 {
  margin-left: 0.5rem;
}

#retenue-section .mr-1 {
  margin-right: 0.25rem;
}

#retenue-section .mr-2 {
  margin-right: 0.5rem;
}

#retenue-section .mr-3 {
  margin-right: 0.75rem;
}

#retenue-section .my-2 {
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}

#retenue-section .px-1 {
  padding-left: 0.25rem;
  padding-right: 0.25rem;
}

#retenue-section .px-2 {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}

#retenue-section .px-3 {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}

#retenue-section .px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}

#retenue-section .py-0\.5 {
  padding-top: 0.125rem;
  padding-bottom: 0.125rem;
}

#retenue-section .py-1 {
  padding-top: 0.25rem;
  padding-bottom: 0.25rem;
}

#retenue-section .py-2 {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}

#retenue-section .py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}

/* Nouvelles additions pour correspondre exactement au code React */
#retenue-section .inline {
  display: inline;
}

#retenue-section .inline-flex {
  display: inline-flex;
}

#retenue-section .inline-block {
  display: inline-block;
}

#retenue-section .hidden {
  display: none;
}

#retenue-section .h-5 {
  height: 1.25rem;
}

#retenue-section .w-5 {
  width: 1.25rem;
}

#retenue-section .h-10 {
  height: 2.5rem;
}

#retenue-section .w-10 {
  width: 2.5rem;
}

#retenue-section .h-16 {
  height: 4rem;
}

#retenue-section .w-16 {
  width: 4rem;
}

#retenue-section .min-h-\[160px\] {
  min-height: 160px;
}

#retenue-section .bg-opacity-75 {
  --tw-bg-opacity: 0.75;
}

#retenue-section .border-collapse {
  border-collapse: collapse;
}

/* Ajout des styles existants que vous avez fournis */
#retenue-section .card-hover {
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

#retenue-section .card-hover:hover {
  transform: translateY(-4px);
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

#retenue-section .water-level {
  transition: height 0.8s ease-in-out;
}

#retenue-section .circular-progress circle {
  transition: stroke-dashoffset 0.8s ease-in-out;
}

#retenue-section #retenue-visualization {
  transition: transform 0.5s ease-in-out, box-shadow 0.3s ease-in-out;
  transform-style: preserve-3d;
  backface-visibility: hidden;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
}

#retenue-section #retenue-visualization:hover {
  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.15);
}

#retenue-section #retenue-water {
  position: absolute;
  bottom: 0;  /* C'est cette ligne qui est cruciale */
  left: 0;
  right: 0;
  transition: height 1s ease-in-out;
  background-image: 
    linear-gradient(to bottom, rgba(255, 255, 255, 0.2) 0%, transparent 80%),
    linear-gradient(to top, rgba(59, 130, 246, 1), rgba(96, 165, 250, 0.8));
  overflow: hidden;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}



@keyframes wave {
  0% {
    transform: translateX(0) translateZ(0) scaleY(1);
  }
  50% {
    transform: translateX(25%) translateZ(0) scaleY(0.8);
  }
  100% {
    transform: translateX(50%) translateZ(0) scaleY(1);
  }
}

#retenue-section #retenue-sediment {
  transition: height 1s ease-in-out;
  background-image: linear-gradient(to top, #8B4513, #A0522D);
  position: relative;
  overflow: hidden;
}

/* MODIFICATION: Animation des ondulations améliorée */
@keyframes ripple-effect {
  0% { 
    transform: scale(0); 
    opacity: 0.6;
  }
  100% { 
    transform: scale(3); 
    opacity: 0;
  }
}

/* Styles pour la section niveau de retenue */
.water-container {
    width: 100%;
    max-width: 36rem;
    margin-bottom: 2rem;
}

.water-block {
    transform-style: preserve-3d;
}

.water-fill {
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
    overflow: hidden;
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
}

.wave {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 200%;
    height: 100%;
    background-repeat: repeat-x;
}

.wave-back {
    background: linear-gradient(90deg, rgba(96, 165, 250, 0.4) 0%, rgba(59, 130, 246, 0.3) 50%, rgba(96, 165, 250, 0.4) 100%);
    animation: waveSlide 10s linear infinite;
    filter: blur(2px);
    mix-blend-mode: multiply;
}

.wave-front {
    background: linear-gradient(90deg, rgba(59, 130, 246, 0.9) 0%, rgba(37, 99, 235, 0.9) 50%, rgba(59, 130, 246, 0.9) 100%);
    animation: waveSlideFast 6s linear infinite;
    animation-delay: -2s;
    mix-blend-mode: multiply;
}

@keyframes waveSlide {
    0% {
        transform: translateX(0);
    }
    100% {
        transform: translateX(-50%);
    }
}

@keyframes waveSlideFast {
    0% {
        transform: translateX(0);
    }
    100% {
        transform: translateX(-50%);
    }
}

.level-marker {
    position: absolute;
    left: 1rem;
    display: flex;
    align-items: center;
}

.marker-line {
    height: 2px;
    width: 2rem;
    background-color: #ef4444;
}

.marker-value {
    margin-left: 0.5rem;
    background-color: #fee2e2;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    font-size: 0.75rem;
    font-weight: 600;
    color: #dc2626;
}

.y-axis-labels {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0.75rem;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 1rem 0.25rem;
    font-size: 0.75rem;
    color: #4b5563;
    pointer-events: none;
}

.toggle-line {
    height: 0.25rem;
    width: 100%;
    max-width: 36rem;
    background-color: black;
    cursor: pointer;
    margin-top: 2rem;
}

.sliding-panel {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: 50;
    transform: translateY(100%);
    transition: transform 0.5s;
    max-width: 36rem;
    margin-left: auto;
    margin-right: auto;
    border-top-left-radius: 0.75rem;
    border-top-right-radius: 0.75rem;
    background-color: white;
    box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
}

.sliding-panel.visible {
    transform: translateY(0);
}

.panel-content {
    position: relative;
    margin: 0 auto;
    width: 100%;
    max-width: 36rem;
    background-color: white;
    padding: 1.5rem;
    box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1);
}

.close-button {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    width: 2rem;
    height: 2rem;
    border-radius: 50%;
    background-color: #e5e7eb;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
}

.close-button:hover {
    background-color: #d1d5db;
}

.button {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: 0.375rem;
    border: none;
    cursor: pointer;
    color: white;
    font-weight: 500;
    margin-bottom: 1rem;
}

.button.gray {
    background-color: #4b5563;
}

.button.gray:hover {
    background-color: #374151;
}

.button.indigo {
    background-color: #4f46e5;
}

.button.indigo:hover {
    background-color: #4338ca;
}

.button.blue {
    background-color: #2563eb;
}

.button.blue:hover {
    background-color: #1d4ed8;
}

.button.red {
    background-color: #dc2626;
}

.button.red:hover {
    background-color: #b91c1c;
}

.button.full-width {
    width: 100%;
    justify-content: center;
}

.slider-container {
    margin-bottom: 1rem;
}

.slider-label {
    display: block;
    margin-bottom: 0.5rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: #374151;
}

.slider {
    width: 100%;
    cursor: pointer;
}

.slider-value {
    margin-top: 0.25rem;
    text-align: center;
    font-size: 0.875rem;
    color: #4b5563;
}

#retenue-section #retenue-level-marker,
#retenue-section #retenue-current-level-marker {
  transition: bottom 0.8s ease-in-out;
}

#retenue-section .chart-zoom-controls {
  position: absolute;
  bottom: 10px;
  right: 10px;
  z-index: 10;
  display: flex;
  gap: 5px;
}

#retenue-section .chart-zoom-btn {
  background-color: white;
  border: 1px solid #e5e7eb;
  border-radius: 5px;
  padding: 5px 8px;
  font-size: 14px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  transition: all 0.2s;
}

#retenue-section .chart-zoom-btn:hover {
  background-color: #f3f4f6;
  transform: translateY(-1px);
  box-shadow: 0 2px 5px rgba(0,0,0,0.15);
}

#retenue-section .zoom-info {
  position: absolute;
  top: 10px;
  left: 10px;
  font-size: 12px;
  color: #6b7280;
  background-color: rgba(255,255,255,0.8);
  padding: 3px 6px;
  border-radius: 3px;
  z-index: 5;
}

#retenue-section .btn-gestion {
  background-color: #000000;
  color: white;
  border: none;
  border-radius: 8px;
  padding: 10px 15px;
  font-size: 14px;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

#retenue-section .btn-gestion:hover {
  background-color: #333333;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

#retenue-section .btn-gestion:active {
  transform: translateY(0);
}

#retenue-section .btn-gestion i {
  font-size: 16px;
}

#retenue-section .filter-btn {
  padding: 6px 12px;
  border-radius: 9999px;
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
  display: inline-flex;
  align-items: center;
  gap: 4px;
}

#retenue-section .filter-btn span {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  transition: all 0.2s ease;
}

#retenue-section .filter-btn.active {
  opacity: 1;
}

#retenue-section .filter-btn.inactive {
  opacity: 0.6;
  background-color: #e5e7eb !important;
  color: #6b7280 !important;
}

#retenue-section .filter-btn.inactive span {
  background-color: #9ca3af !important;
}

#retenue-section .btn-main {
  padding: 10px 20px;
  border-radius: 6px;
  color: white;
  font-size: 14px;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
}

#retenue-section .btn-main:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

#retenue-section .btn-main.blue {
  background-color: #2563eb;
}

#retenue-section .btn-main.blue:hover {
  background-color: #1d4ed8;
}

#retenue-section .btn-main.red {
  background-color: #dc2626;
}

#retenue-section .btn-main.red:hover {
  background-color: #b91c1c;
}

#retenue-section .btn-main.gray {
  background-color: #374151;
}

#retenue-section .btn-main.gray:hover {
  background-color: #1f2937;
}

#retenue-section .btn-main.green {
  background-color: #059669;
}

#retenue-section .btn-main.green:hover {
  background-color: #047857;
}

#retenue-section #retenue-update-btn {
  transition: background-color 0.3s ease-in-out;
}

#retenue-section #retenue-rotate-left,
#retenue-section #retenue-rotate-right,
#retenue-section #retenue-rotate-reset {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  background-color: white;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.2s ease;
}

#retenue-section #retenue-rotate-left:hover,
#retenue-section #retenue-rotate-right:hover,
#retenue-section #retenue-rotate-reset:hover {
  transform: scale(1.1);
  box-shadow: 0 3px 7px rgba(0,0,0,0.3);
}

#retenue-section tbody tr {
  transition: background-color 0.15s ease-in-out;
}

#retenue-section tbody tr:hover {
  background-color: rgba(20, 184, 166, 0.1) !important;
}

#retenue-section #retenue-full-table tr:hover {
  background-color: rgba(147, 51, 234, 0.05) !important;
}

#retenue-section .border-purple-100 {
  border-color: #e9d5ff !important;
}

#retenue-section .bg-purple-50 {
  background-color: #faf5ff !important;
}

#retenue-section .text-purple-700 {
  color: #6b21a8 !important;
}

#retenue-section #retenue-visualization.rotating {
  transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
}

#retenue-section .water-ripple {
  position: absolute;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0) 70%);
  border-radius: 50%;
  transform: scale(0);
  animation: ripple-effect 4s ease-out infinite;
  pointer-events: none;
}

@keyframes fill-animation {
  from { height: 0; }
  to { height: var(--target-height); }
}

#retenue-section .water-fill-animation {
  animation: fill-animation 2s ease-out forwards;
}

@media (max-width: 768px) {
  #retenue-section .grid-cols-3 {
    grid-template-columns: repeat(1, minmax(0, 1fr));
  }
  
  #retenue-section .btn-gestion span,
  #retenue-section .btn-main span {
    display: none;
  }
  
  #retenue-section .btn-gestion,
  #retenue-section .btn-main {
    padding: 8px;
  }
  
  #retenue-section .btn-gestion i,
  #retenue-section .btn-main i {
    margin-right: 0;
  }
  
  #retenue-section #retenue-3d-container {
    height: 180px;
  }
  
  #retenue-section .filter-btn {
    font-size: 0.65rem;
    padding: 4px 8px;
  }
  
  #retenue-section .filter-btn span {
    width: 6px;
    height: 6px;
  }
}

#retenue-section .dynamic-value {
  transition: all 0.5s ease-in-out;
}

#retenue-section .progress-bar {
  background-color: #e5e7eb;
  border-radius: 9999px;
  overflow: hidden;
  height: 8px;
}

#retenue-section .progress-fill {
  height: 100%;
  border-radius: 9999px;
  transition: width 1s ease-in-out;
}

#retenue-section .trend-arrow {
  transition: transform 0.3s ease;
}

#retenue-section .trend-up {
  color: #059669;
  transform: translateY(-2px);
}

#retenue-section .trend-down {
  color: #dc2626;
  transform: translateY(2px);
}

#retenue-section .trend-stable {
  color: #d97706;
}
/* Ajoutez ces styles CSS dans votre section <style> */
  @keyframes wave {
  0% {
    transform: translateX(0) translateZ(0) scaleY(1);
  }
  50% {
    transform: translateX(25%) translateZ(0) scaleY(0.8);
  }
  100% {
    transform: translateX(50%) translateZ(0) scaleY(1);
  }
}



    /* Sidemenu Small Screens */
    @media (max-width: 767px) {
      .w-\[calc\(100\%-4\.5rem\)\] {
        width: calc(100% - 4.5rem);
      }
    }
</style>
</head>
<body>
  <div class="flex min-h-screen bg-gray-50 font-sans">
    <!-- Side Menu - SIMPLIFIÉ ET CORRIGÉ -->
    <div id="side-menu" class="w-18 md:w-72 bg-white text-gray-700 h-screen fixed left-0 top-0 overflow-y-auto shadow-lg p-0 pt-6 md:p-6 md:pr-4 border-r border-gray-100 z-50 transition-all duration-300 ease-in-out">
      <div class="pb-6 mb-6 border-b border-gray-100 flex items-center justify-center md:justify-start px-4 md:px-0">
        <h2 class="text-xl font-bold text-gray-800 m-0 hidden md:block"> Barrage hydroagricole Subiakro</h2>
      </div>
      
      <nav>
        <ul class="list-none p-0 m-0 flex flex-col gap-2 items-center md:items-start">
          <li class="w-full">
            <a href="#" class="nav-link group w-full cursor-pointer flex items-center justify-center p-4 md:justify-start md:py-3 md:px-4 rounded-lg transition-all duration-200 ease-in-out text-gray-600 relative overflow-hidden hover:bg-gray-100 hover:text-gray-800 bg-blue-50 text-blue-600 font-medium" data-section="water-section">
              <div class="absolute left-0 top-0 h-full w-1 bg-blue-600 rounded-r-sm transition-all duration-200 ease-in-out"></div>
              <div class="flex items-center justify-center w-9 h-9 rounded-lg mr-0 md:mr-3 bg-white shadow-md transition-all duration-200 ease-in-out flex-shrink-0 text-blue-600 bg-blue-50"> 
                <i class="fas fa-water"></i>
              </div>
              <span class="text-sm hidden md:inline whitespace-nowrap">Niveau et Débit d'eau</span>
            </a>
          </li>
          <li class="w-full">
            <a href="#" class="nav-link group w-full cursor-pointer flex items-center justify-center p-4 md:justify-start md:py-3 md:px-4 rounded-lg transition-all duration-200 ease-in-out text-gray-600 relative overflow-hidden hover:bg-gray-100 hover:text-gray-800" data-section="temperature-section">
              <div class="absolute left-0 top-0 h-full w-1 bg-transparent rounded-r-sm transition-all duration-200 ease-in-out"></div>
              <div class="flex items-center justify-center w-9 h-9 rounded-lg mr-0 md:mr-3 bg-white shadow-sm transition-all duration-200 ease-in-out flex-shrink-0 text-amber-500 bg-amber-50"> 
                <i class="fas fa-thermometer-half"></i>
              </div>
              <span class="text-sm hidden md:inline whitespace-nowrap">Température du Sol</span>
            </a>
          </li>
          <li class="w-full">
            <a href="#" class="nav-link group w-full cursor-pointer flex items-center justify-center p-4 md:justify-start md:py-3 md:px-4 rounded-lg transition-all duration-200 ease-in-out text-gray-600 relative overflow-hidden hover:bg-gray-100 hover:text-gray-800" data-section="humidity-section">
              <div class="absolute left-0 top-0 h-full w-1 bg-transparent rounded-r-sm transition-all duration-200 ease-in-out"></div>
              <div class="flex items-center justify-center w-9 h-9 rounded-lg mr-0 md:mr-3 bg-white shadow-sm transition-all duration-200 ease-in-out flex-shrink-0 text-sky-500 bg-sky-50"> 
                <i class="fas fa-tint"></i>
              </div>
              <span class="text-sm hidden md:inline whitespace-nowrap">Humidité du Sol</span>
            </a>
          </li>
          <!-- Menu capteur de pluie -->
          <li class="w-full">
            <a href="#" class="nav-link group w-full cursor-pointer flex items-center justify-center p-4 md:justify-start md:py-3 md:px-4 rounded-lg transition-all duration-200 ease-in-out text-gray-600 relative overflow-hidden hover:bg-gray-100 hover:text-gray-800" data-section="rain-section">
              <div class="absolute left-0 top-0 h-full w-1 bg-transparent rounded-r-sm transition-all duration-200 ease-in-out"></div>
              <div class="flex items-center justify-center w-9 h-9 rounded-lg mr-0 md:mr-3 bg-white shadow-sm transition-all duration-200 ease-in-out flex-shrink-0 text-indigo-500 bg-indigo-50"> 
                <i class="fas fa-cloud-rain"></i>
              </div>
              <span class="text-sm hidden md:inline whitespace-nowrap">Pluviométrie</span>
            </a>
          </li>
          <li class="w-full">
            <a href="#" class="nav-link group w-full cursor-pointer flex items-center justify-center p-4 md:justify-start md:py-3 md:px-4 rounded-lg transition-all duration-200 ease-in-out text-gray-600 relative overflow-hidden hover:bg-gray-100 hover:text-gray-800" data-section="ambient-section">
              <div class="absolute left-0 top-0 h-full w-1 bg-transparent rounded-r-sm transition-all duration-200 ease-in-out"></div>
              <div class="flex items-center justify-center w-9 h-9 rounded-lg mr-0 md:mr-3 bg-white shadow-sm transition-all duration-200 ease-in-out flex-shrink-0 text-purple-500 bg-purple-50"> 
                <i class="fas fa-temperature-high"></i>
              </div>
              <span class="text-sm hidden md:inline whitespace-nowrap">Climat Ambiant</span>
            </a>
          </li>
        </br>
       <li class="w-full">
  <a href="#" class="nav-link group w-full cursor-pointer flex items-center justify-center p-4 md:justify-start md:py-3 md:px-4 rounded-lg transition-all duration-200 ease-in-out text-gray-600 relative overflow-hidden hover:bg-gray-100 hover:text-gray-800" data-section="retenue-section">
    <div class="absolute left-0 top-0 h-full w-1 bg-transparent rounded-r-sm transition-all duration-200 ease-in-out"></div>
    <div class="flex items-center justify-center w-9 h-9 rounded-lg mr-0 md:mr-3 bg-white shadow-sm transition-all duration-200 ease-in-out flex-shrink-0 text-teal-500 bg-teal-50"> 
      <i class="fas fa-water"></i>
    </div>
    <span class="text-sm hidden md:inline whitespace-nowrap">GESTION RETENUE</span>
  </a>
</li>
        </ul>
      </nav>
    </div>

    <!-- Main Content -->
    <main class="flex-1 ml-18 md:ml-72 w-[calc(100%-4.5rem)] md:w-[calc(100%-18rem)] bg-gray-50 min-h-screen px-4 md:px-6 lg:px-8 box-border transition-all duration-300 ease-in-out">
      <div class="max-w-7xl mx-auto py-8 w-full">
        <div class="bg-white rounded-xl shadow-md p-5 mb-8 border border-gray-100">
          
          <div class="flex flex-wrap justify-center gap-6">
            <!-- Logo Partenaire 1 -->
            <div class="flex flex-col items-center p-4 hover:bg-gray-50 rounded-lg transition-all">
              <div class="h-24 w-24 md:h-32 md:w-32 flex items-center justify-center mb-2">
                <img src="images/logoministere.png" alt="Logo Partenaire 1" class="max-h-full max-w-full object-contain">
              </div>
            </div>
            
            <!-- Logo Partenaire 2 -->
            <div class="flex flex-col items-center p-4 hover:bg-gray-50 rounded-lg transition-all">
              <div class="h-24 w-24 md:h-32 md:w-32 flex items-center justify-center mb-2">
                <img src="images/logocassur.jpg" alt="Logo Partenaire 2" class="max-h-full max-w-full object-contain">
              </div>
            </div>
            
            <!-- Logo Partenaire 3 -->
            <div class="flex flex-col items-center p-4 hover:bg-gray-50 rounded-lg transition-all">
              <div class="h-24 w-24 md:h-32 md:w-32 flex items-center justify-center mb-2">
                <img src="images/logocihydro.png" alt="Logo Partenaire 3" class="max-h-full max-w-full object-contain">
              </div>
            </div>
          </div>
        </div>
        <header class="flex flex-col md:flex-row justify-between items-start md:items-center mb-8 p-5 px-6 bg-white rounded-xl shadow-md border border-gray-100 gap-4">
         <!-- Ajoutez ce code juste après la balise <header> et avant la section water-section -->

         
          <h1 class="text-xl md:text-2xl font-bold text-gray-800 flex items-center">
            <div class="w-10 h-10 md:w-12 md:h-12 bg-blue-50 text-blue-600 flex items-center justify-center rounded-xl mr-3 md:mr-4 text-xl md:text-2xl shadow-sm flex-shrink-0">
              <i class="fas fa-chart-line"></i>
            </div>
            Paramètres Hydrometriques / Agrométéorologiques
          </h1>
          <div id="connection-status" class="py-2 px-4 rounded-full text-xs md:text-sm font-semibold flex items-center shadow-sm whitespace-nowrap bg-yellow-100 text-yellow-800"> 
            <i class="fas fa-sync-alt fa-spin mr-2"></i>
            Connexion...
          </div>
        </header>
        <!-- Sections Container -->
        
        <div>
          <!-- Niveau et Débit d'eau Section -->
          <section id="water-section" class="py-4 block"> 
            <h2 class="text-xl font-bold mb-6 text-gray-800 flex items-center">
              <div class="mr-3 w-10 h-10 flex items-center justify-center rounded-lg text-xl bg-blue-50 text-blue-600 flex-shrink-0">
                <i class="fas fa-water"></i>
              </div>
              Niveau et Débit d'eau
            </h2>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
              <!-- Canal 1 -->
              <div class="flex flex-col gap-4">
                <h3 class="mb-0 text-lg font-semibold text-gray-700">Canal 1</h3>
                <!-- Distance Sensor (Niveau d'eau) - Canal 1 -->
                <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-blue-500 to-blue-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
                  <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
                  <p class="uppercase tracking-wider text-sm font-medium mb-2">Niveau d'eau</p>
                  <div class="flex items-baseline justify-between mt-4">
                    <p class="text-3xl font-bold">
                      <span id="distance1">0.0</span>
                      <span class="text-lg ml-1">cm</span>
                    </p>
                  </div>
                </div>
                <!-- Flow Sensor (Débit d'eau) - Canal 1 -->
                <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-emerald-500 to-emerald-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
                  <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
                  <p class="uppercase tracking-wider text-sm font-medium mb-2">Débit d'eau</p>
                  <div class="flex items-baseline justify-between mt-4">
                    <p class="text-3xl font-bold">
                      <span id="flow1">0.0</span>
                      <span class="text-lg ml-1">m³/s</span>
                    </p>
                  </div>
                </div>
                <!-- Historique Débit - Canal 1 -->
                <div class="bg-white rounded-xl shadow-md p-5 mt-0 overflow-hidden transition-shadow duration-200 ease-in-out border border-gray-100 hover:shadow-lg">
                  <h3 class="text-base font-semibold text-gray-600 mb-3">Historique Débit (Canal 1)</h3>
                  <div class="max-h-60 overflow-y-auto">
                    <table class="w-full text-sm text-gray-600 border-collapse">
                      <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                        <tr>
                          <th class="p-2 text-left border-b border-gray-200">#</th>
                          <th class="p-2 text-left border-b border-gray-200">Valeur (m³/s)</th>
                        </tr>
                      </thead>
                      <tbody id="flow1-history">
                        <tr>
                          <td colspan="2" class="text-center text-gray-400 p-2">
                            Aucune donnée historique
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>

              <!-- Canal 2 -->
              <div class="flex flex-col gap-4">
                <h3 class="mb-0 text-lg font-semibold text-gray-700">Canal 2</h3>
                <!-- Distance Sensor (Niveau d'eau) - Canal 2 -->
                <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-blue-500 to-blue-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
                  <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
                  <p class="uppercase tracking-wider text-sm font-medium mb-2">Niveau d'eau</p>
                  <div class="flex items-baseline justify-between mt-4">
                    <p class="text-3xl font-bold">
                      <span id="distance2">0.0</span>
                      <span class="text-lg ml-1">cm</span>
                    </p>
                  </div>
                </div>
                <!-- Flow Sensor (Débit d'eau) - Canal 2 -->
                <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-emerald-500 to-emerald-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
                  <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
                  <p class="uppercase tracking-wider text-sm font-medium mb-2">Débit d'eau</p>
                  <div class="flex items-baseline justify-between mt-4">
                    <p class="text-3xl font-bold">
                      <span id="flow2">0.0</span>
                      <span class="text-lg ml-1">m³/s</span>
                    </p>
                  </div>
                </div>
                <!-- Historique Débit - Canal 2 -->
                <div class="bg-white rounded-xl shadow-md p-5 mt-0 overflow-hidden transition-shadow duration-200 ease-in-out border border-gray-100 hover:shadow-lg">
                  <h3 class="text-base font-semibold text-gray-600 mb-3">Historique Débit (Canal 2)</h3>
                  <div class="max-h-60 overflow-y-auto">
                    <table class="w-full text-sm text-gray-600 border-collapse">
                      <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                        <tr>
                          <th class="p-2 text-left border-b border-gray-200">#</th>
                          <th class="p-2 text-left border-b border-gray-200">Valeur (m³/s)</th>
                        </tr>
                      </thead>
                      <tbody id="flow2-history">
                        <tr>
                          <td colspan="2" class="text-center text-gray-400 p-2">
                            Aucune donnée historique
                          </td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>

            <!-- Real-time Water Level Chart -->
            <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100 hover:shadow-lg">
              <h3 class="text-base font-semibold text-gray-600 mb-4">Graphique Niveau d'eau Temps Réel</h3>
              <div class="relative w-full h-72"> 
                <div id="water-level-chart" class="chart-container"></div>
                <!-- Zoom controls -->
                <div class="chart-zoom-controls">
                  <button id="zoom-in-btn" class="chart-zoom-btn" title="Zoomer">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button id="zoom-out-btn" class="chart-zoom-btn" title="Dézoomer">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button id="reset-zoom-btn" class="chart-zoom-btn" title="Réinitialiser le zoom">
                    <i class="fas fa-home"></i>
                  </button>
                </div>
                <div class="zoom-info">
                  <i class="fas fa-info-circle"></i> Utilisez la molette pour zoomer et le clic-déplacer pour naviguer
                </div>
              </div>
            </div>
            
        

            <!-- Dans la section water-section, après le graphique -->
            <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100">
                <h3 class="text-base font-semibold text-gray-600 mb-4">Gestion des données</h3>
                
                <div class="flex flex-wrap gap-3">
                  <button onclick="showFullHistory()" class="btn-gestion">
                    <i class="fas fa-history"></i>
                    <span>Historique complet</span>
                  </button>
                  
                   
                  
                  <button onclick="exportData('xlsx')" class="btn-gestion">
                    <i class="fas fa-file-excel"></i>
                    <span>Exporter Excel</span>
                  </button>
                             <!-- Bouton PDF -->
                  <button onclick="exportToPDF()" class="btn-gestion">
                                <i class="fas fa-file-pdf"></i>
                                <span>PDF (.pdf)</span>
                 </button>

                  <button onclick="if(confirm('Voulez-vous vraiment effacer toutes les données?')) { 
                                  localStorage.clear(); 
                                  state.chartData = []; 
                                  state.dataIndex = 0; 
                                  renderChart(); 
                                }" 
                          class="btn-gestion">
                    <i class="fas fa-trash-alt"></i>
                    <span>Réinitialiser</span>
                  </button>
                  <button onclick="exportChartImage()" class="btn-gestion">
                    <i class="fas fa-camera"></i>
                    <span>Exporter Image</span>
                  </button>
                </div>
              </div>
          </section>

          <!-- Température du Sol Section -->
          <section id="temperature-section" class="py-4 hidden">
            <h2 class="text-xl font-bold mb-6 text-gray-800 flex items-center">
              <div class="mr-3 w-10 h-10 flex items-center justify-center rounded-lg text-xl bg-amber-50 text-amber-500 flex-shrink-0">
                <i class="fas fa-thermometer-half"></i>
              </div>
              Température du Sol
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-amber-500 to-amber-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
                <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
                <p class="uppercase tracking-wider text-sm font-medium mb-2">Température du Sol</p>
                <div class="flex items-baseline justify-between mt-4">
                  <p class="text-3xl font-bold">
                    <span id="soilTemperature">0.0</span>
                    <span class="text-lg ml-1">°C</span>
                  </p>
                </div>
              </div>
              <div class="bg-white rounded-xl shadow-md p-5 overflow-hidden transition-shadow duration-200 ease-in-out border border-gray-100 hover:shadow-lg">
                <h3 class="text-base font-semibold text-gray-600 mb-3">Historique Température</h3>
                <div class="max-h-60 overflow-y-auto">
                  <table class="w-full text-sm text-gray-600 border-collapse">
                    <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                      <tr>
                        <th class="p-2 text-left border-b border-gray-200">#</th>
                        <th class="p-2 text-left border-b border-gray-200">Valeur (°C)</th>
                      </tr>
                    </thead>
                    <tbody id="temperature-history">
                      <tr>
                        <td colspan="2" class="text-center text-gray-400 p-2">
                          Aucune donnée historique
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100 hover:shadow-lg">
              <h3 class="text-base font-semibold text-gray-600 mb-4">Graphique Température du Sol Temps Réel</h3>
              <div class="relative w-full h-72"> 
                <div id="temperature-chart" class="chart-container"></div>
                <div class="chart-zoom-controls">
                  <button id="temp-zoom-in-btn" class="chart-zoom-btn" title="Zoomer">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button id="temp-zoom-out-btn" class="chart-zoom-btn" title="Dézoomer">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button id="temp-reset-zoom-btn" class="chart-zoom-btn" title="Réinitialiser le zoom">
                    <i class="fas fa-home"></i>
                  </button>
                </div>
                <div class="zoom-info">
                  <i class="fas fa-info-circle"></i> Utilisez la molette pour zoomer et le clic-déplacer pour naviguer
                </div>
              </div>
            </div>

         
            
          </section>

          
          <!-- Humidité du Sol Section -->
          <section id="humidity-section" class="py-4 hidden">
            <h2 class="text-xl font-bold mb-6 text-gray-800 flex items-center">
              <div class="mr-3 w-10 h-10 flex items-center justify-center rounded-lg text-xl bg-sky-50 text-sky-500 flex-shrink-0">
                <i class="fas fa-tint"></i>
              </div>
              Humidité du Sol
            </h2>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-sky-500 to-sky-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
                <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
                <p class="uppercase tracking-wider text-sm font-medium mb-2">Humidité du Sol</p>
                <div class="flex items-baseline justify-between mt-4">
                  <p class="text-3xl font-bold">
                    <span id="soilHumidity">0.0</span>
                    <span class="text-lg ml-1">%</span>
                  </p>
                </div>
              </div>
              <div class="bg-white rounded-xl shadow-md p-5 overflow-hidden transition-shadow duration-200 ease-in-out border border-gray-100 hover:shadow-lg">
                <h3 class="text-base font-semibold text-gray-600 mb-3">Historique Humidité</h3>
                <div class="max-h-60 overflow-y-auto">
                  <table class="w-full text-sm text-gray-600 border-collapse">
                    <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                      <tr>
                        <th class="p-2 text-left border-b border-gray-200">#</th>
                        <th class="p-2 text-left border-b border-gray-200">Valeur (%)</th>
                      </tr>
                    </thead>
                    <tbody id="humidity-history">
                      <tr>
                        <td colspan="2" class="text-center text-gray-400 p-2">
                          Aucune donnée historique
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100 hover:shadow-lg">
              <h3 class="text-base font-semibold text-gray-600 mb-4">Graphique Humidité du Sol Temps Réel</h3>
              <div class="relative w-full h-72"> 
                <div id="humidity-chart" class="chart-container"></div>
                <!-- Zoom controls -->
                <div class="chart-zoom-controls">
                  <button id="humidity-zoom-in-btn" class="chart-zoom-btn" title="Zoomer">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button id="humidity-zoom-out-btn" class="chart-zoom-btn" title="Dézoomer">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button id="humidity-reset-zoom-btn" class="chart-zoom-btn" title="Réinitialiser le zoom">
                    <i class="fas fa-home"></i>
                  </button>
                </div>
                <div class="zoom-info">
                  <i class="fas fa-info-circle"></i> Utilisez la molette pour zoomer et le clic-déplacer pour naviguer
                </div>
              </div>
            </div>
            
            <!-- Buttons for humidity data management -->
       
          </section>

          <section id="rain-section" class="py-4 hidden">
            <h2 class="text-xl font-bold mb-6 text-gray-800 flex items-center">
              <div class="mr-3 w-10 h-10 flex items-center justify-center rounded-lg text-xl bg-indigo-50 text-indigo-500 flex-shrink-0">
                <i class="fas fa-cloud-rain"></i>
              </div>
              Pluviométrie
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-indigo-500 to-indigo-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
                <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
                <p class="uppercase tracking-wider text-sm font-medium mb-2">Précipitations</p>
                <div class="flex items-baseline justify-between mt-4">
                  <p class="text-3xl font-bold">
                    <span id="rainAmount">0.0</span>
                    <span class="text-lg ml-1">mm</span>
                  </p>
                </div>
              </div>
              <div class="bg-white rounded-xl shadow-md p-5 overflow-hidden transition-shadow duration-200 ease-in-out border border-gray-100 hover:shadow-lg">
                <h3 class="text-base font-semibold text-gray-600 mb-3">Historique Précipitations</h3>
                <div class="max-h-60 overflow-y-auto">
                  <table class="w-full text-sm text-gray-600 border-collapse">
                    <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                      <tr>
                        <th class="p-2 text-left border-b border-gray-200">#</th>
                        <th class="p-2 text-left border-b border-gray-200">Valeur (mm)</th>
                      </tr>
                    </thead>
                    <tbody id="rain-history">
                      <tr>
                        <td colspan="2" class="text-center text-gray-400 p-2">
                          Aucune donnée historique
                        </td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100 hover:shadow-lg">
              <h3 class="text-base font-semibold text-gray-600 mb-4">Graphique Précipitations Temps Réel</h3>
              <div class="relative w-full h-72"> 
                <div id="rain-chart" class="chart-container"></div>
                <!-- Zoom controls -->
                <div class="chart-zoom-controls">
                  <button id="rain-zoom-in-btn" class="chart-zoom-btn" title="Zoomer">
                    <i class="fas fa-search-plus"></i>
                  </button>
                  <button id="rain-zoom-out-btn" class="chart-zoom-btn" title="Dézoomer">
                    <i class="fas fa-search-minus"></i>
                  </button>
                  <button id="rain-reset-zoom-btn" class="chart-zoom-btn" title="Réinitialiser le zoom">
                    <i class="fas fa-home"></i>
                  </button>
                </div>
                <div class="zoom-info">
                  <i class="fas fa-info-circle"></i> Utilisez la molette pour zoomer et le clic-déplacer pour naviguer
                </div>
              </div>
            </div>
    
            <!-- Visualisation 3D -->
            <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100 hover:shadow-lg">
              <h3 class="text-base font-semibold text-gray-600 mb-4">Analyse détaillée</h3>
              <div id="rain-3d-visualization" style="width: 100%; height: 150px; background: linear-gradient(to right, #f0f9ff, #dbeafe, #bfdbfe, #93c5fd); 
                   border-radius: 8px; position: relative; overflow: hidden; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                <div class="rain-layers" style="height: 100%; width: 100%; position: relative;">
                  <!-- Les couches de pluie seront générées dynamiquement -->
                </div>
                <div class="rain-indicators" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                  <!-- Les indicateurs de pluie seront générés dynamiquement -->
                </div>
                <div class="rain-scale" style="position: absolute; bottom: 10px; right: 10px; background: rgba(255,255,255,0.8); 
                    padding: 5px; border-radius: 5px; font-size: 12px;">
                  <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="color: #93c5fd;">■</span> Faible
                    <span style="color: #60a5fa;">■</span> Modérée
                    <span style="color: #3b82f6;">■</span> Forte
                    <span style="color: #2563eb;">■</span> Intense
                  </div>
                </div>
              </div>
              
              <!-- Tableau de données détaillées -->
              <div class="max-h-60 overflow-y-auto">
                <table class="w-full text-sm text-gray-600 border-collapse">
                  <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                    <tr>
                      <th class="p-2 text-left border-b border-gray-200">Heure</th>
                      <th class="p-2 text-center border-b border-gray-200">Précipitations (mm)</th>
                      <th class="p-2 text-center border-b border-gray-200">Intensité</th>
                      <th class="p-2 text-center border-b border-gray-200">Variation</th>
                    </tr>
                  </thead>
                  <tbody id="rain-data-table">
                    <tr>
                      <td colspan="4" class="text-center text-gray-400 p-2">
                        Chargement des données...
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            
            <!-- Boutons de gestion des données -->
            <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100">
              <h3 class="text-base font-semibold text-gray-600 mb-4">Gestion des données</h3>
              
              <div class="flex flex-wrap gap-3">
                <button onclick="showRainFullHistory()" class="btn-gestion">
                  <i class="fas fa-history"></i>
                  <span>Historique complet</span>
                </button>
                
                <button onclick="exportRainData('xlsx')" class="btn-gestion">
                  <i class="fas fa-file-excel"></i>
                  <span>Exporter Excel</span>
                </button>
                
                <button onclick="exportRainToPDF()" class="btn-gestion">
                  <i class="fas fa-file-pdf"></i>
                  <span>PDF (.pdf)</span>
                </button>
                
                <button onclick="exportRainChartImage()" class="btn-gestion">
                  <i class="fas fa-camera"></i>
                  <span>Exporter Image</span>
                </button>
                
                <button onclick="resetRainData()" class="btn-gestion">
                  <i class="fas fa-trash-alt"></i>
                  <span>Réinitialiser</span>
                </button>
              </div>
            </div>
          </section>

      <!-- Section Température et Humidité Ambiante -->
<!-- Section Température et Humidité Ambiante -->
<section id="ambient-section" class="py-4 hidden">
    
    <h2 class="text-xl font-bold mb-6 text-gray-800 flex items-center">
      <div class="mr-3 w-10 h-10 flex items-center justify-center rounded-lg text-xl bg-gray-100 text-black flex-shrink-0">
        <i class="fas fa-temperature-high"></i>
      </div>
      Climat Ambiant (DHT22)
    </h2>
    
   <!-- Cartes d'information principales -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
      <!-- Carte Température Ambiante -->
      <div class="rounded-xl shadow-lg text-white p-6 relative transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl" style="background: linear-gradient(to bottom right, #000000, #333333); border: 1px solid #555555;">
        <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
        <p class="uppercase tracking-wider text-sm font-medium mb-2">Température Ambiante</p>
        <div class="flex items-baseline justify-between mt-4">
          <p class="text-3xl font-bold">
            <span id="ambientTemperature">0.0</span>
            <span class="text-lg ml-1">°C</span>
          </p>
          <div id="tempTrend" class="text-2xl">
            <i class="fas fa-equals opacity-50"></i>
          </div>
        </div>
      </div>
      
      <!-- Carte Humidité Ambiante -->
      <div class="rounded-xl shadow-lg text-white p-6 relative transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl" style="background: linear-gradient(to bottom right, #222222, #111111); border: 1px solid #444444;">
        <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
        <p class="uppercase tracking-wider text-sm font-medium mb-2">Humidité Ambiante</p>
        <div class="flex items-baseline justify-between mt-4">
          <p class="text-3xl font-bold">
            <span id="ambientHumidity">0.0</span>
            <span class="text-lg ml-1">%</span>
          </p>
          <div id="humidityTrend" class="text-2xl">
            <i class="fas fa-equals opacity-50"></i>
          </div>
        </div>
      </div>
    </div>
    
    <div class="bg-white rounded-xl shadow-md p-5 mb-6 border border-gray-200" style="border-color: rgba(0, 0, 0, 0.3);">
      <h3 class="text-base font-semibold mb-4" style="color: #000000;">Visualisation 3D du Climat Extérieur</h3>
      <div class="flex flex-col lg:flex-row gap-6">
        <!-- Espace 3D -->
        <div id="ambient-3d-scene" class="relative w-full lg:w-2/3 h-80 rounded-lg overflow-hidden shadow-inner">
          <!-- Environnement extérieur - sera mis à jour par JavaScript selon l'heure -->
          <div id="environment" class="absolute inset-0">
            <!-- Ciel - défaut jour -->
            <div id="sky" class="absolute inset-0" style="background: linear-gradient(to bottom, #a5b4fc, #c7d2fe); transition: all 1s ease-in-out;"></div>
            
            <!-- Soleil/Lune -->
            <div id="celestial-body" class="absolute rounded-full" style="width: 60px; height: 60px; background: #fde047; box-shadow: 0 0 40px rgba(253, 224, 71, 0.6); top: 40px; left: 80%; transform: translateX(-50%); transition: all 1s ease-in-out;"></div>
            
            <!-- Étoiles (visibles la nuit) -->
            <div id="stars" class="absolute inset-0" style="opacity: 0; transition: opacity 1s ease-in-out;">
              <!-- Étoiles générées dynamiquement par JavaScript -->
            </div>
            
            <!-- Herbe/Sol -->
            <div id="ground" class="absolute left-0 right-0 bottom-0 h-1/4" style="background: linear-gradient(to bottom, #10b981, #047857); transition: all 1s ease-in-out;"></div>
            
            <!-- Arbres stylisés en arrière-plan -->
            <div class="absolute bottom-1/4 left-1/5 w-16 h-32" style="background: linear-gradient(to top, #166534, #15803d); border-radius: 50% 50% 0 0; transition: all 1s ease-in-out;"></div>
            <div class="absolute bottom-1/4 left-2/3 w-24 h-40" style="background: linear-gradient(to top, #166534, #15803d); border-radius: 50% 50% 0 0; transition: all 1s ease-in-out;"></div>
          </div>
          
          <!-- Conteneur 3D -->
          <div class="absolute inset-0 flex items-center justify-center">
            <!-- Modèle 3D Interactif -->
            <div id="room-model" class="w-full h-full relative" style="perspective: 1000px;">
              <!-- Station météo extérieure -->
              <div id="room-container" class="w-full h-full relative" style="transform-style: preserve-3d; transform: rotateX(20deg) rotateY(30deg);">
                
                <!-- Abri météorologique / Boîtier -->
                <div id="sensor-housing" class="absolute" style="width: 80px; height: 100px; transform: translate(-50%, -50%) translateZ(-20px); left: 50%; top: 50%;">
                  <!-- Boîtier principal -->
                  <div class="absolute w-full h-full" style="background-color: white; border: 2px solid #d1d5db; border-radius: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); transform: translateZ(0px);"></div>
                  
                  <!-- Persiennes de ventilation (pour abri Stevenson) -->
                  <div class="absolute left-0 top-1/5 w-full h-2/3" style="display: flex; flex-direction: column; justify-content: space-around;">
                    <div style="height: 2px; background-color: #d1d5db; margin: 0 -2px;"></div>
                    <div style="height: 2px; background-color: #d1d5db; margin: 0 -2px;"></div>
                    <div style="height: 2px; background-color: #d1d5db; margin: 0 -2px;"></div>
                    <div style="height: 2px; background-color: #d1d5db; margin: 0 -2px;"></div>
                    <div style="height: 2px; background-color: #d1d5db; margin: 0 -2px;"></div>
                  </div>
                  
                  <!-- Toit -->
                  <div class="absolute" style="width: 100px; height: 20px; background-color: #d1d5db; border: 1px solid #9ca3af; border-radius: 3px; transform: translate(-10px, -20px);"></div>
                  
                  <!-- Support / Mât -->
                  <div class="absolute" style="width: 10px; height: 100px; background-color: #9ca3af; left: 50%; transform: translate(-50%, 100%);"></div>
                  
                  <!-- Capteur DHT22 à l'intérieur -->
                  <div id="dht22-sensor" class="absolute" style="width: 30px; height: 60px; transform: translate(-50%, -50%); left: 50%; top: 50%;">
                    <div class="h-full w-full rounded-lg flex flex-col justify-center items-center p-1" style="background-color: #000000; border: 2px solid #333333; box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);">
                      <div class="w-3/4 h-1/2 bg-white rounded-t-md flex items-center justify-center text-[8px] text-gray-800 font-bold">DHT22</div>
                      <div class="w-3/4 h-1/2 bg-black rounded-b-md relative">
                        <div class="absolute w-1 h-4 bg-gray-400 -bottom-4 left-1/4"></div>
                        <div class="absolute w-1 h-4 bg-gray-400 -bottom-4 right-1/4"></div>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- Nuages -->
                <div id="cloud-container" class="absolute" style="transform: translateZ(-200px); left: 0; top: 0; width: 100%; height: 40%;">
                  <!-- Nuage 1 -->
                  <div class="absolute cloud" style="left: 20%; top: 30%; transform: translate(-50%, -50%);">
                    <div class="relative">
                      <div class="absolute rounded-full opacity-90" style="width: 60px; height: 40px; left: -20px; top: 0; background-color: rgba(255, 255, 255, 0.9); box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);"></div>
                      <div class="absolute rounded-full opacity-90" style="width: 40px; height: 40px; left: 20px; top: -5px; background-color: rgba(255, 255, 255, 0.9); box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);"></div>
                      <div class="absolute rounded-full opacity-90" style="width: 50px; height: 35px; left: 5px; top: 10px; background-color: rgba(255, 255, 255, 0.9); box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);"></div>
                    </div>
                  </div>
                  
                  <!-- Nuage 2 -->
                  <div class="absolute cloud" style="left: 70%; top: 15%; transform: translate(-50%, -50%);">
                    <div class="relative">
                      <div class="absolute rounded-full opacity-90" style="width: 80px; height: 50px; left: -30px; top: 0; background-color: rgba(255, 255, 255, 0.9); box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);"></div>
                      <div class="absolute rounded-full opacity-90" style="width: 55px; height: 55px; left: 30px; top: -10px; background-color: rgba(255, 255, 255, 0.9); box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);"></div>
                      <div class="absolute rounded-full opacity-90" style="width: 65px; height: 45px; left: 5px; top: 15px; background-color: rgba(255, 255, 255, 0.9); box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);"></div>
                    </div>
                  </div>
                </div>
                
                <!-- Précipitations -->
                <div id="humidity-drops" class="absolute" style="top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
                  <!-- Les gouttes sont générées dynamiquement -->
                  <div class="absolute raindrop" style="left: 20%; top: 15%; width: 4px; height: 8px; background: linear-gradient(45deg, #000000, #555555); border-radius: 50% 50% 50% 0; transform: rotate(45deg); filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));"></div>
                  <div class="absolute raindrop" style="left: 45%; top: 20%; width: 4px; height: 8px; background: linear-gradient(45deg, #000000, #555555); border-radius: 50% 50% 50% 0; transform: rotate(45deg); filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));"></div>
                  <div class="absolute raindrop" style="left: 70%; top: 10%; width: 4px; height: 8px; background: linear-gradient(45deg, #000000, #555555); border-radius: 50% 50% 50% 0; transform: rotate(45deg); filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));"></div>
                  <div class="absolute raindrop" style="left: 30%; top: 5%; width: 4px; height: 8px; background: linear-gradient(45deg, #000000, #555555); border-radius: 50% 50% 50% 0; transform: rotate(45deg); filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));"></div>
                  <div class="absolute raindrop" style="left: 85%; top: 25%; width: 4px; height: 8px; background: linear-gradient(45deg, #000000, #555555); border-radius: 50% 50% 50% 0; transform: rotate(45deg); filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.7));"></div>
                </div>
                
                <!-- Indicateurs de valeur -->
                <div id="temp-value" class="absolute z-10 flex items-center justify-center" style="transform: translate(-50%, -50%) translateZ(40px) translateX(-80px) translateY(-50px); left: 40%; top: 40%;">
                  <div class="px-2 py-1 rounded-md text-sm font-bold" style="background-color: white; border: 2px solid rgba(0, 0, 0, 0.6); box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3); color: #000000;">
                    <span id="temp-3d-value">0.0</span>°C
                  </div>
                </div>
                
                <div id="humidity-value" class="absolute z-10 flex items-center justify-center" style="transform: translate(-50%, -50%) translateZ(40px) translateX(80px) translateY(-50px); left: 60%; top: 40%;">
                  <div class="px-2 py-1 rounded-md text-sm font-bold" style="background-color: white; border: 2px solid rgba(0, 0, 0, 0.6); box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3); color: #000000;">
                    <span id="humidity-3d-value">0.0</span>%
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Contrôles de rotation -->
          <div class="absolute bottom-3 right-3 flex gap-2">
            <button id="rotate-left" class="p-2 rounded-full shadow" style="background-color: rgba(0, 0, 0, 0.1); border: 2px solid rgba(0, 0, 0, 0.5); color: #000000; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);">
              <i class="fas fa-undo-alt"></i>
            </button>
            <button id="rotate-right" class="p-2 rounded-full shadow" style="background-color: rgba(0, 0, 0, 0.1); border: 2px solid rgba(0, 0, 0, 0.5); color: #000000; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);">
              <i class="fas fa-redo-alt"></i>
            </button>
            <button id="rotate-reset" class="p-2 rounded-full shadow" style="background-color: rgba(0, 0, 0, 0.1); border: 2px solid rgba(0, 0, 0, 0.5); color: #000000; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25);">
              <i class="fas fa-home"></i>
            </button>
          </div>
          
          <!-- Indicateur d'heure -->
          <div class="absolute top-3 left-3 px-3 py-1 rounded-lg text-xs font-medium" style="background-color: rgba(255, 255, 255, 0.8); color: #000000; border: 1px solid rgba(0, 0, 0, 0.3);">
            <i class="far fa-clock mr-1"></i><span id="time-display">12:00</span>
          </div>
        </div>
        
        <!-- Points de confort -->
        <div class="w-full lg:w-1/3 flex flex-col gap-4">
          <!-- Jauge de confort -->
          <div class="bg-white rounded-lg p-4" style="border: 1px solid rgba(0, 0, 0, 0.3); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);">
            <h4 class="text-sm font-semibold mb-2" style="color: #000000;">Indice de Confort</h4>
            <div class="relative h-6 bg-gradient-to-r from-blue-500 via-green-500 to-red-500 rounded-full overflow-hidden">
              <div id="comfort-marker" class="absolute top-0 w-4 h-6 bg-white" style="left: 45%; transform: translateX(-50%); border: 3px solid #000000; box-shadow: 0 0 8px #000000;"></div>
            </div>
            <div class="flex justify-between mt-1 text-xs text-gray-600">
              <span>Froid</span>
              <span>Confortable</span>
              <span>Chaud</span>
            </div>
            <p class="mt-2 text-center font-medium text-sm" style="color: #000000;" id="comfort-text">Conditions confortables</p>
          </div>
          
          <!-- Point de rosée -->
          <div class="bg-white rounded-lg p-4" style="border: 1px solid rgba(0, 0, 0, 0.3); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);">
            <h4 class="text-sm font-semibold mb-2" style="color: #000000;">Point de Rosée</h4>
            <p class="text-center text-lg font-bold" style="color: #000000;"><span id="dew-point">0.0</span>°C</p>
            <p class="text-xs text-center mt-1" style="color: #333333;" id="dew-point-desc">En dessous du point de rosée, l'humidité se condense</p>
          </div>
          
          <!-- Humidex / Indice de chaleur -->
          <div class="bg-white rounded-lg p-4" style="border: 1px solid rgba(0, 0, 0, 0.3); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);">
            <h4 class="text-sm font-semibold mb-2" style="color: #000000;">Indice de Chaleur</h4>
            <p class="text-center text-lg font-bold" style="color: #000000;"><span id="heat-index">0.0</span>°C</p>
            <p class="text-xs text-center mt-1" style="color: #333333;" id="heat-index-desc">Température ressentie combinant chaleur et humidité</p>
          </div>
        </div>
      </div>
    </div>
    
    
    <!-- Graphiques -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
      <!-- Graphique Température Ambiante -->
      <div class="bg-white rounded-xl shadow-md p-5 border border-gray-100 hover:shadow-lg">
        <h3 class="text-base font-semibold text-gray-600 mb-4">Évolution de la Température Ambiante</h3>
        <div class="relative w-full h-72">
          <div id="ambient-temp-chart" class="chart-container"></div>
          <div class="chart-zoom-controls">
            <button id="ambient-temp-zoom-in-btn" class="chart-zoom-btn" title="Zoomer">
              <i class="fas fa-search-plus"></i>
            </button>
            <button id="ambient-temp-zoom-out-btn" class="chart-zoom-btn" title="Dézoomer">
              <i class="fas fa-search-minus"></i>
            </button>
            <button id="ambient-temp-reset-zoom-btn" class="chart-zoom-btn" title="Réinitialiser le zoom">
              <i class="fas fa-home"></i>
            </button>
          </div>
          <div class="zoom-info">
            <i class="fas fa-info-circle"></i> Utilisez la molette pour zoomer et le clic-déplacer pour naviguer
          </div>
        </div>
      </div>
      
      <!-- Graphique Humidité Ambiante -->
      <div class="bg-white rounded-xl shadow-md p-5 border border-gray-100 hover:shadow-lg">
        <h3 class="text-base font-semibold text-gray-600 mb-4">Évolution de l'Humidité Ambiante</h3>
        <div class="relative w-full h-72">
          <div id="ambient-humidity-chart" class="chart-container"></div>
          <div class="chart-zoom-controls">
            <button id="ambient-humidity-zoom-in-btn" class="chart-zoom-btn" title="Zoomer">
              <i class="fas fa-search-plus"></i>
            </button>
            <button id="ambient-humidity-zoom-out-btn" class="chart-zoom-btn" title="Dézoomer">
              <i class="fas fa-search-minus"></i>
            </button>
            <button id="ambient-humidity-reset-zoom-btn" class="chart-zoom-btn" title="Réinitialiser le zoom">
              <i class="fas fa-home"></i>
            </button>
          </div>
          <div class="zoom-info">
            <i class="fas fa-info-circle"></i> Utilisez la molette pour zoomer et le clic-déplacer pour naviguer
          </div>
        </div>
      </div>
    </div>
    
    <!-- Historiques -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
      <!-- Historique Température Ambiante -->
      <div class="bg-white rounded-xl shadow-md p-5 overflow-hidden transition-shadow duration-200 ease-in-out border border-gray-100 hover:shadow-lg">
        <h3 class="text-base font-semibold text-gray-600 mb-3">Historique Température Ambiante</h3>
        <div class="max-h-60 overflow-y-auto">
          <table class="w-full text-sm text-gray-600 border-collapse">
            <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
              <tr>
                <th class="p-2 text-left border-b border-gray-200">Heure</th>
                <th class="p-2 text-center border-b border-gray-200">Température (°C)</th>
                <th class="p-2 text-center border-b border-gray-200">Statut</th>
                <th class="p-2 text-center border-b border-gray-200">Variation</th>
              </tr>
            </thead>
            <tbody id="ambient-temp-history">
              <tr>
                <td colspan="4" class="text-center text-gray-400 p-2">
                  Aucune donnée historique
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      
      <!-- Historique Humidité Ambiante -->
      <div class="bg-white rounded-xl shadow-md p-5 overflow-hidden transition-shadow duration-200 ease-in-out border border-gray-100 hover:shadow-lg">
        <h3 class="text-base font-semibold text-gray-600 mb-3">Historique Humidité Ambiante</h3>
        <div class="max-h-60 overflow-y-auto">
          <table class="w-full text-sm text-gray-600 border-collapse">
            <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
              <tr>
                <th class="p-2 text-left border-b border-gray-200">Heure</th>
                <th class="p-2 text-center border-b border-gray-200">Humidité (%)</th>
                <th class="p-2 text-center border-b border-gray-200">Statut</th>
                <th class="p-2 text-center border-b border-gray-200">Variation</th>
              </tr>
            </thead>
            <tbody id="ambient-humidity-history">
              <tr>
                <td colspan="4" class="text-center text-gray-400 p-2">
                  Aucune donnée historique
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
    
    <!-- Gestion des données -->
    <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100">
      <h3 class="text-base font-semibold text-gray-600 mb-4">Gestion des données</h3>
      
      <div class="flex flex-wrap gap-3">
        <button onclick="showAmbientFullHistory()" class="btn-gestion">
          <i class="fas fa-history"></i>
          <span>Historique complet</span>
        </button>
        
        <button onclick="exportAmbientData('xlsx')" class="btn-gestion">
          <i class="fas fa-file-excel"></i>
          <span>Exporter Excel</span>
        </button>
        
        <button onclick="exportAmbientToPDF()" class="btn-gestion">
          <i class="fas fa-file-pdf"></i>
          <span>PDF (.pdf)</span>
        </button>
        
        <button onclick="exportAmbientChartImage()" class="btn-gestion">
          <i class="fas fa-camera"></i>
          <span>Exporter Image</span>
        </button>
        
        <button onclick="resetAmbientData()" class="btn-gestion">
          <i class="fas fa-trash-alt"></i>
          <span>Réinitialiser</span>
        </button>
      </div>
    </div>
  </section>

<!-- Section Retenue -->
<section id="retenue-section" class="py-4 hidden">
  <h2 class="text-xl font-bold mb-6 text-gray-800 flex items-center">
    <div class="mr-3 w-10 h-10 flex items-center justify-center rounded-lg text-xl bg-teal-50 text-teal-600 flex-shrink-0">
      <i class="fas fa-water"></i>
    </div>
    Gestion de la Retenue
  </h2>

  <!-- Grille des cartes principales en 2x3 - CORRECTION IMPORTANTE -->
  <div class="grid grid-cols-3 gap-4 mb-6">
    <!-- Première rangée -->
    <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-teal-500 to-teal-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
      <h3 class="uppercase tracking-wider text-sm font-medium mb-2 text-center">
        Capacité initiale de stockage<br/>(Million de m³)
      </h3>
      <div class="flex flex-col items-center mt-4">
        <p class="text-3xl font-bold">42,11</p>
      </div>
    </div>

    <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-blue-500 to-blue-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
      <i class="fas fa-wifi absolute top-3 right-3 opacity-70"></i>
      <h3 class="uppercase tracking-wider text-sm font-medium mb-2 text-center">
        Stock d'eau du jour<br/>(Million de m³)
      </h3>
      <div class="flex flex-col items-center mt-4">
        <p class="text-3xl font-bold" id="current-stock">28.75</p>
      </div>
    </div>

    <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-green-500 to-green-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
      <h3 class="uppercase tracking-wider text-sm font-medium mb-2 text-center">
        Taux de remplissage<br/>(%)
      </h3>
      <div class="flex flex-col items-center mt-4">
        <p class="text-3xl font-bold" id="current-fill-rate">68.3</p>
      </div>
    </div>

    <!-- Deuxième rangée -->
    <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-amber-500 to-amber-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
      <h3 class="uppercase tracking-wider text-sm font-medium mb-2 text-center">
        Taux d'envasement<br/>(%)
      </h3>
      <div class="flex flex-col items-center mt-4">
        <p class="text-3xl font-bold" id="current-siltation">64.9</p>
      </div>
    </div>

    <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-indigo-500 to-indigo-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
      <h3 class="uppercase tracking-wider text-sm font-medium mb-2 text-center">
        Évaporation de la retenue<br/>(%)
      </h3>
      <div class="flex flex-col items-center mt-4">
        <p class="text-3xl font-bold" id="current-evaporation">3.4</p>
      </div>
    </div>

    <div class="rounded-xl shadow-lg text-white p-6 relative bg-gradient-to-br from-red-500 to-red-700 transition-transform duration-200 ease-in-out hover:-translate-y-1 hover:shadow-xl">
      <h3 class="uppercase tracking-wider text-sm font-medium mb-2 text-center">
        Lâché d'eau<br/>(Million m³)
      </h3>
      <div class="flex flex-col items-center mt-4">
        <p class="text-3xl font-bold" id="current-release">0.86</p>
      </div>
    </div>
  </div>
 <h2 class="text-xl font-bold mb-6 text-gray-800 ">
    <div class="mr-3 w-10 h-10 flex items-center justify-center rounded-lg text-xl bg-teal-50 text-teal-600 flex-shrink-0">
    </div>
    Niveau de la Retenue actuel
  </h2>
  <!-- Niveau de la Retenue avec visualisation animée 3D -->
<br/> 
<div class="container max-w-4xl mx-auto mb-6">
    <div class="water-container w-full max-w-xl mx-auto mb-8">
        <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">Niveau de la Retenue</h3>
        <div
            class="water-block relative h-72 w-full rounded-2xl border-4 border-gray-300 bg-white shadow-lg"
            style="transform-style: preserve-3d;"
            id="retenue-visualization"
        >
            <div class="inner-border absolute inset-0 rounded-lg border-2 border-gray-200"></div>

            <div
                class="water-fill absolute bottom-0 left-0 right-0 overflow-hidden rounded-b-lg"
                style="height: 68.3%;"
                id="retenue-water"
            >
                <div class="wave wave-back absolute bottom-0 left-0 w-[200%] h-full bg-gradient-to-r from-blue-400/40 via-blue-400/30 to-blue-400/40 animate-waveSlide blur-sm mix-blend-multiply"></div>
                <div class="wave wave-front absolute bottom-0 left-0 w-[200%] h-full bg-gradient-to-r from-blue-600/90 via-blue-700/90 to-blue-600/90 animate-waveSlideFast mix-blend-multiply" style="animation-delay: -2s"></div>
            </div>

            <div
                class="level-marker absolute left-4 flex items-center"
                style="bottom: 68.3%;"
                id="retenue-level-marker"
            >
                <div class="marker-line h-0.5 w-8 bg-red-600"></div>
                <span class="marker-value ml-2 rounded bg-red-100 px-1.5 py-0.5 text-xs font-semibold text-red-700">
                    <span id="retenue-marker-value">181.18</span> m
                </span>
            </div>

            <div class="y-axis-labels absolute top-0 bottom-0 left-3 flex flex-col justify-between py-4 px-1 text-xs text-gray-600 select-none pointer-events-none" id="retenue-axis-labels">
                <span>200 m</span>
                <span>190 m</span>
                <span>180 m</span>
            </div>
        </div>
    </div>

    <div
        class="toggle-line h-1 max-w-xl mx-auto bg-black cursor-pointer"
        title="Cliquer trois fois pour afficher / cacher le panneau"
        id="retenue-toggle-line"
    ></div>

    <div
        class="sliding-panel fixed bottom-0 left-0 right-0 z-50 transform bg-white shadow-lg transition-transform max-w-xl mx-auto rounded-t-xl"
        style="transition-duration: 0.5s; transform: translateY(100%);"
        id="retenue-sliding-panel"
    >
      <div class="panel-content relative p-6">
            <button
                class="close-button absolute top-2 right-2 flex h-8 w-8 items-center justify-center rounded-full bg-gray-200 hover:bg-gray-300"
                id="retenue-close-panel"
                aria-label="Fermer le panneau"
            >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>

            <button
                class="button gray mb-4 flex w-full items-center justify-center gap-2 rounded-md bg-gray-700 px-4 py-2 text-white hover:bg-gray-800"
                id="retenue-return-to-line"
            >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14M5 12l4 4m-4-4l4-4" />
                </svg>
                Revenir au trait noir
            </button>

            <button
                class="button indigo mb-4 flex w-full items-center justify-center gap-2 rounded-md bg-indigo-600 px-4 py-2 text-white hover:bg-indigo-700"
                id="retenue-calibrage-button"
            >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                </svg>
                Mode précis
            </button>

            <div class="slider-container mb-4">
                <label for="retenue-level-slider" class="slider-label mb-2 block text-gray-700">
                    Ajuster le niveau (m)
                </label>
                <input
                    id="retenue-level-slider"
                    type="range"
                    min="177.25"
                    max="200"
                    step="0.01"
                    value="181.18"
                    class="slider w-full cursor-pointer rounded border border-gray-300"
                />
                <div class="slider-value mt-1 text-center text-sm text-gray-600">
                    Niveau actuel : <span id="retenue-slider-value">181.18</span> m
                </div>
            </div>

            <button
                class="button flex w-full items-center justify-center gap-2 rounded-md px-4 py-2 text-white bg-blue-600 hover:bg-blue-700"
                id="retenue-simulation-button"
            >
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Démarrer la simulation
            </button>
        </div>
    </div>
</div>


  <!-- Graphique d'évolution des données - AMÉLIORÉ -->
  <div class="bg-white rounded-xl shadow-md p-5 mb-6">
    <h3 class="text-base font-semibold text-gray-600 mb-4">Évolution des données</h3>
    
    <!-- Options de filtrage du graphique -->
    <div class="flex flex-wrap gap-2 mb-4 p-3 bg-gray-50 rounded-lg">
      <div class="text-sm font-medium text-gray-700 mr-2">Afficher:</div>
      
      <button onclick="toggleAllFilters(true)" class="px-3 py-1 text-xs rounded-md bg-blue-600 text-white mr-2">
        <i class="fas fa-list mr-1"></i>
        Tout afficher
      </button>
      
      <button onclick="toggleAllFilters(false)" class="px-3 py-1 text-xs rounded-md bg-gray-600 text-white mr-2">
        <i class="fas fa-times mr-1"></i>
        Tout masquer
      </button>
      
      <div class="w-full h-0 border-t border-gray-200 my-2"></div>
      
      <button onclick="toggleFilter('niveau')" class="px-2 py-1 text-xs rounded-full bg-blue-100 text-blue-700" id="filter-niveau">
        <span class="inline-block w-2 h-2 rounded-full mr-1 bg-blue-600"></span>
        Niveau
      </button>
      
      <button onclick="toggleFilter('stock')" class="px-2 py-1 text-xs rounded-full bg-teal-100 text-teal-700" id="filter-stock">
        <span class="inline-block w-2 h-2 rounded-full mr-1 bg-teal-600"></span>
        Stock
      </button>
      
      <button onclick="toggleFilter('taux')" class="px-2 py-1 text-xs rounded-full bg-green-100 text-green-700" id="filter-taux">
        <span class="inline-block w-2 h-2 rounded-full mr-1 bg-green-600"></span>
        Taux remplissage
      </button>
      
      <button onclick="toggleFilter('envasement')" class="px-2 py-1 text-xs rounded-full bg-amber-100 text-amber-700" id="filter-envasement">
        <span class="inline-block w-2 h-2 rounded-full mr-1 bg-amber-600"></span>
        Envasement
      </button>
      
      <button onclick="toggleFilter('evaporation')" class="px-2 py-1 text-xs rounded-full bg-indigo-100 text-indigo-700" id="filter-evaporation">
        <span class="inline-block w-2 h-2 rounded-full mr-1 bg-indigo-600"></span>
        Évaporation
      </button>
      
      <button onclick="toggleFilter('laches')" class="px-2 py-1 text-xs rounded-full bg-red-100 text-red-700" id="filter-laches">
        <span class="inline-block w-2 h-2 rounded-full mr-1 bg-red-600"></span>
        Lâchés d'eau
      </button>
    </div>
    
    <div class="relative w-full h-96 bg-gray-50 rounded-lg p-4 overflow-hidden">
      <!-- Conteneur pour le graphique Chart.js -->
      <div id="retenue-evolution-chart" style="width: 100%; height: 100%;"></div>
    </div>
  </div>

  <!-- Jauges et indicateurs en 1x3 -->
  <div class="grid grid-cols-3 gap-6 mb-6">
      <!-- Jauge de taux de remplissage -->
      <div class="bg-white rounded-xl shadow-md p-5 border border-gray-100">
        <h3 class="text-base font-semibold text-gray-600 mb-3">
          <i class="fas fa-chart-bar h-5 w-5 inline mr-2 text-blue-600"></i>
          Taux de remplissage
        </h3>
        <div class="flex justify-center">
          <div class="w-40 h-40 relative">
            <!-- Cercle de fond -->
            <svg class="w-full h-full" viewBox="0 0 100 100">
              <!-- Cercle de fond -->
              <circle cx="50" cy="50" r="45" fill="none" stroke="#e5e7eb" stroke-width="10" />
              
              <!-- Cercle de progression -->
              <circle id="retenue-fill-gauge" cx="50" cy="50" r="45" fill="none" stroke="#3b82f6" stroke-width="10" 
                     stroke-dasharray="283" stroke-dashoffset="89.711" transform="rotate(-90 50 50)" />
            </svg>
            <!-- Texte central -->
            <div class="absolute inset-0 flex flex-col items-center justify-center">
              <span id="retenue-fill-rate-display" class="text-2xl font-bold text-blue-600">68.3%</span>
              <span class="text-xs text-gray-500">Remplissage</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Jauge du stock d'eau -->
      <div class="bg-white rounded-xl shadow-md p-5 border border-gray-100">
        <h3 class="text-base font-semibold text-gray-600 mb-3">
          <i class="fas fa-water h-5 w-5 inline mr-2 text-teal-600"></i>
          Stock d'eau
        </h3>
        <div class="flex justify-center">
          <div class="w-40 h-40 relative">
            <!-- Cercle de fond -->
            <svg class="w-full h-full" viewBox="0 0 100 100">
              <!-- Cercle de fond -->
              <circle cx="50" cy="50" r="45" fill="none" stroke="#e5e7eb" stroke-width="10" />
              
              <!-- Cercle de progression -->
              <circle id="retenue-stock-gauge" cx="50" cy="50" r="45" fill="none" stroke="#10b981" stroke-width="10" 
                     stroke-dasharray="283" stroke-dashoffset="171.9953" transform="rotate(-90 50 50)" />
            </svg>
            <!-- Texte central -->
            <div class="absolute inset-0 flex flex-col items-center justify-center">
              <span id="retenue-stock-display" class="text-2xl font-bold text-teal-600">28.75</span>
              <span class="text-xs text-gray-500">million m³</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Tendance du niveau d'eau -->
      <div class="bg-white rounded-xl shadow-md p-5 border border-gray-100">
        <h3 class="text-base font-semibold text-gray-600 mb-3">
          <i class="fas fa-chart-line h-5 w-5 inline mr-2 text-indigo-600"></i>
          Tendance du niveau
        </h3>
        <div class="flex justify-center">
          <div class="w-40 h-40 relative">
            <div class="w-full h-full flex items-center justify-center">
              <svg id="retenue-trend-icon" xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />
              </svg>
            </div>
            <div class="absolute inset-0 flex flex-col items-center justify-center mt-20">
              <span id="retenue-trend-text" class="text-sm font-medium text-green-600">En hausse</span>
              <span id="retenue-trend-value" class="text-sm font-bold text-green-600">+0.26 m</span>
            </div>
          </div>
        </div>
      </div>
    </div>

  <!-- Tableau complet des indicateurs -->
  <div class="bg-white rounded-xl shadow-md p-5 mb-6">
    <h3 class="text-base font-semibold text-gray-600 mb-4">Tableau complet des indicateurs</h3>
    <div class="overflow-x-auto">
      <table class="w-full text-sm text-gray-600 border-collapse">
        <thead class="bg-purple-50 text-purple-700 uppercase text-xs">
          <tr>
            <th class="p-3 text-left border-b border-purple-100">Date</th>
            <th class="p-3 text-center border-b border-purple-100">Niveau (m)</th>
            <th class="p-3 text-center border-b border-purple-100">Stock (Mm³)</th>
            <th class="p-3 text-center border-b border-purple-100">Remplissage (%)</th>
            <th class="p-3 text-center border-b border-purple-100">Envasement (%)</th>
            <th class="p-3 text-center border-b border-purple-100">Évaporation (%)</th>
            <th class="p-3 text-center border-b border-purple-100">Lâchés d'eau (Mm³)</th>
          </tr>
        </thead>
        <tbody>
          <tr class="hover:bg-purple-50">
            <td class="p-3 border-b border-purple-100">29/04/2025</td>
            <td class="p-3 text-center border-b border-purple-100">181.18</td>
            <td class="p-3 text-center border-b border-purple-100">28.75</td>
            <td class="p-3 text-center border-b border-purple-100">68.3</td>
            <td class="p-3 text-center border-b border-purple-100">64.9</td>
            <td class="p-3 text-center border-b border-purple-100">3.4</td>
            <td class="p-3 text-center border-b border-purple-100">0.86</td>
          </tr>
          <tr class="hover:bg-purple-50">
            <td class="p-3 border-b border-purple-100">28/04/2025</td>
            <td class="p-3 text-center border-b border-purple-100">180.92</td>
            <td class="p-3 text-center border-b border-purple-100">26.88</td>
            <td class="p-3 text-center border-b border-purple-100">63.8</td>
            <td class="p-3 text-center border-b border-purple-100">61.7</td>
            <td class="p-3 text-center border-b border-purple-100">3.2</td>
            <td class="p-3 text-center border-b border-purple-100">0.81</td>
          </tr>
          <tr class="hover:bg-purple-50">
            <td class="p-3 border-b border-purple-100">27/04/2025</td>
            <td class="p-3 text-center border-b border-purple-100">180.75</td>
            <td class="p-3 text-center border-b border-purple-100">25.64</td>
            <td class="p-3 text-center border-b border-purple-100">60.9</td>
            <td class="p-3 text-center border-b border-purple-100">57.9</td>
            <td class="p-3 text-center border-b border-purple-100">3.0</td>
            <td class="p-3 text-center border-b border-purple-100">0.77</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Boutons de gestion -->
   <!-- Gestion des données -->
   <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100">
    <h3 class="text-base font-semibold text-gray-600 mb-4">Gestion des données</h3>
    
    <div class="flex flex-wrap gap-3">
      <button onclick="showRetenueFullHistory()" class="btn-gestion">
        <i class="fas fa-history"></i>
        <span>Historique complet</span>
      </button>
      
      <button onclick="exportRetenueData('xlsx')" class="btn-gestion">
        <i class="fas fa-file-excel"></i>
        <span>Exporter Excel</span>
      </button>
      
      <button onclick="exportRetenueToPDF()" class="btn-gestion">
        <i class="fas fa-file-pdf"></i>
        <span>PDF (.pdf)</span>
      </button>
      
      <button onclick="exportAmbientChartImage()" class="btn-gestion">
        <i class="fas fa-camera"></i>
        <span>Exporter Image</span>
      </button>
      
      <button onclick="resetRetenueData()" class="btn-gestion">
        <i class="fas fa-trash-alt"></i>
        <span>Réinitialiser</span>
      </button>
    </div>
  </div>
</section>
        </div>
      </div>
    </main>
  </div>


  <!-- JavaScript -->
  <script>

 let chart = null;
let socket = null;
let temperatureChart = null;
let humidityChart = null;
let rainChart = null;
let ambientTempChart = null;
let ambientHumidityChart = null;
let roomRotationX = 20;
let roomRotationY = 30;
let animationFrameId = null;
let raindropElements = [];

// Variables globales pour la section Retenue
// Variables globales pour la section Retenue
let retenueChart = null;
let retenueSimulationActive = false;
let retenueSimulationInterval = null;
let retenuePanelVisible = false;
let retenueClickCount = 0;
let retenueCalibrageMode = "standard";


// Ajoutez ceci avec vos autres variables globales (après retenueRotationAngle)
const retenueFilters = {
    niveau: true,
    stock: true,
    taux: true,
    envasement: true,
    evaporation: true,
    laches: true
};

const RETENUE_MAX_CAPACITY = 42.11; // Capacité maximale en millions de m³

// Données pour le graphique d'évolution de la retenue
const retenueChartData = [
  { date: '24/04', niveau: 181.82, stock: 33.50, taux: 79.6 },
  { date: '25/04', niveau: 181.65, stock: 32.10, taux: 76.2 },
  { date: '26/04', niveau: 181.30, stock: 29.70, taux: 70.5 },
  { date: '27/04', niveau: 180.75, stock: 25.64, taux: 60.9 },
  { date: '28/04', niveau: 180.92, stock: 26.88, taux: 63.8 },
  { date: '29/04', niveau: 181.18, stock: 28.75, taux: 68.3 }
];

// Données pour le tableau de la retenue
const retenueTableData = [
  { date: '29/04/2025', level: 181.18, stock: 28.75, rate: 68.3, silt: 64.9, evap: 3.4, release: 0.86 },
  { date: '28/04/2025', level: 180.92, stock: 26.88, rate: 63.8, silt: 61.7, evap: 3.2, release: 0.81 },
  { date: '27/04/2025', level: 180.75, stock: 25.64, rate: 60.9, silt: 57.9, evap: 3.0, release: 0.77 }
];
  

  // State variables
const state = {
    activeSection: 'water-section',
    connectionStatus: 'connecting',
    sensorData: {
        distance1: 0,
        distance2: 0,
        flow1: 0,
        flow2: 0,
        soilTemperature: 0,
        soilHumidity: 0,
        rainAmount: 0,
        ambientTemperature: 0,  // Ajouté
        ambientHumidity: 0      // Ajouté
    },
    sensorHistory: {
        flow1: [],
        flow2: [],
        soilTemperature: [],
        soilHumidity: [],
        rainAmount: [],
        ambientTemperature: [],  // Ajouté
        ambientHumidity: []      // Ajouté
    },
    chartData: [],
    dataIndex: 0,
    temperatureChartData: [],
    temperatureDataIndex: 0,
    humidityChartData: [],
    humidityDataIndex: 0,
    rainChartData: [],
    rainDataIndex: 0,
    ambientTempChartData: [],    // Ajouté
    ambientTempDataIndex: 0,     // Ajouté
    ambientHumidityChartData: [], // Ajouté
    ambientHumidityDataIndex: 0, // Ajouté
    simulationInterval: null,
    zoomLevel: 1,
    animateDrops: true 
            // Ajouté
};

    // Constants
    const MAX_HISTORY = 10; 

    // DOM elements
 // DOM elements
 const elements = {
    sections: {}, // Laisser vide et remplir dynamiquement
    navLinks: document.querySelectorAll('.nav-link'),
    connectionStatus: document.getElementById('connection-status'),
    distance1: document.getElementById('distance1'),
    distance2: document.getElementById('distance2'),
    flow1: document.getElementById('flow1'),
    flow2: document.getElementById('flow2'),
    soilTemperature: document.getElementById('soilTemperature'),
    soilHumidity: document.getElementById('soilHumidity'),
    flow1History: document.getElementById('flow1-history'),
    flow2History: document.getElementById('flow2-history'),
    temperatureHistory: document.getElementById('temperature-history'),
    humidityHistory: document.getElementById('humidity-history'),
    waterLevelChart: document.getElementById('water-level-chart'),
    rainAmount: document.getElementById('rainAmount'),
    rainHistory: document.getElementById('rain-history'),
    
    // Nouveaux éléments pour la section ambiante
    ambientTemperature: document.getElementById('ambientTemperature'),
    ambientHumidity: document.getElementById('ambientHumidity'),
    ambientTempHistory: document.getElementById('ambient-temp-history'),
    ambientHumidityHistory: document.getElementById('ambient-humidity-history'),
    comfortMarker: document.getElementById('comfort-marker'),
    comfortText: document.getElementById('comfort-text'),
    dewPoint: document.getElementById('dew-point'),
    dewPointDesc: document.getElementById('dew-point-desc'),
    heatIndex: document.getElementById('heat-index'),
    heatIndexDesc: document.getElementById('heat-index-desc'),
    tempIndicator: document.getElementById('temp-indicator'),
    temp3dValue: document.getElementById('temp-3d-value'),
    humidity3dValue: document.getElementById('humidity-3d-value'),
    humidityDrops: document.getElementById('humidity-drops'),
    roomContainer: document.getElementById('room-container')
};
  
// Fonction pour initialiser les sections dynamiquement
function initializeSections() {
    const sectionIds = ['water-section', 'temperature-section', 'humidity-section', 'rain-section', 'ambient-section', 'retenue-section'];
    
    sectionIds.forEach(id => {
        const section = document.getElementById(id);
        if (section) {
            elements.sections[id] = section;
        } else {
            console.warn(`Section ${id} non trouvée dans le DOM`);
        }
    });
}

// Vérification des dépendances
    function verifyDependencies() {
        const issues = [];
        
        if (typeof io === 'undefined') {
            console.error("Socket.io non chargé");
            issues.push("Socket.io non chargé - La connexion en temps réel ne fonctionnera pas");
        }

        if (typeof Chart === 'undefined') {
            console.error("Chart.js non chargé");
            issues.push("Chart.js non chargé - Le graphique ne fonctionnera pas");
        }
        
        if (typeof Chart !== 'undefined' && typeof Chart.plugins === 'object' && !Chart.plugins._plugins.some(p => p.id === 'zoom')) {
            console.warn("Plugin Zoom pour Chart.js non détecté");
            issues.push("Plugin Zoom pour Chart.js non chargé - Le zoom du graphique sera limité");
        }

        if (issues.length > 0) {
            showError(issues);
            return false;
        }
        return true;
    }

    function showError(issues) {
        const container = document.getElementById('water-level-chart') || document.body;
        container.innerHTML = `
            <div class="p-4 bg-red-50 border border-red-200 rounded-lg">
                <h3 class="font-bold text-red-600 mb-2">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    Erreur de chargement
                </h3>
                <ul class="list-disc pl-5 text-red-700">
                    ${issues.map(issue => `<li>${issue}</li>`).join('')}
                </ul>
                <button onclick="window.location.reload()" 
                        class="mt-3 bg-red-100 hover:bg-red-200 text-red-800 px-3 py-1 rounded">
                    <i class="fas fa-sync-alt mr-2"></i>Recharger
                </button>
            </div>
        `;
    }

    function initApp() {
    console.log("Initialisation de l'application...");
    
    if (!verifyDependencies()) {
        console.error("Dépendances manquantes");
        return;
    }
    
    // Initialiser les sections dynamiquement
    initializeSections();
    
    loadFromLocalStorage();
    initUI();
    
    // Initialiser les graphiques avec des données par défaut si vide
    if (state.chartData.length === 0) {
        console.log("Aucune donnée de niveau d'eau existante, initialisation avec des valeurs par défaut");
        updateChartData(0, 0);
    } else {
        console.log("Données de niveau d'eau existantes chargées, rendu du graphique");
        renderChart();
    }
    
    if (state.temperatureChartData.length === 0) {
        console.log("Aucune donnée de température existante, initialisation avec des valeurs par défaut");
        updateTemperatureChartData(20);
    } else {
        console.log("Données de température existantes chargées");
    }
    
    if (state.humidityChartData.length === 0) {
        console.log("Aucune donnée d'humidité existante, initialisation avec des valeurs par défaut");
        updateHumidityChartData(50);
    } else {
        console.log("Données d'humidité existantes chargées");
    }
    
    if (state.rainChartData.length === 0) {
        console.log("Aucune donnée de pluie existante, initialisation avec des valeurs par défaut");
        updateRainChartData(2.5);
    } else {
        console.log("Données de pluie existantes chargées");
    }
    
    if (state.ambientTempChartData.length === 0) {
        console.log("Aucune donnée de température ambiante existante, initialisation avec des valeurs par défaut");
        updateAmbientTempChartData(22.5);
    } else {
        console.log("Données de température ambiante existantes chargées");
    }
    
    if (state.ambientHumidityChartData.length === 0) {
        console.log("Aucune donnée d'humidité ambiante existante, initialisation avec des valeurs par défaut");
        updateAmbientHumidityChartData(55);
    } else {
        console.log("Données d'humidité ambiante existantes chargées");
    }
    
    // Initialisation de la section retenue avec protection
    try {
        if (document.getElementById('retenue-section')) {
            addRetenueLink();
            setupRetenueControls();
            initRetenueSection();

            if (state.activeSection === 'retenue-section') {
                renderRetenueChart();
                updateRetenue3DVisualisation();
            }
        }
    } catch (error) {
        console.error("Erreur lors de l'initialisation de la section retenue:", error);
        // Ne pas bloquer le reste de l'application
    }
    
    // Nettoyer les données anciennes au démarrage
    cleanupOldData();
    
    // Mettre en place un nettoyage périodique (toutes les heures)
    setInterval(cleanupOldData, 60 * 60 * 1000);
    
    // Démarrer la connexion Socket.io
    initSocketConnection();
    
    // Démarrer la vérification de connexion après un délai
    setTimeout(() => {
        if (state.connectionStatus === 'connecting') {
            console.log("Connexion toujours en cours, démarrage du mode simulation");
            simulateDataIfNeeded();
        }
    }, 5000);
    
    // Nettoyage
    window.addEventListener('beforeunload', () => {
        if (socket) socket.disconnect();
        if (state.simulationInterval) {
            clearInterval(state.simulationInterval);
        }
    });
    
    // Vérifier et initialiser les graphiques ambiants
    if (state.activeSection === 'ambient-section') {
        setTimeout(() => {
            if (!ambientTempChart && state.ambientTempChartData.length > 0) {
                renderAmbientTempChart();
            }
            if (!ambientHumidityChart && state.ambientHumidityChartData.length > 0) {
                renderAmbientHumidityChart();
            }
        }, 100);
    }
}

// Gestion globale des erreurs
window.onerror = function(msg, url, lineNo, columnNo, error) {
    console.error('Erreur globale:', msg, 'à', url, 'ligne', lineNo);
    // Ne pas bloquer l'exécution
    return false;
};


    function simulateDataIfNeeded() {
        if (state.connectionStatus !== 'connecting' || state.simulationInterval) return;

        console.log('Server connection timeout, starting simulation...');
        
        // Initialiser les graphiques si pas déjà fait
        if (!chart && state.chartData.length === 0) {
            updateChartData(30, 25);
        }
        
        if (!temperatureChart && state.temperatureChartData.length === 0) {
            updateTemperatureChartData(20);
        }
        
        if (!humidityChart && state.humidityChartData.length === 0) {
            updateHumidityChartData(50);
        }
        if (!rainChart && state.rainChartData.length === 0) {
        updateRainChartData(2.5);
    }

    if (!ambientTempChart && state.ambientTempChartData.length === 0) {
        updateAmbientTempChartData(22.5);
    }
    
    if (!ambientHumidityChart && state.ambientHumidityChartData.length === 0) {
        updateAmbientHumidityChartData(55);
    }

        state.simulationInterval = setInterval(() => {
            const mockData = {
                distance1: 30 + Math.random() * 40,
                distance2: 25 + Math.random() * 40,
                soilTemperature: 20 + Math.random() * 10,
                soilHumidity: 40 + Math.random() * 30,
                rainAmount: Math.random() * 10 ,
                ambientTemperature: 20 + Math.random() * 10,
                ambientHumidity: 40 + Math.random() * 40
            };
            updateSensorData(mockData);
        }, 2000);

         // Si la section de climat est active, démarrer l'animation des gouttes
    if (state.activeSection === 'ambient-section') {
        startRaindropsAnimation();
    }

        const statusEl = document.getElementById('connection-status');
        statusEl.classList.remove('bg-yellow-100', 'text-yellow-800');
        statusEl.classList.add('bg-green-100', 'text-green-800');
        statusEl.innerHTML = '<i class="fas fa-exclamation-circle mr-2"></i>Mode démo';
    }

    function initUI() {
        const navLinks = document.querySelectorAll('.nav-link');
        navLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const sectionId = link.getAttribute('data-section');
                setActiveSection(sectionId);
            });
        });
        
        // Init zoom controls pour le niveau d'eau
        document.getElementById('zoom-in-btn').addEventListener('click', function() {
            zoomChart(0.2);
        });
        
        document.getElementById('zoom-out-btn').addEventListener('click', function() {
            zoomChart(-0.2);
        });
        
        document.getElementById('reset-zoom-btn').addEventListener('click', function() {
            resetZoom();
        });
        
        // Init zoom controls pour la température
        document.getElementById('temp-zoom-in-btn').addEventListener('click', function() {
            zoomTemperatureChart(0.2);
        });
        
        document.getElementById('temp-zoom-out-btn').addEventListener('click', function() {
            zoomTemperatureChart(-0.2);
        });
        
        document.getElementById('temp-reset-zoom-btn').addEventListener('click', function() {
            resetTemperatureZoom();
        });
        
        // Init zoom controls pour l'humidité
        document.getElementById('humidity-zoom-in-btn').addEventListener('click', function() {
            zoomHumidityChart(0.2);
        });
        
        document.getElementById('humidity-zoom-out-btn').addEventListener('click', function() {
            zoomHumidityChart(-0.2);
        });
        
        document.getElementById('humidity-reset-zoom-btn').addEventListener('click', function() {
            resetHumidityZoom();
        });
   
        // Init zoom controls pour la pluie
    document.getElementById('rain-zoom-in-btn').addEventListener('click', function() {
        zoomRainChart(0.2);
    });
    
    document.getElementById('rain-zoom-out-btn').addEventListener('click', function() {
        zoomRainChart(-0.2);
    });
    
    document.getElementById('rain-reset-zoom-btn').addEventListener('click', function() {
        resetRainZoom();
    });
   
      // Init zoom controls pour la température ambiante
      document.getElementById('ambient-temp-zoom-in-btn').addEventListener('click', function() {
        zoomAmbientTempChart(0.2);
    });
    
    document.getElementById('ambient-temp-zoom-out-btn').addEventListener('click', function() {
        zoomAmbientTempChart(-0.2);
    });
    
    document.getElementById('ambient-temp-reset-zoom-btn').addEventListener('click', function() {
        resetAmbientTempZoom();
    });
    
    // Init zoom controls pour l'humidité ambiante
    document.getElementById('ambient-humidity-zoom-in-btn').addEventListener('click', function() {
        zoomAmbientHumidityChart(0.2);
    });
    
    document.getElementById('ambient-humidity-zoom-out-btn').addEventListener('click', function() {
        zoomAmbientHumidityChart(-0.2);
    });
    
    document.getElementById('ambient-humidity-reset-zoom-btn').addEventListener('click', function() {
        resetAmbientHumidityZoom();
    });
  
    // Contrôles de rotation 3D
    document.getElementById('rotate-left').addEventListener('click', function() {
        roomRotationY -= 45;
        updateRoomRotation();
    });
    
    document.getElementById('rotate-right').addEventListener('click', function() {
        roomRotationY += 45;
        updateRoomRotation();
    });
    
    document.getElementById('rotate-reset').addEventListener('click', function() {
        roomRotationX = 20;
        roomRotationY = 30;
        updateRoomRotation();
    });
    
    // Initialiser l'animation des gouttes si on est sur la section climatique
    if (state.activeSection === 'ambient-section') {
        startRaindropsAnimation();
    }

  }

  // Fonction pour mettre à jour la retenue depuis le serveur
function updateRetenueFromServer(data) {
    // Ne pas mettre à jour si c'est nous qui avons envoyé le changement
    if (data.isLocalChange) return;
    
    // Mettre à jour le niveau
    if (data.level !== undefined) {
        const levelSlider = document.getElementById('retenue-level-slider');
        if (levelSlider) {
            levelSlider.value = data.level;
        }
        updateRetenueBasedOnLevel(data.level, false); // false = pas d'émission vers le serveur
    }
    
    // Mettre à jour les autres valeurs
    if (data.stock !== undefined) {
        const currentStock = document.getElementById('current-stock');
        if (currentStock) currentStock.textContent = data.stock;
    }
    
    if (data.fillRate !== undefined) {
        const currentFillRate = document.getElementById('current-fill-rate');
        if (currentFillRate) currentFillRate.textContent = data.fillRate;
    }
    
    if (data.siltation !== undefined) {
        const currentSiltation = document.getElementById('current-siltation');
        if (currentSiltation) currentSiltation.textContent = data.siltation;
    }
    
    if (data.evaporation !== undefined) {
        const currentEvaporation = document.getElementById('current-evaporation');
        if (currentEvaporation) currentEvaporation.textContent = data.evaporation;
    }
    
    if (data.release !== undefined) {
        const currentRelease = document.getElementById('current-release');
        if (currentRelease) currentRelease.textContent = data.release;
    }
}

  function initSocketConnection() {
    console.log("Initialisation de la connexion Socket.io...");
    
    // Vérifier si Socket.io est disponible
    if (typeof io === 'undefined') {
        console.error("Socket.io n'est pas disponible. Passage en mode simulation.");
        startSimulationIfDisconnected();
        return;
    }
    
    try {
        console.log("Tentative de connexion à https://server-cassur.onrender.com");
        
        // Arrêter toute connexion existante
        if (socket) {
            socket.disconnect();
            socket = null;
        }
        
        // Initialisation de Socket.io avec des options de base
        socket = io('https://server-cassur.onrender.com', {
            reconnectionAttempts: 3,
            timeout: 5000,
            transports: ['websocket', 'polling']
        });
        
        // Ajouter un log pour suivre la progression
        console.log("Socket.io initialisé, en attente de connexion...");
        
        socket.on('connect', () => {
            console.log('Connecté avec ID:', socket.id);
            setConnectionStatus('connected');
            stopSimulation();
            
            // Demander les données de retenue à la connexion
            if (state.activeSection === 'retenue-section') {
                socket.emit('getRetenueData');
            }
        });
        
        socket.on('disconnect', (reason) => {
            console.log('Déconnexion. Raison:', reason);
            setConnectionStatus('connecting');
            startSimulationIfDisconnected();
        });
        
        socket.on('connect_error', (error) => {
            console.error('Erreur de connexion:', error.message);
            setConnectionStatus('connecting');
            startSimulationIfDisconnected();
        });
        
        socket.on('sensorData', (data) => {
            console.log('Données reçues:', data);
            updateSensorData(data);
        });
        
        // Écouter les mises à jour de la retenue
        socket.on('retenueUpdate', (data) => {
            console.log('Mise à jour retenue reçue:', data);
            updateRetenueFromServer(data);
        });
        
    } catch (e) {
        console.error("Erreur lors de l'initialisation de Socket.io:", e);
        startSimulationIfDisconnected();
    }
}
  
function stopSimulation() {
        if (state.simulationInterval) {
            clearInterval(state.simulationInterval);
            state.simulationInterval = null;
            console.log("Simulation arrêtée");
        }
    }
    
    function startSimulationIfDisconnected() {
        if (state.connectionStatus === 'connecting' && !state.simulationInterval) {
            simulateDataIfNeeded();
        }
    }

    function setActiveSection(sectionId) {
    console.log("Changement de section vers:", sectionId);
    
    // Arrêter l'animation des gouttes lorsqu'on quitte la section climat ambiant
    if (state.activeSection === 'ambient-section' && sectionId !== 'ambient-section') {
        stopRaindropsAnimation();
    }
    
    state.activeSection = sectionId;
    
    Object.keys(elements.sections).forEach(id => {
        if (id === sectionId) {
            elements.sections[id].classList.remove('hidden');
            elements.sections[id].classList.add('block');
        } else {
            elements.sections[id].classList.remove('block');
            elements.sections[id].classList.add('hidden');
        }
    });
    
    elements.navLinks.forEach(link => {
        const linkSection = link.getAttribute('data-section');
        const indicator = link.querySelector('div:first-child');
        const icon = link.querySelector('div:nth-child(2)');
        
        if (linkSection === sectionId) {
            link.classList.add('font-medium');
            
            if (sectionId === 'water-section') {
                link.classList.add('bg-blue-50', 'text-blue-600');
                indicator.classList.add('bg-blue-600');
                icon.classList.add('shadow-md', 'text-blue-600', 'bg-blue-50');
            } else if (sectionId === 'temperature-section') {
                link.classList.add('bg-amber-50', 'text-amber-600');
                indicator.classList.add('bg-amber-600');
                icon.classList.add('shadow-md', 'text-amber-600', 'bg-amber-50');
            } else if (sectionId === 'humidity-section') {
                link.classList.add('bg-sky-50', 'text-sky-600');
                indicator.classList.add('bg-sky-600');
                icon.classList.add('shadow-md', 'text-sky-600', 'bg-sky-50');
            } else if (sectionId === 'rain-section') {
                link.classList.add('bg-indigo-50', 'text-indigo-600');
                indicator.classList.add('bg-indigo-600');
                icon.classList.add('shadow-md', 'text-indigo-600', 'bg-indigo-50');
            } else if (sectionId === 'ambient-section') {
                link.classList.add('bg-purple-50', 'text-purple-600');
                indicator.classList.add('bg-purple-600');
                icon.classList.add('shadow-md', 'text-purple-600', 'bg-purple-50');
            } else if (sectionId === 'retenue-section') {
                link.classList.add('bg-teal-50', 'text-teal-600');
                indicator.classList.add('bg-teal-600');
                icon.classList.add('shadow-md', 'text-teal-600', 'bg-teal-50');
            }
        } else {
            link.classList.remove('font-medium', 'bg-blue-50', 'text-blue-600', 'bg-amber-50', 'text-amber-600', 'bg-sky-50', 'text-sky-600', 'bg-indigo-50', 'text-indigo-600', 'bg-purple-50', 'text-purple-600', 'bg-teal-50', 'text-teal-600');
            indicator.classList.remove('bg-blue-600', 'bg-amber-600', 'bg-sky-600', 'bg-indigo-600', 'bg-purple-600', 'bg-teal-600');
            icon.classList.remove('shadow-md', 'text-blue-600', 'text-amber-600', 'text-sky-600', 'text-indigo-600', 'text-purple-600', 'text-teal-600');
            icon.classList.add('shadow-sm');
        }
    });
    
    // Démarrer l'animation si on passe à la section climat ambiant
    if (sectionId === 'ambient-section') {
        startRaindropsAnimation();
        
        // Si aucune donnée n'existe, en créer des simulées
        if (state.ambientTempChartData.length === 0) {
            updateAmbientTempChartData(22.5);
        }
        if (state.ambientHumidityChartData.length === 0) {
            updateAmbientHumidityChartData(55);
        }
        
        // Rendre les graphiques
        setTimeout(() => {
            renderAmbientTempChart();
            renderAmbientHumidityChart();
            update3DVisualizations();
        }, 10);
    }
    // Si on passe à la section retenue, mettre à jour ses graphiques
    else if (sectionId === 'retenue-section') {
        console.log("Activation de la section retenue, appel des fonctions de rendu");
        setTimeout(() => {
            console.log("Appel de renderRetenueChart()");
            renderRetenueChart();
            console.log("Appel de updateRetenue3DVisualisation()");
            updateRetenue3DVisualisation();
            initRetenueSection();
        }, 100);
    }
    // Mettre à jour le graphique approprié lorsque la section devient active
    else if (sectionId === 'water-section' && state.chartData.length > 0) {
        setTimeout(renderChart, 10);
    } else if (sectionId === 'temperature-section' && state.temperatureChartData.length > 0) {
        setTimeout(renderTemperatureChart, 10);
    } else if (sectionId === 'humidity-section' && state.humidityChartData.length > 0) {
        setTimeout(renderHumidityChart, 10);
    } else if (sectionId === 'rain-section' && state.rainChartData.length > 0) {
        setTimeout(renderRainChart, 10);
    }
}

function setConnectionStatus(status) {
        state.connectionStatus = status;
        
        if (status === 'connected') {
            elements.connectionStatus.classList.remove('bg-yellow-100', 'text-yellow-800');
            elements.connectionStatus.classList.add('bg-green-100', 'text-green-800');
            elements.connectionStatus.innerHTML = '<i class="fas fa-check-circle mr-2"></i>Connecté';
        } else {
            elements.connectionStatus.classList.remove('bg-green-100', 'text-green-800');
            elements.connectionStatus.classList.add('bg-yellow-100', 'text-yellow-800');
            elements.connectionStatus.innerHTML = '<i class="fas fa-sync-alt fa-spin mr-2"></i>Connexion...';
        }
    }

    function loadFromLocalStorage() {
    try {
        const savedData = localStorage.getItem('waterMonitoringData');
        if (savedData) {
            const parsed = JSON.parse(savedData);
            // Données existantes
            state.chartData = parsed.chartData || [];
            state.dataIndex = parsed.dataIndex || 0;
            state.sensorHistory = parsed.sensorHistory || {
                flow1: [], 
                flow2: [], 
                soilTemperature: [], 
                soilHumidity: [],
                rainAmount: [],
                ambientTemperature: [],  // Ajouté
                ambientHumidity: []      // Ajouté
            };
            state.temperatureChartData = parsed.temperatureChartData || [];
            state.temperatureDataIndex = parsed.temperatureDataIndex || 0;
            state.humidityChartData = parsed.humidityChartData || [];
            state.humidityDataIndex = parsed.humidityDataIndex || 0;
            state.rainChartData = parsed.rainChartData || [];
            state.rainDataIndex = parsed.rainDataIndex || 0;
            
            // Données DHT22 (température et humidité ambiantes)
            state.ambientTempChartData = parsed.ambientTempChartData || [];       // Ajouté
            state.ambientTempDataIndex = parsed.ambientTempDataIndex || 0;        // Ajouté
            state.ambientHumidityChartData = parsed.ambientHumidityChartData || []; // Ajouté
            state.ambientHumidityDataIndex = parsed.ambientHumidityDataIndex || 0;  // Ajouté
            
            // Vérification des historiques
            if (parsed.sensorHistory) {
                state.sensorHistory.rainAmount = parsed.sensorHistory.rainAmount || [];
                state.sensorHistory.ambientTemperature = parsed.sensorHistory.ambientTemperature || []; // Ajouté
                state.sensorHistory.ambientHumidity = parsed.sensorHistory.ambientHumidity || [];       // Ajouté
            }
        }
    } catch (e) {
        console.error("Erreur de lecture du localStorage", e);
    }
}

function saveToLocalStorage() {
    try {
        const dataToSave = {
            chartData: state.chartData,
            dataIndex: state.dataIndex,
            sensorHistory: state.sensorHistory,
            temperatureChartData: state.temperatureChartData,
            temperatureDataIndex: state.temperatureDataIndex,
            humidityChartData: state.humidityChartData,
            humidityDataIndex: state.humidityDataIndex,
            rainChartData: state.rainChartData,
            rainDataIndex: state.rainDataIndex,
            ambientTempChartData: state.ambientTempChartData,
            ambientTempDataIndex: state.ambientTempDataIndex,
            ambientHumidityChartData: state.ambientHumidityChartData,
            ambientHumidityDataIndex: state.ambientHumidityDataIndex
        };
        localStorage.setItem('waterMonitoringData', JSON.stringify(dataToSave));
    } catch (e) {
        console.error("Erreur d'écriture dans le localStorage", e);
    }
}
   
function cleanupOldData() {
    const now = new Date();
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    
    // Nettoyer les données de niveau d'eau
    if (state.chartData.length > 0) {
        const newWaterData = state.chartData.filter(dataPoint => {
            if (!dataPoint.timestamp) return false; // On supprime les points sans timestamp
            const dataTime = new Date(dataPoint.timestamp);
            return dataTime >= oneDayAgo;
        });
        
        if (newWaterData.length < state.chartData.length) {
            console.log(`Nettoyage eau: ${state.chartData.length - newWaterData.length} points supprimés`);
            state.chartData = newWaterData;
        }
    }

    // Nettoyer les données de température
    if (state.temperatureChartData.length > 0) {
        const newTempData = state.temperatureChartData.filter(dataPoint => {
            if (!dataPoint.timestamp) return false;
            const dataTime = new Date(dataPoint.timestamp);
            return dataTime >= oneDayAgo;
        });
        
        if (newTempData.length < state.temperatureChartData.length) {
            console.log(`Nettoyage température: ${state.temperatureChartData.length - newTempData.length} points supprimés`);
            state.temperatureChartData = newTempData;
        }
    }

    // Nettoyer les données d'humidité
    if (state.humidityChartData.length > 0) {
        const newHumidityData = state.humidityChartData.filter(dataPoint => {
            if (!dataPoint.timestamp) return false;
            const dataTime = new Date(dataPoint.timestamp);
            return dataTime >= oneDayAgo;
        });
        
        if (newHumidityData.length < state.humidityChartData.length) {
            console.log(`Nettoyage humidité: ${state.humidityChartData.length - newHumidityData.length} points supprimés`);
            state.humidityChartData = newHumidityData;
        }
    }
    
    // Nettoyer les données de pluie
    if (state.rainChartData.length > 0) {
        const newRainData = state.rainChartData.filter(dataPoint => {
            if (!dataPoint.timestamp) return false;
            const dataTime = new Date(dataPoint.timestamp);
            return dataTime >= oneDayAgo;
        });
        
        if (newRainData.length < state.rainChartData.length) {
            console.log(`Nettoyage pluie: ${state.rainChartData.length - newRainData.length} points supprimés`);
            state.rainChartData = newRainData;
        }
    }
    
    // Température ambiante
    if (state.ambientTempChartData.length > 0) {
        const newAmbientTempData = state.ambientTempChartData.filter(dataPoint => {
            if (!dataPoint.timestamp) return false;
            const dataTime = new Date(dataPoint.timestamp);
            return dataTime >= oneDayAgo;
        });
        
        if (newAmbientTempData.length < state.ambientTempChartData.length) {
            console.log(`Nettoyage température ambiante: ${state.ambientTempChartData.length - newAmbientTempData.length} points supprimés`);
            state.ambientTempChartData = newAmbientTempData;
        }
    }
    
    // Humidité ambiante
    if (state.ambientHumidityChartData.length > 0) {
        const newAmbientHumidityData = state.ambientHumidityChartData.filter(dataPoint => {
            if (!dataPoint.timestamp) return false;
            const dataTime = new Date(dataPoint.timestamp);
            return dataTime >= oneDayAgo;
        });
        
        if (newAmbientHumidityData.length < state.ambientHumidityChartData.length) {
            console.log(`Nettoyage humidité ambiante: ${state.ambientHumidityChartData.length - newAmbientHumidityData.length} points supprimés`);
            state.ambientHumidityChartData = newAmbientHumidityData;
        }
    }

    saveToLocalStorage();

  if (state.activeSection === 'water-section' && chart) {
    renderChart();
} else if (state.activeSection === 'temperature-section' && temperatureChart) {
    renderTemperatureChart();
} else if (state.activeSection === 'humidity-section' && humidityChart) {
    renderHumidityChart();
} else if (state.activeSection === 'rain-section' && rainChart) {
    renderRainChart();
} else if (state.activeSection === 'ambient-section') {
    if (ambientTempChart) renderAmbientTempChart();
    if (ambientHumidityChart) renderAmbientHumidityChart();
} else if (state.activeSection === 'retenue-section' && retenueChart) {
    renderRetenueChart();
}
}
 
function calculateFlow(sensorReading) {
        const SENSOR_HEIGHT = 50;
        const MIN_FLOW = 0.1;
        const MAX_FLOW = 5.0;
        const CANAL_WIDTH = 1.5;
        const COEFFICIENT = 0.6;
        const SLOPE = 0.002;
        
        const waterHeight = SENSOR_HEIGHT - sensorReading;
        const effectiveHeight = Math.max(0, waterHeight);
        
        if (effectiveHeight > 0) {
            const area = CANAL_WIDTH * effectiveHeight;
            const flow = COEFFICIENT * area * Math.pow(effectiveHeight, 2/3) * Math.sqrt(SLOPE);
            return Math.min(Math.max(flow, MIN_FLOW), MAX_FLOW);
        } else {
            return MIN_FLOW;
        }
    }

    function getWaterLevelAlert(sensorReading) {
    const SENSOR_HEIGHT = 50;
    const waterHeight = SENSOR_HEIGHT - sensorReading;
    
    let color, status, bgColor, textColor;
    
    if (waterHeight <= 20) {
        color = "#10b981";
        status = "Normal";
        bgColor = "bg-green-100";
        textColor = "text-green-800";
    } else if (waterHeight <= 35) {
        color = "#f59e0b";
        status = "Attention";
        bgColor = "bg-yellow-100";
        textColor = "text-yellow-800";
    } else {
        color = "#ef4444";
        status = "Critique";
        bgColor = "bg-red-100";
        textColor = "text-red-800";
    }
    
    return {
        color,
        value: waterHeight,
        status,
        bgColor,
        textColor
    };
}

function getTemperatureLevel(temperature) {
    let color, status, bgColor, textColor;
    
    if (temperature < 15) {
        color = "#3b82f6";
        status = "Froid";
        bgColor = "bg-blue-100";
        textColor = "text-blue-800";
    } else if (temperature < 25) {
        color = "#10b981";
        status = "Optimal";
        bgColor = "bg-green-100";
        textColor = "text-green-800";
    } else {
        color = "#ef4444";
        status = "Chaud";
        bgColor = "bg-red-100";
        textColor = "text-red-800";
    }
    
    return {
        color,
        value: temperature,
        status,
        bgColor,
        textColor
    };
}

function getHumidityLevel(humidity) {
    let color, status, bgColor, textColor;
    
    if (humidity < 30) {
        color = "#ef4444";
        status = "Sec";
        bgColor = "bg-red-100";
        textColor = "text-red-800";
    } else if (humidity < 70) {
        color = "#10b981";
        status = "Optimal";
        bgColor = "bg-green-100";
        textColor = "text-green-800";
    } else {
        color = "#3b82f6";
        status = "Humide";
        bgColor = "bg-blue-100";
        textColor = "text-blue-800";
    }
    
    return {
        color,
        value: humidity,
        status,
        bgColor,
        textColor
    };
}

function getRainIntensity(rainAmount) {
    let color, status, bgColor, textColor;
    
    if (rainAmount < 1) {
        color = "#93c5fd";
        status = "Faible";
        bgColor = "bg-blue-100";
        textColor = "text-blue-800";
    } else if (rainAmount < 4) {
        color = "#60a5fa";
        status = "Modérée";
        bgColor = "bg-blue-200";
        textColor = "text-blue-800";
    } else if (rainAmount < 8) {
        color = "#3b82f6";
        status = "Forte";
        bgColor = "bg-blue-300";
        textColor = "text-blue-800";
    } else {
        color = "#2563eb";
        status = "Intense";
        bgColor = "bg-blue-400";
        textColor = "text-blue-900";
    }
    
    return {
        color,
        value: rainAmount,
        status,
        bgColor,
        textColor
    };
}

function updateSensorData(data) {
    const distance1 = data.distance1 || 0;
    const flow1 = calculateFlow(distance1);
    
    const distance2 = data.distance2 || 0;
    const flow2 = calculateFlow(distance2);
    
    const soilTemperature = data.soilTemperature || 0;
    const soilHumidity = data.soilHumidity || 0;
    const rainAmount = data.rainAmount || 0;
    const ambientTemperature = data.ambientTemperature || 0;
    const ambientHumidity = data.ambientHumidity || 0;

    // Mettre à jour l'objet state.sensorData
    state.sensorData = {
        distance1,
        distance2,
        flow1,
        flow2,
        soilTemperature,
        soilHumidity,
        rainAmount,
        ambientTemperature,
        ambientHumidity
    };

    // Mettre à jour les éléments d'affichage
    elements.distance1.textContent = distance1.toFixed(1);
    elements.distance2.textContent = distance2.toFixed(1);
    elements.flow1.textContent = flow1.toFixed(1);
    elements.flow2.textContent = flow2.toFixed(1);
    elements.soilTemperature.textContent = soilTemperature.toFixed(1);
    elements.soilHumidity.textContent = soilHumidity.toFixed(1);
    elements.rainAmount.textContent = rainAmount.toFixed(1);
    elements.ambientTemperature.textContent = ambientTemperature.toFixed(1);
    elements.ambientHumidity.textContent = ambientHumidity.toFixed(1);

    // Mettre à jour les tendances et indicateurs de confort
    updateTrends(ambientTemperature, ambientHumidity);
    updateComfortIndicators(ambientTemperature, ambientHumidity);

    // Mettre à jour l'historique des capteurs
    updateSensorHistory({
        flow1,
        flow2,
        soilTemperature,
        soilHumidity,
        rainAmount,
        ambientTemperature,
        ambientHumidity
    });

    // Mettre à jour tous les graphiques
    updateChartData(distance1, distance2);
    updateTemperatureChartData(soilTemperature);
    updateHumidityChartData(soilHumidity);
    updateRainChartData(rainAmount);
    updateAmbientTempChartData(ambientTemperature);
    updateAmbientHumidityChartData(ambientHumidity);

    // Mettre à jour les visualisations 3D si la section est active
    if (state.activeSection === 'ambient-section') {
        update3DVisualizations();
        updateRoomEnvironment(ambientTemperature, ambientHumidity);
    }
}

function updateSensorHistory(newData) {
    state.sensorHistory = {
        flow1: [newData.flow1, ...state.sensorHistory.flow1].slice(0, MAX_HISTORY),
        flow2: [newData.flow2, ...state.sensorHistory.flow2].slice(0, MAX_HISTORY),
        soilTemperature: [newData.soilTemperature, ...state.sensorHistory.soilTemperature].slice(0, MAX_HISTORY),
        soilHumidity: [newData.soilHumidity, ...state.sensorHistory.soilHumidity].slice(0, MAX_HISTORY),
        rainAmount: [newData.rainAmount, ...state.sensorHistory.rainAmount].slice(0, MAX_HISTORY),
        ambientTemperature: [newData.ambientTemperature, ...state.sensorHistory.ambientTemperature].slice(0, MAX_HISTORY),
        ambientHumidity: [newData.ambientHumidity, ...state.sensorHistory.ambientHumidity].slice(0, MAX_HISTORY)
    };
    
    // Mettre à jour les tableaux d'historique existants
    updateHistoryTable(elements.flow1History, state.sensorHistory.flow1, 'm³/s');
    updateHistoryTable(elements.flow2History, state.sensorHistory.flow2, 'm³/s');
    updateHistoryTable(elements.temperatureHistory, state.sensorHistory.soilTemperature, '°C');
    updateHistoryTable(elements.humidityHistory, state.sensorHistory.soilHumidity, '%');
    updateHistoryTable(elements.rainHistory, state.sensorHistory.rainAmount, 'mm');
    
    // Mettre à jour les nouveaux tableaux d'historique ambiant
    updateHistoryTable(elements.ambientTempHistory, state.sensorHistory.ambientTemperature, '°C');
    updateHistoryTable(elements.ambientHumidityHistory, state.sensorHistory.ambientHumidity, '%');
    
    // Mettre à jour les indicateurs de confort si nécessaire
    if (typeof updateComfortIndicators === 'function') {
        updateComfortIndicators(newData.ambientTemperature, newData.ambientHumidity);
    }
}

    function updateHistoryTable(tableElement, dataArray, unit) {
        if (!dataArray || dataArray.length === 0) {
            tableElement.innerHTML = `
                <tr>
                    <td colspan="2" class="text-center text-gray-400 p-2">
                        Aucune donnée historique
                    </td>
                </tr>
            `;
            return;
        }
        
        let html = '';
        dataArray.forEach((reading, index) => {
            html += `
                <tr class="hover:bg-gray-50">
                    <td class="p-2 text-left border-b border-gray-200">${index + 1}</td>
                    <td class="p-2 text-left border-b border-gray-200">${reading.toFixed(1)} ${unit}</td>
                </tr>
            `;
        });
        tableElement.innerHTML = html;
    }

    function updateChartData(distance1, distance2) {
        const now = new Date();
        const newDataPoint = {
            index: state.dataIndex++,
            distance1: parseFloat(distance1.toFixed(1)),
            distance2: parseFloat(distance2.toFixed(1)),
            timestamp: now.toISOString()
        };

        state.chartData.push(newDataPoint);
        
        if (state.chartData.length > 1000) {
            state.chartData.shift();
        }

        saveToLocalStorage();

        if (state.activeSection === 'water-section') {
            renderChart();
        }
    }

    function renderChart() {
    const container = document.getElementById('water-level-chart');
    if (!container) {
        console.error("Conteneur du graphique non trouvé");
        return;
    }

    // Vérifier si Chart.js est disponible
    if (typeof Chart === 'undefined') {
        console.error("Chart.js n'est pas chargé");
        container.innerHTML = `<div class="bg-red-50 p-4 rounded-lg text-red-600">
            <p><i class="fas fa-exclamation-triangle"></i> Chart.js n'est pas chargé. Veuillez recharger la page.</p>
        </div>`;
        return;
    }

    container.innerHTML = '<canvas id="chartCanvas"></canvas>';
    const ctx = document.getElementById('chartCanvas').getContext('2d');

    // Vérifier si des données sont disponibles
    if (!state.chartData || state.chartData.length === 0) {
        console.warn("Aucune donnée à afficher dans le graphique");
        container.innerHTML = `<div class="bg-yellow-50 p-4 rounded-lg text-yellow-600">
            <p><i class="fas fa-exclamation-circle"></i> Aucune donnée disponible</p>
        </div>`;
        return;
    }

    const timeLabels = state.chartData.map(d => {
        if (d.timestamp) {
            return new Date(d.timestamp).toLocaleTimeString();
        }
        return `Mesure ${d.index}`;
    });
    
    const canal1Data = state.chartData.map(d => d.distance1);
    const canal2Data = state.chartData.map(d => d.distance2);
    
    const canal1Alerts = canal1Data.map(d => getWaterLevelAlert(d));
    const canal1PointColors = canal1Alerts.map(alert => alert.color);
    
    const canal2Alerts = canal2Data.map(d => getWaterLevelAlert(d));
    const canal2PointColors = canal2Alerts.map(alert => alert.color);

    if (chart) {
        chart.destroy();
    }

 

        try {
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timeLabels,
                    datasets: [
                        {
                            label: 'Canal 1 (cm)',
                            data: canal1Data,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(56, 130, 246, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            pointRadius: 0,
                            pointBackgroundColor: canal1PointColors,
                            pointBorderColor: 'white',
                            pointBorderWidth: 0,
                        },
                        {
                            label: 'Canal 2 (cm)',
                            data: canal2Data,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 2,
                            tension: 0.1,
                            pointRadius: 0,
                            pointBackgroundColor: canal2PointColors,
                            pointBorderColor: 'white',
                            pointBorderWidth: 1.5,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 500
                    },
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(1) + ' cm';
                                        const alertInfo = getWaterLevelAlert(context.parsed.y);
                                        label += ` (niveau d'eau: ${alertInfo.value.toFixed(1)} cm)`;                                    }
                                    return label;
                                }
                            }
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'x',
                                threshold: 5
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x',
                                speed: 0.1
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Niveau d\'eau (cm)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Temps'
                            }
                        }
                    }
                }
            });
            
            const drawZones = function() {
                if (!chart) return;
                
                const chartArea = chart.chartArea;
                const yAxis = chart.scales.y;
                const ctx = chart.ctx;
                
                const SENSOR_HEIGHT = 50;
                const normalY = yAxis.getPixelForValue(SENSOR_HEIGHT - 20);
                const warningY = yAxis.getPixelForValue(SENSOR_HEIGHT - 35);
                
                ctx.save();
                
                ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
                ctx.fillRect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, warningY - chartArea.top);
                
                ctx.fillStyle = 'rgba(245, 158, 11, 0.1)';
                ctx.fillRect(chartArea.left, warningY, chartArea.right - chartArea.left, normalY - warningY);
                
                ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
                ctx.fillRect(chartArea.left, normalY, chartArea.right - chartArea.left, chartArea.bottom - normalY);
                
                ctx.strokeStyle = 'rgba(239, 68, 68, 0.7)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(chartArea.left, warningY);
                ctx.lineTo(chartArea.right, warningY);
                ctx.stroke();
                
                ctx.strokeStyle = 'rgba(245, 158, 11, 0.7)';
                ctx.beginPath();
                ctx.moveTo(chartArea.left, normalY);
                ctx.lineTo(chartArea.right, normalY);
                ctx.stroke();
                
                ctx.restore();
            };
            
            chart.options.plugins.afterRender = drawZones;
            chart.options.plugins.afterUpdate = drawZones;
            
        } catch (error) {
            console.error("Erreur lors de la création du graphique:", error);
            container.innerHTML = `<div class="bg-red-50 p-4 rounded-lg text-red-600">
                <p><i class="fas fa-exclamation-triangle"></i> Erreur de graphique: ${error.message}</p>
            </div>`;
        }
    }

    function updateTemperatureChartData(temperature) {
        const now = new Date();
        const newDataPoint = {
            index: state.temperatureDataIndex++,
            temperature: parseFloat(temperature.toFixed(1)),
            timestamp: now.toISOString()
        };

        state.temperatureChartData.push(newDataPoint);
        
        if (state.temperatureChartData.length > 1000) {
            state.temperatureChartData.shift();
        }

        saveToLocalStorage();

        if (state.activeSection === 'temperature-section') {
            renderTemperatureChart();
        }
    }

    function renderTemperatureChart() {
    const container = document.getElementById('temperature-chart');
    if (!container) {
        console.error("Conteneur du graphique de température non trouvé");
        return;
    }

    // Créer une structure complète avec graphique, tableau, zone 3D et boutons de gestion
    container.innerHTML = `
        <div class="chart-container" style="position: relative; height: 350px;">
            <canvas id="tempChartCanvas"></canvas>
        </div>
        <br>
        <br>
             <!-- Visualisation 3D -->
        <div id="temp-3d-visualization" style="width: 100%; height: 150px; background: linear-gradient(to right, #3b82f6, #16a34a, #f59e0b, #dc2626); 
             border-radius: 8px; position: relative; overflow: hidden; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div class="soil-layers" style="height: 100%; width: 100%; position: relative;">
                <!-- Les couches du sol seront générées dynamiquement -->
            </div>
            <div class="temp-indicators" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                <!-- Les indicateurs de température seront générés dynamiquement -->
            </div>
            <div class="temp-scale" style="position: absolute; bottom: 10px; right: 10px; background: rgba(255,255,255,0.8); 
                 padding: 5px; border-radius: 5px; font-size: 12px;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="color: #3b82f6;">■</span> Froid
                    <span style="color: #16a34a;">■</span> Optimal
                    <span style="color: #f59e0b;">■</span> Chaud
                    <span style="color: #dc2626;">■</span> Très chaud
                </div>
            </div>
        </div>
       

     <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100 hover:shadow-lg">
    <h3 class="text-base font-semibold text-gray-600 mb-3">Historique des données</h3>
    <div class="max-h-60 overflow-y-auto">
        <table class="w-full text-sm text-gray-600 border-collapse">
            <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                <tr>
                    <th class="p-2 text-left border-b border-gray-200">Heure</th>
                    <th class="p-2 text-center border-b border-gray-200">Température (°C)</th>
                    <th class="p-2 text-center border-b border-gray-200">Statut</th>
                    <th class="p-2 text-center border-b border-gray-200">Variation</th>
                </tr>
            </thead>
            <tbody id="temp-data-table">
                <tr>
                    <td colspan="4" class="text-center text-gray-400 p-2">
                        Chargement des données...
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

        
   
        
        <!-- Boutons de gestion des données -->
        <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100">
            <h3 class="text-base font-semibold text-gray-600 mb-4">Gestion des données</h3>
            
            <div class="flex flex-wrap gap-3">
                <button onclick="showTemperatureFullHistory()" class="btn-gestion">
                    <i class="fas fa-history"></i>
                    <span>Historique complet</span>
                </button>
                
                <button onclick="exportTemperatureData('xlsx')" class="btn-gestion">
                    <i class="fas fa-file-excel"></i>
                    <span>Exporter Excel</span>
                </button>
                
                <button onclick="exportTemperatureToPDF()" class="btn-gestion">
                    <i class="fas fa-file-pdf"></i>
                    <span>PDF (.pdf)</span>
                </button>
                
                <button onclick="exportTemperatureChartImage()" class="btn-gestion">
                    <i class="fas fa-camera"></i>
                    <span>Exporter Image</span>
                </button>
                
                <button onclick="resetTemperatureData()" class="btn-gestion">
                    <i class="fas fa-trash-alt"></i>
                    <span>Réinitialiser</span>
                </button>
            </div>
        </div>
    `;

    // Préparation des données
    const timeLabels = state.temperatureChartData.map(d => {
        if (d.timestamp) {
            return new Date(d.timestamp).toLocaleTimeString();
        }
        return `Mesure ${d.index}`;
    });
    
    const tempData = state.temperatureChartData.map(d => d.temperature);
    
    if (temperatureChart) {
        temperatureChart.destroy();
    }

    // Définitions des fonctions de couleur
    const getTempColor = (temp) => {
        if (temp < 10) return '#3b82f6';      // Bleu (froid)
        if (temp < 15) return '#60a5fa';      // Bleu clair (frais)
        if (temp < 20) return '#16a34a';      // Vert (optimal bas)
        if (temp < 25) return '#059669';      // Vert foncé (optimal)
        if (temp < 30) return '#f59e0b';      // Orange (chaud)
        return '#dc2626';                     // Rouge (très chaud)
    };
    
    const getTempStatus = (temp) => {
        if (temp < 10) return "Froid";
        if (temp < 15) return "Frais";
        if (temp < 20) return "Optimal (frais)";
        if (temp < 25) return "Optimal (chaud)";
        if (temp < 30) return "Chaud";
        return "Très chaud";
    };

    try {
        // Création du graphique principal
        const ctx = document.getElementById('tempChartCanvas').getContext('2d');
        
        temperatureChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Température du sol (°C)',
                        data: tempData,
                        borderWidth: 3,
                        borderColor: function(context) {
                            const index = context.dataIndex;
                            const value = tempData[index];
                            return getTempColor(value);
                        },
                        backgroundColor: 'rgba(255, 205, 86, 0.1)',
                        tension: 0.4,
                        pointRadius: 0,
                        pointBackgroundColor: function(context) {
                            const index = context.dataIndex;
                            const value = tempData[index];
                            return getTempColor(value);
                        },
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const temp = context.parsed.y;
                                return `Température: ${temp.toFixed(1)}°C `;
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x'
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            mode: 'x'
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        suggestedMin: Math.max(0, Math.min(...tempData) - 5),
                        suggestedMax: Math.max(...tempData) + 5,
                        ticks: {
                            callback: function(value) {
                                return value + '°C';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Température du sol (°C)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Heure de mesure'
                        }
                    }
                }
            }
        });
        
        // Génération du tableau de données
        populateDataTable();
        
        // Création de la visualisation 3D
        create3DVisualization();
        
        // Fonction pour remplir le tableau de données
        function populateDataTable() {
            const tableBody = document.getElementById('temp-data-table');
            if (!tableBody) return;
            
            let tableContent = '';
            
            // Parcourir les données de température en ordre inverse (plus récentes d'abord)
            const dataPoints = state.temperatureChartData.slice();
            dataPoints.reverse();
            
            dataPoints.forEach((dataPoint, index, array) => {
                const temp = dataPoint.temperature;
                const status = getTempStatus(temp);
                const statusColor = getTempColor(temp);
                
                // Calculer la variation par rapport à la mesure précédente
                let variation = '';
                let variationClass = '';
                
                if (index < array.length - 1) {
                    const prevTemp = array[index + 1].temperature;
                    const diff = temp - prevTemp;
                    
                    if (diff > 0.2) {
                        variation = `+${diff.toFixed(1)}°C`;
                        variationClass = 'text-red-600';
                    } else if (diff < -0.2) {
                        variation = `${diff.toFixed(1)}°C`;
                        variationClass = 'text-blue-600';
                    } else {
                        variation = 'Stable';
                        variationClass = 'text-gray-600';
                    }
                } else {
                    variation = '-';
                    variationClass = 'text-gray-400';
                }
                
                // Formatter l'heure
                let timeStr = 'N/A';
                if (dataPoint.timestamp) {
                    const date = new Date(dataPoint.timestamp);
                    timeStr = date.toLocaleTimeString();
                }
                
                // Couleur d'arrière-plan alternée
                const rowBg = index % 2 === 0 ? 'bg-amber-50' : 'bg-white';
                
                tableContent += `
                    <tr class="${rowBg} hover:bg-amber-100 transition-colors duration-150">
                        <td class="p-2 border-b border-amber-100">${timeStr}</td>
                        <td class="p-2 text-center border-b border-amber-100 font-semibold" style="color: ${statusColor}">
                            ${temp.toFixed(1)}°C
                        </td>
                        <td class="p-2 text-center border-b border-amber-100">
                            <span class="px-2 py-1 rounded-full text-xs font-medium" 
                                  style="background-color: ${statusColor}1A; color: ${statusColor}">
                                ${status}
                            </span>
                        </td>
                        <td class="p-2 text-center border-b border-amber-100 ${variationClass}">
                            ${variation}
                        </td>
                    </tr>
                `;
            });
            
            if (tableContent === '') {
                tableContent = `
                    <tr>
                        <td colspan="4" class="text-center text-gray-400 p-4">
                            Aucune donnée disponible
                        </td>
                    </tr>
                `;
            }
            
            tableBody.innerHTML = tableContent;
        }
        
        // Fonction pour créer la visualisation 3D
        function create3DVisualization() {
            const container = document.getElementById('temp-3d-visualization');
            const soilLayers = container.querySelector('.soil-layers');
            const indicators = container.querySelector('.temp-indicators');
            
            if (!soilLayers || !indicators) return;
            
            // Récupérer la dernière valeur de température (ou la moyenne si disponible)
            const currentTemp = tempData.length > 0 ? tempData[tempData.length - 1] : 20;
            
            // Générer les couches du sol
            soilLayers.innerHTML = '';
            
            // Créer 5 couches
            for (let i = 0; i < 5; i++) {
                const layer = document.createElement('div');
                const depth = i * 20; // 0%, 20%, 40%, 60%, 80% depuis le haut
                
                // Calculer la température à cette profondeur (diminue avec la profondeur)
                // La température diminue d'environ 0.5°C tous les 10cm de profondeur
                const depthTemp = currentTemp - (i * 0.5);
                const layerColor = getTempColor(depthTemp);
                
                layer.style.cssText = `
                    position: absolute;
                    top: ${depth}%;
                    left: 0;
                    width: 100%;
                    height: 20%;
                    background: ${layerColor}33;
                    border-bottom: 1px solid ${layerColor}66;
                    transition: all 0.5s ease;
                    transform-style: preserve-3d;
                    transform: perspective(1000px) rotateX(${10 - i * 2}deg);
                `;
                
                // Ajouter un indicateur de température
                layer.innerHTML = `
                    <div style="position: absolute; bottom: 5px; right: 10px; 
                                 color: ${layerColor}; font-weight: bold; font-size: 12px;">
                        ${depthTemp.toFixed(1)}°C
                    </div>
                    <div style="position: absolute; bottom: 5px; left: 10px; color: rgba(0,0,0,0.6); font-size: 11px;">
                        Profondeur: ${i * 10} cm
                    </div>
                `;
                
                soilLayers.appendChild(layer);
            }
            
            // Ajouter des indicateurs visuels selon la température
            indicators.innerHTML = '';
            
            if (currentTemp < 10) {
                // Indicateurs de froid
                indicators.innerHTML += `
                    <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
                                text-align: center; color: #3b82f6; font-weight: bold;">
                        <i class="fas fa-snowflake" style="font-size: 24px;"></i>
                        <div style="font-size: 12px; margin-top: 5px;">Sol froid</div>
                    </div>
                `;
            } else if (currentTemp > 30) {
                // Indicateurs de chaleur
                indicators.innerHTML += `
                    <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
                                text-align: center; color: #dc2626; font-weight: bold;">
                        <i class="fas fa-fire" style="font-size: 24px;"></i>
                        <div style="font-size: 12px; margin-top: 5px;">Sol très chaud</div>
                    </div>
                `;
            } else if (currentTemp >= 15 && currentTemp <= 25) {
                // Indicateurs optimaux
                indicators.innerHTML += `
                    <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
                                text-align: center; color: #059669; font-weight: bold;">
                        <i class="fas fa-seedling" style="font-size: 24px;"></i>
                        <div style="font-size: 12px; margin-top: 5px;">Température optimale</div>
                    </div>
                `;
            }
            
            // Ajouter effet de profondeur 3D
            const depthEffect = document.createElement('div');
            depthEffect.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(to bottom, 
                            rgba(0,0,0,0) 0%, 
                            rgba(0,0,0,0.1) 40%, 
                            rgba(0,0,0,0.2) 70%, 
                            rgba(0,0,0,0.3) 100%);
                pointer-events: none;
            `;
            container.appendChild(depthEffect);
            
            // Animation subtile pour donner un effet de vie
            animateSoilLayers();
        }
        
        // Animation des couches du sol
        function animateSoilLayers() {
            const layers = document.querySelectorAll('#temp-3d-visualization .soil-layers > div');
            
            layers.forEach((layer, index) => {
                // Animation légère de rotation
                const baseRotation = 10 - index * 2;
                const animRotation = baseRotation + (Math.random() * 0.5 - 0.25);
                
                layer.style.transform = `perspective(1000px) rotateX(${animRotation}deg)`;
                
                // Réanimer progressivement
                setTimeout(() => {
                    animateSoilLayers();
                }, 1000 + Math.random() * 500);
            });
        }
        
    } catch (error) {
        console.error("Erreur lors de la création du graphique de température:", error);
        container.innerHTML = `<div class="bg-red-50 p-4 rounded-lg text-red-600">
            <p><i class="fas fa-exclamation-triangle"></i> Erreur de graphique: ${error.message}</p>
        </div>`;
    }
}

    function updateHumidityChartData(humidity) {
        const now = new Date();
        const newDataPoint = {
            index: state.humidityDataIndex++,
            humidity: parseFloat(humidity.toFixed(1)),
            timestamp: now.toISOString()
        };

        state.humidityChartData.push(newDataPoint);
        
        if (state.humidityChartData.length > 1000) {
            state.humidityChartData.shift();
        }

        saveToLocalStorage();

        if (state.activeSection === 'humidity-section') {
            renderHumidityChart();
        }
    }

    function renderHumidityChart() {
    const container = document.getElementById('humidity-chart');
    if (!container) {
        console.error("Conteneur du graphique d'humidité non trouvé");
        return;
    }

    // Créer une structure complète avec graphique, tableau, zone 3D et boutons de gestion
    container.innerHTML = `
        <div class="chart-container" style="position: relative; height: 350px;">
            <canvas id="humidityChartCanvas"></canvas>
        </div>
     <br><br>
          <!-- Visualisation 3D -->
        <div id="humidity-3d-visualization" style="width: 100%; height: 150px; background: linear-gradient(to right, #dc2626, #f59e0b, #16a34a, #3b82f6); 
             border-radius: 8px; position: relative; overflow: hidden; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
            <div class="soil-layers" style="height: 100%; width: 100%; position: relative;">
                <!-- Les couches du sol seront générées dynamiquement -->
            </div>
            <div class="humidity-indicators" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">
                <!-- Les indicateurs d'humidité seront générés dynamiquement -->
            </div>
            <div class="humidity-scale" style="position: absolute; bottom: 10px; right: 10px; background: rgba(255,255,255,0.8); 
                 padding: 5px; border-radius: 5px; font-size: 12px;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="color: #dc2626;">■</span> Sec
                    <span style="color: #f59e0b;">■</span> Peu humide
                    <span style="color: #16a34a;">■</span> Optimal
                    <span style="color: #3b82f6;">■</span> Très humide
                </div>
            </div>
        </div>
        
        <!-- Tableau de données -->
      <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100 hover:shadow-lg">
    <h3 class="text-base font-semibold text-gray-600 mb-3">Historique des données</h3>
    <div class="max-h-60 overflow-y-auto">
        <table class="w-full text-sm text-gray-600 border-collapse">
            <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                <tr>
                    <th class="p-2 text-left border-b border-gray-200">Heure</th>
                    <th class="p-2 text-center border-b border-gray-200">Humidité (%)</th>
                    <th class="p-2 text-center border-b border-gray-200">Statut</th>
                    <th class="p-2 text-center border-b border-gray-200">Variation</th>
                </tr>
            </thead>
            <tbody id="humidity-data-table">
                <tr>
                    <td colspan="4" class="text-center text-gray-400 p-2">
                        Chargement des données...
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>
        
      
        <!-- Boutons de gestion des données -->
        <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100">
            <h3 class="text-base font-semibold text-gray-600 mb-4">Gestion des données</h3>
            
            <div class="flex flex-wrap gap-3">
                <button onclick="showHumidityFullHistory()" class="btn-gestion">
                    <i class="fas fa-history"></i>
                    <span>Historique complet</span>
                </button>
                
                <button onclick="exportHumidityData('xlsx')" class="btn-gestion">
                    <i class="fas fa-file-excel"></i>
                    <span>Exporter Excel</span>
                </button>
                
                <button onclick="exportHumidityToPDF()" class="btn-gestion">
                    <i class="fas fa-file-pdf"></i>
                    <span>PDF (.pdf)</span>
                </button>
                
                <button onclick="exportHumidityChartImage()" class="btn-gestion">
                    <i class="fas fa-camera"></i>
                    <span>Exporter Image</span>
                </button>
                
                <button onclick="resetHumidityData()" class="btn-gestion">
                    <i class="fas fa-trash-alt"></i>
                    <span>Réinitialiser</span>
                </button>
            </div>
        </div>
    `;

    // Préparation des données
    const timeLabels = state.humidityChartData.map(d => {
        if (d.timestamp) {
            return new Date(d.timestamp).toLocaleTimeString();
        }
        return `Mesure ${d.index}`;
    });
    
    const humidityData = state.humidityChartData.map(d => d.humidity);
    
    if (humidityChart) {
        humidityChart.destroy();
    }

    // Définitions des fonctions de couleur
    const getHumidityColor = (humidity) => {
        if (humidity < 20) return '#dc2626';       // Rouge (très sec)
        if (humidity < 30) return '#f59e0b';       // Orange (sec)
        if (humidity < 70) return '#16a34a';       // Vert (optimal)
        if (humidity < 85) return '#60a5fa';       // Bleu clair (humide)
        return '#3b82f6';                          // Bleu (très humide)
    };
    
    const getHumidityStatus = (humidity) => {
        if (humidity < 20) return "Très sec";
        if (humidity < 30) return "Sec";
        if (humidity < 70) return "Optimal";
        if (humidity < 85) return "Humide";
        return "Très humide";
    };

    try {
        // Création du graphique principal
        const ctx = document.getElementById('humidityChartCanvas').getContext('2d');
        
        humidityChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Humidité du sol (%)',
                        data: humidityData,
                        borderWidth: 3,
                        borderColor: function(context) {
                            const index = context.dataIndex;
                            const value = humidityData[index];
                            return getHumidityColor(value);
                        },
                        backgroundColor: 'rgba(14, 165, 233, 0.1)',
                        tension: 0.4,
                        pointRadius: 0,
                        pointBackgroundColor: function(context) {
                            const index = context.dataIndex;
                            const value = humidityData[index];
                            return getHumidityColor(value);
                        },
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const humidity = context.parsed.y;
                                return `Humidité: ${humidity.toFixed(1)}% `;
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x'
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            mode: 'x'
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Humidité du sol (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Heure de mesure'
                        }
                    }
                }
            }
        });
        
        // Génération du tableau de données
        populateHumidityDataTable();
        
        // Création de la visualisation 3D
        createHumidity3DVisualization();
        
        // Fonction pour remplir le tableau de données
        function populateHumidityDataTable() {
            const tableBody = document.getElementById('humidity-data-table');
            if (!tableBody) return;
            
            let tableContent = '';
            
            // Parcourir les données d'humidité en ordre inverse (plus récentes d'abord)
            const dataPoints = state.humidityChartData.slice();
            dataPoints.reverse();
            
            dataPoints.forEach((dataPoint, index, array) => {
                const humidity = dataPoint.humidity;
                const status = getHumidityStatus(humidity);
                const statusColor = getHumidityColor(humidity);
                
                // Calculer la variation par rapport à la mesure précédente
                let variation = '';
                let variationClass = '';
                
                if (index < array.length - 1) {
                    const prevHumidity = array[index + 1].humidity;
                    const diff = humidity - prevHumidity;
                    
                    if (diff > 1) {
                        variation = `+${diff.toFixed(1)}%`;
                        variationClass = 'text-blue-600';
                    } else if (diff < -1) {
                        variation = `${diff.toFixed(1)}%`;
                        variationClass = 'text-red-600';
                    } else {
                        variation = 'Stable';
                        variationClass = 'text-gray-600';
                    }
                } else {
                    variation = '-';
                    variationClass = 'text-gray-400';
                }
                
                // Formatter l'heure
                let timeStr = 'N/A';
                if (dataPoint.timestamp) {
                    const date = new Date(dataPoint.timestamp);
                    timeStr = date.toLocaleTimeString();
                }
                
                // Couleur d'arrière-plan alternée
                const rowBg = index % 2 === 0 ? 'bg-sky-50' : 'bg-white';
                
                tableContent += `
                    <tr class="${rowBg} hover:bg-sky-100 transition-colors duration-150">
                        <td class="p-2 border-b border-sky-100">${timeStr}</td>
                        <td class="p-2 text-center border-b border-sky-100 font-semibold" style="color: ${statusColor}">
                            ${humidity.toFixed(1)}%
                        </td>
                        <td class="p-2 text-center border-b border-sky-100">
                            <span class="px-2 py-1 rounded-full text-xs font-medium" 
                                  style="background-color: ${statusColor}1A; color: ${statusColor}">
                                ${status}
                            </span>
                        </td>
                        <td class="p-2 text-center border-b border-sky-100 ${variationClass}">
                            ${variation}
                        </td>
                    </tr>
                `;
            });
            
            if (tableContent === '') {
                tableContent = `
                    <tr>
                        <td colspan="4" class="text-center text-gray-400 p-4">
                            Aucune donnée disponible
                        </td>
                    </tr>
                `;
            }
            
            tableBody.innerHTML = tableContent;
        }
        
        // Fonction pour créer la visualisation 3D d'humidité
        function createHumidity3DVisualization() {
            const container = document.getElementById('humidity-3d-visualization');
            const soilLayers = container.querySelector('.soil-layers');
            const indicators = container.querySelector('.humidity-indicators');
            
            if (!soilLayers || !indicators) return;
            
            // Récupérer la dernière valeur d'humidité (ou la moyenne si disponible)
            const currentHumidity = humidityData.length > 0 ? humidityData[humidityData.length - 1] : 50;
            
            // Générer les couches du sol
            soilLayers.innerHTML = '';
            
            // Créer 5 couches
            for (let i = 0; i < 5; i++) {
                const layer = document.createElement('div');
                const depth = i * 20; // 0%, 20%, 40%, 60%, 80% depuis le haut
                
                // L'humidité augmente légèrement avec la profondeur
                const depthHumidity = Math.min(100, currentHumidity + (i * 2));
                const layerColor = getHumidityColor(depthHumidity);
                
                // La transparence augmente avec l'humidité
                const opacity = 0.3 + (depthHumidity / 300);
                
                layer.style.cssText = `
                    position: absolute;
                    top: ${depth}%;
                    left: 0;
                    width: 100%;
                    height: 20%;
                    background: ${layerColor}${Math.round(opacity * 100).toString(16).padStart(2, '0')};
                    border-bottom: 1px solid ${layerColor};
                    transition: all 0.5s ease;
                    transform-style: preserve-3d;
                    transform: perspective(1000px) rotateX(${10 - i * 2}deg);
                `;
                
                // Ajouter un indicateur d'humidité
                layer.innerHTML = `
                    <div style="position: absolute; bottom: 5px; right: 10px; 
                                 color: ${layerColor}; font-weight: bold; font-size: 12px;">
                        ${depthHumidity.toFixed(1)}%
                    </div>
                    <div style="position: absolute; bottom: 5px; left: 10px; color: rgba(0,0,0,0.6); font-size: 11px;">
                        Profondeur: ${i * 10} cm
                    </div>
                `;
                
                soilLayers.appendChild(layer);
            }
            
            // Ajouter des indicateurs visuels selon l'humidité
            indicators.innerHTML = '';
            
            // Nombre de gouttes basé sur l'humidité
            const numDrops = Math.floor(currentHumidity / 10);
            
            if (currentHumidity < 20) {
                // Sol sec - crevasses
                indicators.innerHTML += `
                    <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
                                text-align: center; color: #dc2626; font-weight: bold;">
                        <i class="fas fa-sun" style="font-size: 24px;"></i>
                        <div style="font-size: 12px; margin-top: 5px;">Sol très sec</div>
                    </div>
                `;
                
                // Ajouter des crevasses au sol
                for (let i = 0; i < 5; i++) {
                    const left = 10 + Math.random() * 80;
                    const top = 20 + Math.random() * 60;
                    const width = 5 + Math.random() * 30;
                    const height = 2 + Math.random() * 5;
                    const angle = -15 + Math.random() * 30;
                    
                    indicators.innerHTML += `
                        <div style="position: absolute; top: ${top}%; left: ${left}%; 
                                     width: ${width}px; height: ${height}px; background-color: rgba(0,0,0,0.3);
                                     transform: rotate(${angle}deg);"></div>
                    `;
                }
            } else if (currentHumidity > 85) {
                // Sol très humide - beaucoup de gouttes
                indicators.innerHTML += `
                    <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
                                text-align: center; color: #3b82f6; font-weight: bold;">
                        <i class="fas fa-tint" style="font-size: 24px;"></i>
                        <div style="font-size: 12px; margin-top: 5px;">Sol saturé d'eau</div>
                    </div>
                `;
                
                // Flaque d'eau
                indicators.innerHTML += `
                    <div style="position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%);
                                width: 80%; height: 40%; background-color: rgba(59, 130, 246, 0.3);
                                border-radius: 50%; box-shadow: inset 0 0 20px rgba(0,0,0,0.1);"></div>
                `;
            } else if (currentHumidity >= 30 && currentHumidity <= 70) {
                // Sol optimal
                indicators.innerHTML += `
                    <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
                                text-align: center; color: #16a34a; font-weight: bold;">
                        <i class="fas fa-check-circle" style="font-size: 24px;"></i>
                        <div style="font-size: 12px; margin-top: 5px;">Humidité optimale</div>
                    </div>
                `;
            }
            
            // Ajouter des gouttes d'eau en fonction de l'humidité
            for (let i = 0; i < numDrops; i++) {
                const size = 4 + Math.random() * 6;
                const left = Math.random() * 95;
                const top = 10 + Math.random() * 80;
                const opacity = 0.4 + Math.random() * 0.5;
                
                indicators.innerHTML += `
                    <div class="water-drop" style="position: absolute; top: ${top}%; left: ${left}%; 
                         width: ${size}px; height: ${size * 1.5}px; background-color: rgba(59, 130, 246, ${opacity});
                         border-radius: 50% 50% 50% 0; transform: rotate(45deg);"></div>
                `;
            }
            
            // Ajouter effet de profondeur 3D
            const depthEffect = document.createElement('div');
            depthEffect.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(to bottom, 
                            rgba(0,0,0,0) 0%, 
                            rgba(0,0,0,0.1) 40%, 
                            rgba(0,0,0,0.2) 70%, 
                            rgba(0,0,0,0.3) 100%);
                pointer-events: none;
            `;
            container.appendChild(depthEffect);
            
            // Animation des gouttes d'eau
            animateWaterDrops();
        }
        
        // Animation des gouttes d'eau
        function animateWaterDrops() {
            const drops = document.querySelectorAll('.water-drop');
            
            drops.forEach(drop => {
                const duration = 2000 + Math.random() * 3000;
                const delay = Math.random() * 1000;
                
                drop.style.transition = `transform ${duration}ms ease-in-out ${delay}ms, 
                                        opacity ${duration}ms ease-in-out ${delay}ms`;
                
                setTimeout(() => {
                    // Les gouttes se déplacent vers le bas
                    const moveY = 10 + Math.random() * 20;
                    drop.style.transform = `rotate(45deg) translateY(${moveY}px)`;
                    drop.style.opacity = '0';
                    
                    // Réinitialiser après l'animation
                    setTimeout(() => {
                        drop.style.transition = 'none';
                        drop.style.transform = 'rotate(45deg)';
                        drop.style.opacity = '1';
                        
                        // Relancer l'animation
                        setTimeout(() => animateWaterDrops(), 100);
                    }, duration + delay);
                }, 50);
            });
        }
        
    } catch (error) {
        console.error("Erreur lors de la création du graphique d'humidité:", error);
        container.innerHTML = `<div class="bg-red-50 p-4 rounded-lg text-red-600">
            <p><i class="fas fa-exclamation-triangle"></i> Erreur de graphique: ${error.message}</p>
        </div>`;
    }
}

function updateRainChartData(rainAmount) {
    const now = new Date();
    const newDataPoint = {
        index: state.rainDataIndex++,
        rainAmount: parseFloat(rainAmount.toFixed(1)),
        timestamp: now.toISOString()
    };

    state.rainChartData.push(newDataPoint);
    
    if (state.rainChartData.length > 1000) {
        state.rainChartData.shift();
    }

    saveToLocalStorage();

    if (state.activeSection === 'rain-section') {
        renderRainChart();
    }
}

function renderRainChart() {
    const container = document.getElementById('rain-chart');
    if (!container) {
        console.error("Conteneur du graphique de pluie non trouvé");
        return;
    }

    // Préparer la structure du graphique
    container.innerHTML = `
    <div class="chart-container" style="position: relative; height: 350px;">
        <canvas id="rainChartCanvas"></canvas>
    </div>
    
    <div class="bg-white rounded-xl shadow-md p-5 mt-6 border border-gray-100">
        <h3 class="text-base font-semibold text-gray-600 mb-3">Historique des précipitations</h3>
        <div class="max-h-60 overflow-y-auto">
            <table class="w-full text-sm text-gray-600 border-collapse">
                <thead class="bg-gray-50 uppercase text-xs text-gray-700 sticky top-0">
                    <tr>
                        <th class="p-2 text-left border-b border-gray-200">Heure</th>
                        <th class="p-2 text-center border-b border-gray-200">Quantité (mm)</th>
                        <th class="p-2 text-center border-b border-gray-200">Intensité</th>
                        <th class="p-2 text-center border-b border-gray-200">Variation</th>
                    </tr>
                </thead>
                <tbody id="rain-data-table">
                    <!-- Les données seront insérées ici -->
                </tbody>
            </table>
        </div>
    </div>
`;

    // Préparation des données
    const timeLabels = state.rainChartData.map(d => {
        if (d.timestamp) {
            return new Date(d.timestamp).toLocaleTimeString();
        }
        return `Mesure ${d.index}`;
    });
    
    const rainData = state.rainChartData.map(d => d.rainAmount);
    
    if (rainChart) {
        rainChart.destroy();
    }

    try {
        // Création du graphique principal
        const ctx = document.getElementById('rainChartCanvas').getContext('2d');
        
        rainChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Précipitations (mm)',
                        data: rainData,
                        backgroundColor: function(context) {
                            const index = context.dataIndex;
                            const value = rainData[index];
                            return getRainIntensity(value).color + 'CC'; // Ajouter transparence
                        },
                        borderColor: function(context) {
                            const index = context.dataIndex;
                            const value = rainData[index];
                            return getRainIntensity(value).color;
                        },
                        borderWidth: 1,
                        barPercentage: 0.8,
                        categoryPercentage: 0.9
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const rain = context.parsed.y;
                                const intensity = getRainIntensity(rain);
                                return `Précipitations: ${rain.toFixed(1)}`;
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x'
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            mode: 'x'
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Précipitations (mm)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Heure de mesure'
                        }
                    }
                }
            }
        });
        
        // Générer le tableau de données
        populateRainDataTable();
        
        // Créer la visualisation 3D
        createRain3DVisualization();
        
    } catch (error) {
        console.error("Erreur lors de la création du graphique de pluie:", error);
        container.innerHTML = `<div class="bg-red-50 p-4 rounded-lg text-red-600">
            <p><i class="fas fa-exclamation-triangle"></i> Erreur de graphique: ${error.message}</p>
        </div>`;
    }
}



function populateRainDataTable() {
    const tableBody = document.getElementById('rain-data-table');
    if (!tableBody) {
        console.error("Élément rain-data-table non trouvé");
        return;
    }

    // Vérifier si des données existent
    if (state.rainChartData.length === 0) {
        tableBody.innerHTML = `
            <tr>
                <td colspan="4" class="text-center text-gray-400 p-4">
                    Aucune donnée de précipitations disponible
                </td>
            </tr>
        `;
        return;
    }

    let tableContent = '';
    
    // Parcourir les données de pluie du plus récent au plus ancien
    const reversedData = [...state.rainChartData].reverse();
    
    reversedData.forEach((dataPoint, index) => {
        const rain = dataPoint.rainAmount;
        const intensity = getRainIntensity(rain);
        
        // Calculer la variation
        let variation = '';
        let variationClass = '';
        
        if (index < reversedData.length - 1) {
            const prevRain = reversedData[index + 1].rainAmount;
            const diff = rain - prevRain;
            
            if (diff > 0.5) {
                variation = `+${diff.toFixed(1)} mm`;
                variationClass = 'text-blue-600';
            } else if (diff < -0.5) {
                variation = `${diff.toFixed(1)} mm`;
                variationClass = 'text-gray-600';
            } else {
                variation = 'Stable';
                variationClass = 'text-gray-600';
            }
        } else {
            variation = '-';
            variationClass = 'text-gray-400';
        }
        
        // Formater l'heure
        const timeStr = dataPoint.timestamp 
            ? new Date(dataPoint.timestamp).toLocaleTimeString() 
            : 'N/A';
        
        tableContent += `
            <tr class="hover:bg-indigo-50">
                <td class="p-2 border-b border-indigo-100">${timeStr}</td>
                <td class="p-2 text-center border-b border-indigo-100 font-semibold" style="color: ${intensity.color}">
                    ${rain.toFixed(1)} mm
                </td>
                <td class="p-2 text-center border-b border-indigo-100">
                    <span class="px-2 py-1 rounded-full text-xs font-medium" 
                          style="background-color: ${intensity.color}1A; color: ${intensity.color}">
                        ${intensity.status}
                    </span>
                </td>
                <td class="p-2 text-center border-b border-indigo-100 ${variationClass}">
                    ${variation}
                </td>
            </tr>
        `;
    });
    
    tableBody.innerHTML = tableContent;
}

function updateAmbientHistoryTables() {
    // Mettre à jour le tableau de température ambiante
    const tempTable = document.getElementById('ambient-temp-history');
    if (tempTable && state.sensorHistory.ambientTemperature.length > 0) {
        let html = '';
        const temps = state.sensorHistory.ambientTemperature;
        
        temps.forEach((temp, index, array) => {
            const status = getAmbientTempStatus(temp);
            const statusStyle = `color: ${status.color}`;
            
            // Calculer la variation
            let variation = '';
            let variationClass = '';
            
            if (index < array.length - 1) {
                const prevTemp = array[index + 1];
                const diff = temp - prevTemp;
                
                if (diff > 0.2) {
                    variation = `+${diff.toFixed(1)}°C`;
                    variationClass = 'text-red-600';
                } else if (diff < -0.2) {
                    variation = `${diff.toFixed(1)}°C`;
                    variationClass = 'text-blue-600';
                } else {
                    variation = 'Stable';
                    variationClass = 'text-gray-600';
                }
            } else {
                variation = '-';
                variationClass = 'text-gray-400';
            }
            
            // Format de l'heure
            const now = new Date();
            const timeStr = new Date(now - index * 60000).toLocaleTimeString();
            
            html += `
        <tr class="hover:bg-purple-50">  <!-- Ajout de la couleur de survol violet clair -->
          <td class="p-2 border-b border-purple-100">${timeStr}</td>  <!-- Bordure violette -->
          <td class="p-2 text-center border-b border-purple-100 font-semibold" style="${statusStyle}">
            ${temp.toFixed(1)}°C
          </td>
          <td class="p-2 text-center border-b border-purple-100">
            <span class="px-2 py-1 rounded-full text-xs font-medium" 
                  style="background-color: ${status.color}1A; color: ${status.color}">
              ${status.label}
            </span>
          </td>
          <td class="p-2 text-center border-b border-purple-100 ${variationClass}">
            ${variation}
          </td>
        </tr>
      `;
        });
        
        tempTable.innerHTML = html;
    } else if (tempTable) {
        tempTable.innerHTML = `
            <tr><td colspan="4" class="text-center text-gray-400 p-2">Aucune donnée historique</td></tr>
        `;
    }
    
    // Mettre à jour le tableau d'humidité ambiante
    const humidityTable = document.getElementById('ambient-humidity-history');
    if (humidityTable && state.sensorHistory.ambientHumidity.length > 0) {
        let html = '';
        const humidities = state.sensorHistory.ambientHumidity;
        
        humidities.forEach((humidity, index, array) => {
            const status = getAmbientHumidityStatus(humidity);
            const statusStyle = `color: ${status.color}`;
            
            // Calculer la variation
            let variation = '';
            let variationClass = '';
            
            if (index < array.length - 1) {
                const prevHumidity = array[index + 1];
                const diff = humidity - prevHumidity;
                
                if (diff > 1) {
                    variation = `+${diff.toFixed(1)}%`;
                    variationClass = 'text-blue-600';
                } else if (diff < -1) {
                    variation = `${diff.toFixed(1)}%`;
                    variationClass = 'text-red-600';
                } else {
                    variation = 'Stable';
                    variationClass = 'text-gray-600';
                }
            } else {
                variation = '-';
                variationClass = 'text-gray-400';
            }
            
            // Format de l'heure
            const now = new Date();
            const timeStr = new Date(now - index * 60000).toLocaleTimeString();
            
           
                html += `
        <tr class="hover:bg-purple-50">  <!-- Ajout de la couleur de survol violet clair -->
          <td class="p-2 border-b border-purple-100">${timeStr}</td>  <!-- Bordure violette -->
          <td class="p-2 text-center border-b border-purple-100 font-semibold" style="${statusStyle}">
            ${temp.toFixed(1)}°C
          </td>
          <td class="p-2 text-center border-b border-purple-100">
            <span class="px-2 py-1 rounded-full text-xs font-medium" 
                  style="background-color: ${status.color}1A; color: ${status.color}">
              ${status.label}
            </span>
          </td>
          <td class="p-2 text-center border-b border-purple-100 ${variationClass}">
            ${variation}
          </td>
        </tr>
      
 `;
        });
        
        humidityTable.innerHTML = html;
    } else if (humidityTable) {
        humidityTable.innerHTML = `
            <tr><td colspan="4" class="text-center text-gray-400 p-2">Aucune donnée historique</td></tr>
        `;
    }
}


// Fonction pour mettre à jour les tendances des capteurs
function updateTrends(temperature, humidity) {
    // Obtenir les éléments pour les tendances
    const tempTrend = document.getElementById('tempTrend');
    const humidityTrend = document.getElementById('humidityTrend');
    
    // Vérifier s'il y a des données historiques
    if (state.sensorHistory.ambientTemperature.length > 1) {
        const prevTemp = state.sensorHistory.ambientTemperature[1];
        const diff = temperature - prevTemp;
        
        if (diff > 0.2) {
            tempTrend.innerHTML = '<i class="fas fa-arrow-up text-red-500"></i>';
        } else if (diff < -0.2) {
            tempTrend.innerHTML = '<i class="fas fa-arrow-down text-blue-500"></i>';
        } else {
            tempTrend.innerHTML = '<i class="fas fa-equals opacity-50"></i>';
        }
    }
    
    if (state.sensorHistory.ambientHumidity.length > 1) {
        const prevHumidity = state.sensorHistory.ambientHumidity[1];
        const diff = humidity - prevHumidity;
        
        if (diff > 1) {
            humidityTrend.innerHTML = '<i class="fas fa-arrow-up text-blue-500"></i>';
        } else if (diff < -1) {
            humidityTrend.innerHTML = '<i class="fas fa-arrow-down text-red-500"></i>';
        } else {
            humidityTrend.innerHTML = '<i class="fas fa-equals opacity-50"></i>';
        }
    }
}

// Fonction pour mettre à jour les visualisations 3D
function update3DVisualizations() {
    // Vérifier que les éléments existent avant de les utiliser
    if (elements.temp3dValue) {
        elements.temp3dValue.textContent = state.sensorData.ambientTemperature.toFixed(1);
    } else {
        console.warn("Élément temp3dValue non trouvé");
        return; // Sortir si un élément essentiel est manquant
    }
    
    if (elements.humidity3dValue) {
        elements.humidity3dValue.textContent = state.sensorData.ambientHumidity.toFixed(1);
    } else {
        console.warn("Élément humidity3dValue non trouvé");
        return;
    }

    const temp = state.sensorData.ambientTemperature;
    const humidity = state.sensorData.ambientHumidity;
    
    // Vérification des éléments avant modification
    if (elements.tempIndicator) {
        // Mettre à jour le thermomètre
        const tempHeight = Math.max(0, Math.min(100, (temp - 10) * 5)); // 10-30°C mappe à 0-100%
        elements.tempIndicator.style.height = `${tempHeight}%`;
    }
    
    // Mettre à jour les gouttes d'humidité si l'élément existe
    if (elements.humidityDrops) {
        const numDrops = Math.floor(humidity / 10); // 1 goutte pour 10% d'humidité
        updateRaindrops(numDrops);
    }
    
    // Vérification des autres éléments
    if (elements.dewPoint && elements.dewPointDesc) {
        // Calculer et mettre à jour le point de rosée
        const dewPoint = calculateDewPoint(temp, humidity);
        elements.dewPoint.textContent = dewPoint.toFixed(1);
        
        if (dewPoint > temp - 2) {
            elements.dewPointDesc.textContent = "Risque de condensation élevé";
            elements.dewPointDesc.className = "text-xs text-red-600 text-center mt-1";
        } else if (dewPoint > temp - 5) {
            elements.dewPointDesc.textContent = "Attention à l'humidité élevée";
            elements.dewPointDesc.className = "text-xs text-amber-600 text-center mt-1";
        } else {
            elements.dewPointDesc.textContent = "Conditions sèches, pas de condensation";
            elements.dewPointDesc.className = "text-xs text-green-600 text-center mt-1";
        }
    }
    
    if (elements.heatIndex && elements.heatIndexDesc) {
        // Calculer et mettre à jour l'indice de chaleur
        const heatIndex = calculateHeatIndex(temp, humidity);
        elements.heatIndex.textContent = heatIndex.toFixed(1);
        
        if (heatIndex > temp + 5) {
            elements.heatIndexDesc.textContent = "Sensation de chaleur élevée";
            elements.heatIndexDesc.className = "text-xs text-red-600 text-center mt-1";
        } else if (heatIndex > temp + 2) {
            elements.heatIndexDesc.textContent = "Légère augmentation de la chaleur ressentie";
            elements.heatIndexDesc.className = "text-xs text-amber-600 text-center mt-1";
        } else {
            elements.heatIndexDesc.textContent = "Température ressentie normale";
            elements.heatIndexDesc.className = "text-xs text-green-600 text-center mt-1";
        }
    }
    
    // Mettre à jour la jauge de confort si les éléments existent
    if (elements.comfortMarker && elements.comfortText) {
        updateComfortGauge(temp, humidity);
    }
}


// Fonction pour mettre à jour la rotation de la pièce 3D

// Ajouter ces fonctions dans le script

function updateRoomEnvironment(temp, humidity) {
    // Implémentation basique - à adapter selon vos besoins
    if (!elements.roomContainer) return;
    
    // Exemple: changer la couleur des murs en fonction de la température
    const hue = 240 - (temp * 4); // Bleu (froid) à Rouge (chaud)
    elements.roomContainer.style.backgroundColor = `hsl(${hue}, 70%, 80%)`;
}

function updateComfortIndicators(temp, humidity) {
    // Mettre à jour les indicateurs de confort
    if (!elements.comfortMarker || !elements.comfortText) return;
    
    // Calcul simplifié du confort
    const comfortValue = (temp * 0.6) + (humidity * 0.4);
    const position = Math.min(100, Math.max(0, comfortValue));
    
    elements.comfortMarker.style.left = `${position}%`;
    
    // Texte descriptif
    if (comfortValue < 30) {
        elements.comfortText.textContent = "Froid et sec";
        elements.comfortText.className = "text-blue-600";
    } else if (comfortValue < 60) {
        elements.comfortText.textContent = "Confortable";
        elements.comfortText.className = "text-green-600";
    } else {
        elements.comfortText.textContent = "Chaud et humide";
        elements.comfortText.className = "text-red-600";
    }
}


// Fonctions pour les calculs de confort

function calculateDewPoint(temp, humidity) {
    // Formule simplifiée du point de rosée
    const a = 17.27;
    const b = 237.7;
    const alpha = ((a * temp) / (b + temp)) + Math.log(humidity / 100);
    return (b * alpha) / (a - alpha);
}

function calculateHeatIndex(temp, humidity) {
    // Formule simplifiée de l'indice de chaleur (valide entre 20°C et 50°C)
    if (temp < 20) return temp;
    
    // Convertir en Fahrenheit pour la formule standard
    const tempF = (temp * 9/5) + 32;
    const rh = humidity;
    
    let heatIndexF = 0.5 * (tempF + 61 + ((tempF - 68) * 1.2) + (rh * 0.094));
    
    // Pour des températures élevées, utiliser une formule plus précise
    if (tempF >= 80) {
        heatIndexF = -42.379 + 2.04901523 * tempF + 10.14333127 * rh - 0.22475541 * tempF * rh - 0.00683783 * tempF * tempF - 0.05481717 * rh * rh + 0.00122874 * tempF * tempF * rh + 0.00085282 * tempF * rh * rh - 0.00000199 * tempF * tempF * rh * rh;
    }
    
    // Convertir en Celsius
    return (heatIndexF - 32) * 5/9;
}


// Fonctions pour déterminer le statut de température et d'humidité
function getAmbientTempStatus(temp) {
    if (temp < 16) {
        return { color: '#3b82f6', label: 'Froid' }; // Bleu
    } else if (temp < 19) {
        return { color: '#60a5fa', label: 'Frais' }; // Bleu clair
    } else if (temp < 24) {
        return { color: '#10b981', label: 'Confortable' }; // Vert
    } else if (temp < 27) {
        return { color: '#f59e0b', label: 'Chaud' }; // Orange
    } else {
        return { color: '#ef4444', label: 'Très chaud' }; // Rouge
    }
}

function getAmbientHumidityStatus(humidity) {
    if (humidity < 30) {
        return { color: '#ef4444', label: 'Sec' }; // Rouge
    } else if (humidity < 40) {
        return { color: '#f59e0b', label: 'Légèrement sec' }; // Orange
    } else if (humidity < 60) {
        return { color: '#10b981', label: 'Optimal' }; // Vert
    } else if (humidity < 70) {
        return { color: '#60a5fa', label: 'Légèrement humide' }; // Bleu clair
    } else {
        return { color: '#3b82f6', label: 'Très humide' }; // Bleu
    }
}

// Fonction pour mettre à jour les données de température ambiante
function updateAmbientTempChartData(temperature) {
    const now = new Date();
    const newDataPoint = {
        index: state.ambientTempDataIndex++,
        temperature: parseFloat(temperature.toFixed(1)),
        timestamp: now.toISOString()
    };

    state.ambientTempChartData.push(newDataPoint);
    
    if (state.ambientTempChartData.length > 1000) {
        state.ambientTempChartData.shift();
    }

    saveToLocalStorage();

    if (state.activeSection === 'ambient-section') {
        renderAmbientTempChart();
    }
}

// Fonction pour afficher le graphique de température ambiante
function renderAmbientTempChart() {
    const container = document.getElementById('ambient-temp-chart');
    if (!container) {
        console.error("Conteneur du graphique de température ambiante non trouvé");
        return;
    }

    container.innerHTML = '<canvas id="ambientTempCanvas"></canvas>';
    const ctx = document.getElementById('ambientTempCanvas').getContext('2d');

    // Préparation des données
    const timeLabels = state.ambientTempChartData.map(d => {
        if (d.timestamp) {
            return new Date(d.timestamp).toLocaleTimeString();
        }
        return `Mesure ${d.index}`;
    });
    
    const tempData = state.ambientTempChartData.map(d => d.temperature);
    
    if (ambientTempChart) {
        ambientTempChart.destroy();
    }

    try {
        ambientTempChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Température Ambiante (°C)',
                        data: tempData,
                        borderWidth: 3,
                        borderColor: function(context) {
                            const index = context.dataIndex;
                            const value = tempData[index];
                            return getAmbientTempStatus(value).color;
                        },
                        backgroundColor: 'rgba(147, 51, 234, 0.1)',
                        tension: 0.4,
                        pointRadius: 0,
                        pointBackgroundColor: function(context) {
                            const index = context.dataIndex;
                            const value = tempData[index];
                            return getAmbientTempStatus(value).color;
                        },
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const temp = context.parsed.y;
                                const status = getAmbientTempStatus(temp);
                                return `Température: ${temp.toFixed(1)}°C `;
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x'
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            mode: 'x'
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: false,
                        suggestedMin: Math.max(0, Math.min(...tempData) - 5),
                        suggestedMax: Math.max(...tempData) + 5,
                        ticks: {
                            callback: function(value) {
                                return value + '°C';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Température Ambiante (°C)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Heure de mesure'
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error("Erreur lors de la création du graphique de température ambiante:", error);
        container.innerHTML = `<div class="bg-red-50 p-4 rounded-lg text-red-600">
            <p><i class="fas fa-exclamation-triangle"></i> Erreur de graphique: ${error.message}</p>
        </div>`;
    }
}

// Fonction pour mettre à jour les données d'humidité ambiante
function updateAmbientHumidityChartData(humidity) {
    const now = new Date();
    const newDataPoint = {
        index: state.ambientHumidityDataIndex++,
        humidity: parseFloat(humidity.toFixed(1)),
        timestamp: now.toISOString()
    };

    state.ambientHumidityChartData.push(newDataPoint);
    
    if (state.ambientHumidityChartData.length > 1000) {
        state.ambientHumidityChartData.shift();
    }

    saveToLocalStorage();

    if (state.activeSection === 'ambient-section') {
        renderAmbientHumidityChart();
    }
}

// Fonction pour afficher le graphique d'humidité ambiante
function renderAmbientHumidityChart() {
    const container = document.getElementById('ambient-humidity-chart');
    if (!container) {
        console.error("Conteneur du graphique d'humidité ambiante non trouvé");
        return;
    }

    container.innerHTML = '<canvas id="ambientHumidityCanvas"></canvas>';
    const ctx = document.getElementById('ambientHumidityCanvas').getContext('2d');

    // Préparation des données
    const timeLabels = state.ambientHumidityChartData.map(d => {
        if (d.timestamp) {
            return new Date(d.timestamp).toLocaleTimeString();
        }
        return `Mesure ${d.index}`;
    });
    
    const humidityData = state.ambientHumidityChartData.map(d => d.humidity);
    
    if (ambientHumidityChart) {
        ambientHumidityChart.destroy();
    }

    try {
        ambientHumidityChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: timeLabels,
                datasets: [
                    {
                        label: 'Humidité Ambiante (%)',
                        data: humidityData,
                        borderWidth: 3,
                        borderColor: function(context) {
                            const index = context.dataIndex;
                            const value = humidityData[index];
                            return getAmbientHumidityStatus(value).color;
                        },
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        tension: 0.4,
                        pointRadius: 0,
                        pointBackgroundColor: function(context) {
                            const index = context.dataIndex;
                            const value = humidityData[index];
                            return getAmbientHumidityStatus(value).color;
                        },
                        pointBorderColor: 'white',
                        pointBorderWidth: 2,
                        fill: true
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const humidity = context.parsed.y;
                                const status = getAmbientHumidityStatus(humidity);
                                return `Humidité: ${humidity.toFixed(1)}% `;
                            }
                        }
                    },
                    zoom: {
                        pan: {
                            enabled: true,
                            mode: 'x'
                        },
                        zoom: {
                            wheel: {
                                enabled: true,
                            },
                            mode: 'x'
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: function(value) {
                                return value + '%';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Humidité Ambiante (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Heure de mesure'
                        }
                    }
                }
            }
        });
    } catch (error) {
        console.error("Erreur lors de la création du graphique d'humidité ambiante:", error);
        container.innerHTML = `<div class="bg-red-50 p-4 rounded-lg text-red-600">
            <p><i class="fas fa-exclamation-triangle"></i> Erreur de graphique: ${error.message}</p>
        </div>`;
    }
}

 // JavaScript pour la section Climat Ambiant (avec modifications de couleur violet → noir)

// Fonction pour mettre à jour l'apparence en fonction de l'heure
function updateDayNightCycle() {
  // Obtenir l'heure actuelle
  const now = new Date();
  const hours = now.getHours();
  const minutes = now.getMinutes();
  
  // Mettre à jour l'affichage de l'heure
  const timeDisplay = document.getElementById('time-display');
  if (timeDisplay) {
    timeDisplay.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }
  
  // Éléments à modifier
  const sky = document.getElementById('sky');
  const ground = document.getElementById('ground');
  const celestialBody = document.getElementById('celestial-body');
  const stars = document.getElementById('stars');
  const clouds = document.querySelectorAll('.cloud');
  const scene = document.getElementById('ambient-3d-scene');
  
  if (!sky || !ground || !celestialBody || !stars || !scene) return;
  
  // Déterminer si c'est la journée, le soir, la nuit ou le matin
  // 6-8: aube, 8-18: jour, 18-21: crépuscule, 21-6: nuit
  let timeOfDay;
  if (hours >= 6 && hours < 8) {
    timeOfDay = 'dawn';
  } else if (hours >= 8 && hours < 18) {
    timeOfDay = 'day';
  } else if (hours >= 18 && hours < 21) {
    timeOfDay = 'dusk';
  } else {
    timeOfDay = 'night';
  }
  
  // Appliquer les styles appropriés
  switch (timeOfDay) {
    case 'dawn':
      // Aube - rose-orangé
      sky.style.background = 'linear-gradient(to bottom, #f9a8d4, #c7d2fe)';
      ground.style.background = 'linear-gradient(to bottom, #10b981, #065f46)';
      celestialBody.style.background = '#fef08a';
      celestialBody.style.boxShadow = '0 0 40px rgba(254, 240, 138, 0.6)';
      celestialBody.style.left = '20%';
      celestialBody.style.top = '60px';
      stars.style.opacity = '0.1';
      scene.style.boxShadow = '0 0 20px rgba(249, 168, 212, 0.4)';
      break;
      
    case 'day':
      // Jour - bleu clair
      sky.style.background = 'linear-gradient(to bottom, #93c5fd, #c7d2fe)';
      ground.style.background = 'linear-gradient(to bottom, #10b981, #047857)';
      celestialBody.style.background = '#fde047';
      celestialBody.style.boxShadow = '0 0 40px rgba(253, 224, 71, 0.6)';
      celestialBody.style.left = '80%';
      celestialBody.style.top = '40px';
      stars.style.opacity = '0';
      scene.style.boxShadow = '0 0 20px rgba(147, 197, 253, 0.4)';
      break;
      
    case 'dusk':
      // Crépuscule - orange-violet
      sky.style.background = 'linear-gradient(to bottom, #c084fc, #f87171)';
      ground.style.background = 'linear-gradient(to bottom, #15803d, #064e3b)';
      celestialBody.style.background = '#f87171';
      celestialBody.style.boxShadow = '0 0 40px rgba(248, 113, 113, 0.6)';
      celestialBody.style.left = '20%';
      celestialBody.style.top = '70px';
      stars.style.opacity = '0.2';
      scene.style.boxShadow = '0 0 20px rgba(248, 113, 113, 0.4)';
      break;
      
    case 'night':
      // Nuit - bleu foncé
      sky.style.background = 'linear-gradient(to bottom, #1e3a8a, #3730a3)';
      ground.style.background = 'linear-gradient(to bottom, #064e3b, #022c22)';
      celestialBody.style.background = '#f3f4f6';
      celestialBody.style.boxShadow = '0 0 20px rgba(243, 244, 246, 0.4)';
      celestialBody.style.left = '70%';
      celestialBody.style.top = '50px';
      stars.style.opacity = '1';
      scene.style.boxShadow = '0 0 20px rgba(30, 58, 138, 0.4)';
      break;
  }
  
  // Ajuster l'opacité des nuages en fonction du temps
  clouds.forEach(cloud => {
    if (timeOfDay === 'night') {
      cloud.style.opacity = '0.5';
    } else {
      cloud.style.opacity = '1';
    }
  });
}

// Générer des étoiles pour le ciel nocturne
function generateStars() {
  const stars = document.getElementById('stars');
  if (!stars) return;
  
  // Vider le conteneur
  stars.innerHTML = '';
  
  // Créer 100 étoiles à positions aléatoires
  for (let i = 0; i < 100; i++) {
    const star = document.createElement('div');
    star.classList.add('star');
    star.classList.add(`star-${(i % 3) + 1}`); // Différentes animations
    
    const size = Math.random() * 2 + 1; // Taille entre 1 et 3px
    star.style.width = `${size}px`;
    star.style.height = `${size}px`;
    
    // Position aléatoire
    star.style.left = `${Math.random() * 100}%`;
    star.style.top = `${Math.random() * 70}%`; // Pas plus bas que 70% pour éviter les arbres
    
    // Ajouter au conteneur
    stars.appendChild(star);
  }
}

// Mettre à jour les gouttes d'eau de l'humidité
function updateRaindrops(numDrops) {
  if (!elements.humidityDrops) return;
  
  // Vider le conteneur
  elements.humidityDrops.innerHTML = '';
  
  // Créer les gouttes
  for (let i = 0; i < numDrops; i++) {
    const drop = document.createElement('div');
    const left = Math.random() * 100;
    const delay = Math.random() * 3;
    drop.className = 'absolute raindrop';
    drop.style.cssText = `
        left: ${left}%;
        width: 4px;
        height: 8px;
        background: linear-gradient(45deg, #000000, #555555);
        border-radius: 50% 50% 50% 0;
        transform: rotate(45deg);
        animation: raindropFall 2s linear ${delay}s infinite;
    `;
    elements.humidityDrops.appendChild(drop);
  }
}

// Fonction pour mettre à jour la rotation de la pièce 3D
function updateRoomRotation() {
  if (!elements.roomContainer) {
    console.warn("Élément roomContainer non trouvé pour la rotation");
    return;
  }
  elements.roomContainer.style.transform = `rotateX(${roomRotationX}deg) rotateY(${roomRotationY}deg)`;
}

// Animation des gouttes
function startRaindropsAnimation() {
  state.animateDrops = true;
  
  // S'assurer que animationFrameId est défini
  if (typeof animationFrameId === 'undefined') {
    window.animationFrameId = null;
  }
  
  if (!animationFrameId) {
    // Réinitialiser les gouttes existantes
    if (typeof raindropElements === 'undefined') {
      window.raindropElements = [];
    } else {
      raindropElements = [];
    }
    
    if (elements.humidityDrops) {
      elements.humidityDrops.innerHTML = '';
    } else {
      console.warn("Élément humidityDrops non trouvé pour l'animation");
      return;
    }
    
    // Fonction d'animation
    function animateDrops() {
      if (!state.animateDrops) return;
      
      // Limiter le nombre de gouttes pour améliorer les performances
      const maxDrops = 50; // Maximum de gouttes à afficher simultanément
      
      // Créer de nouvelles gouttes périodiquement mais limiter leur nombre
      if (Math.random() < 0.1 && elements.humidityDrops && raindropElements.length < maxDrops) {
        const humidity = state.sensorData.ambientHumidity;
        const dropProbability = humidity / 100; // Probabilité basée sur l'humidité
        
        if (Math.random() < dropProbability) {
          const drop = document.createElement('div');
          const left = Math.random() * 100;
          drop.className = 'absolute raindrop';
          drop.style.cssText = `
              left: ${left}%;
              top: 0;
              width: 4px;
              height: 8px;
              background: linear-gradient(45deg, #000000, #555555);
              border-radius: 50% 50% 50% 0;
              transform: rotate(45deg);
          `;
          
          elements.humidityDrops.appendChild(drop);
          
          raindropElements.push({
              element: drop,
              top: 0,
              speed: 1 + Math.random()
          });
        }
      }
      
      // Animer les gouttes existantes
      for (let i = raindropElements.length - 1; i >= 0; i--) {
        const drop = raindropElements[i];
        drop.top += drop.speed;
        drop.element.style.top = `${drop.top}px`;
        
        // Supprimer les gouttes qui sont sorties du conteneur
        if (drop.top > 50) {
          if (drop.element.parentNode) {
              drop.element.parentNode.removeChild(drop.element);
          }
          raindropElements.splice(i, 1);
        }
      }
      
      animationFrameId = requestAnimationFrame(animateDrops);
    }
    
    animateDrops();
  }
}

function stopRaindropsAnimation() {
  state.animateDrops = false;
  
  if (typeof animationFrameId !== 'undefined' && animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  
  // Nettoyer les gouttes existantes
  if (typeof raindropElements !== 'undefined') {
    // Supprimer les éléments DOM
    raindropElements.forEach(drop => {
      if (drop.element && drop.element.parentNode) {
        drop.element.parentNode.removeChild(drop.element);
      }
    });
    raindropElements = []; // Vider le tableau
  }
  
  // Nettoyer le conteneur
  if (elements.humidityDrops) {
    elements.humidityDrops.innerHTML = '';
  }
}

// Mise à jour de la jauge de confort
function updateComfortGauge(temp, humidity) {
  // Calculer l'indice de confort (position entre 0 et 100%)
  let comfortPosition = 50; // Valeur par défaut (milieu)
  
  // Température idéale: 20-24°C, Humidité idéale: 40-60%
  if (temp < 16) {
    // Trop froid - position vers la gauche
    comfortPosition = Math.max(0, 30 - (16 - temp) * 5);
  } else if (temp > 26) {
    // Trop chaud - position vers la droite
    comfortPosition = Math.min(100, 70 + (temp - 26) * 5);
  } else {
    // Température confortable - position au milieu avec ajustement pour l'humidité
    if (humidity < 30) {
      comfortPosition = Math.max(10, 40 - (30 - humidity));
    } else if (humidity > 70) {
      comfortPosition = Math.min(90, 60 + (humidity - 70));
    } else {
      comfortPosition = 50; // Zone optimale
    }
  }
  
  // Mettre à jour la position du marqueur
  elements.comfortMarker.style.left = `${comfortPosition}%`;
  
  // Mettre à jour le texte de confort
  if (comfortPosition < 20) {
    elements.comfortText.textContent = "Trop froid";
    elements.comfortText.className = "mt-2 text-center font-medium text-sm text-blue-600";
  } else if (comfortPosition < 40) {
    elements.comfortText.textContent = "Légèrement frais";
    elements.comfortText.className = "mt-2 text-center font-medium text-sm text-blue-400";
  } else if (comfortPosition <= 60) {
    elements.comfortText.textContent = "Conditions confortables";
    elements.comfortText.className = "mt-2 text-center font-medium text-sm text-green-600";
  } else if (comfortPosition < 80) {
    elements.comfortText.textContent = "Légèrement chaud";
    elements.comfortText.className = "mt-2 text-center font-medium text-sm text-amber-500";
  } else {
    elements.comfortText.textContent = "Trop chaud";
    elements.comfortText.className = "mt-2 text-center font-medium text-sm text-red-600";
  }
}

// Initialisation du cycle jour/nuit
function initDayNightCycle() {
  // Générer les étoiles
  generateStars();
  
  // Mettre à jour le cycle une première fois
  updateDayNightCycle();
  
  // Mettre à jour toutes les minutes
  setInterval(updateDayNightCycle, 60000);

  // Ajouter les écouteurs d'événements pour les boutons de rotation
  if (document.getElementById('rotate-left')) {
    document.getElementById('rotate-left').addEventListener('click', function() {
      roomRotationY -= 45;
      updateRoomRotation();
    });
  }
  
  if (document.getElementById('rotate-right')) {
    document.getElementById('rotate-right').addEventListener('click', function() {
      roomRotationY += 45;
      updateRoomRotation();
    });
  }
  
  if (document.getElementById('rotate-reset')) {
    document.getElementById('rotate-reset').addEventListener('click', function() {
      roomRotationX = 20;
      roomRotationY = 30;
      updateRoomRotation();
    });
  }
}
  // Ajouter un écouteur d'événement pour exécuter le code lorsque la page est chargée
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initDayNightCycle);
  } else {
    initDayNightCycle();
  }


// Fonctions de zoom pour les graphiques ambiants
function zoomAmbientTempChart(factor) {
    if (!ambientTempChart || !ambientTempChart.zoom) {
        console.warn("Fonction de zoom non disponible pour la température ambiante");
        return;
    }
    
    try {
        ambientTempChart.zoom(1 + factor);
    } catch (e) {
        console.warn("Erreur lors du zoom température ambiante:", e);
    }
}

function resetAmbientTempZoom() {
    if (!ambientTempChart || !ambientTempChart.resetZoom) {
        console.warn("Fonction de réinitialisation de zoom non disponible pour la température ambiante");
        return;
    }
    
    try {
        ambientTempChart.resetZoom();
    } catch (e) {
        console.warn("Erreur lors de la réinitialisation du zoom température ambiante:", e);
        setTimeout(renderAmbientTempChart, 100);
    }
}

function zoomAmbientHumidityChart(factor) {
    if (!ambientHumidityChart || !ambientHumidityChart.zoom) {
        console.warn("Fonction de zoom non disponible pour l'humidité ambiante");
        return;
    }
    
    try {
        ambientHumidityChart.zoom(1 + factor);
    } catch (e) {
        console.warn("Erreur lors du zoom humidité ambiante:", e);
    }
}

function resetAmbientHumidityZoom() {
    if (!ambientHumidityChart || !ambientHumidityChart.resetZoom) {
        console.warn("Fonction de réinitialisation de zoom non disponible pour l'humidité ambiante");
        return;
    }
    
    try {
        ambientHumidityChart.resetZoom();
    } catch (e) {
        console.warn("Erreur lors de la réinitialisation du zoom humidité ambiante:", e);
        setTimeout(renderAmbientHumidityChart, 100);
    }
}
 

function calculateRetenueStockAndRate(level) {
   try {
       // Formule simplifiée basée sur les caractéristiques du réservoir
       const minLevel = 177.25;
       const maxLevel = 200;
       const range = maxLevel - minLevel;
       
       // Calculer le stock (formule simplifiée)
       const normalizedLevel = (level - minLevel) / range;
       const stock = normalizedLevel * RETENUE_MAX_CAPACITY;
       
       // Calculer le taux de remplissage
       const rate = (stock / RETENUE_MAX_CAPACITY) * 100;
       
       return { 
           stock: parseFloat(stock.toFixed(2)), 
           rate: parseFloat(rate.toFixed(1))
       };
   } catch (error) {
       console.error("Erreur dans calculateRetenueStockAndRate:", error);
       return { stock: 0, rate: 0 };
   }
}

// Fonction pour basculer un filtre
function toggleFilter(filterName) {
    try {
        // Inverser l'état du filtre
        retenueFilters[filterName] = !retenueFilters[filterName];
        
        // Mettre à jour l'apparence du bouton
        const btn = document.getElementById(`filter-${filterName}`);
        if (btn) {
            const colorMap = {
                niveau: 'blue',
                stock: 'teal',
                taux: 'green',
                envasement: 'amber',
                evaporation: 'indigo',
                laches: 'red'
            };
            const color = colorMap[filterName] || 'gray';
            
            if (retenueFilters[filterName]) {
                // Activer le filtre
                btn.classList.remove('bg-gray-200', 'text-gray-600');
                btn.classList.add(`bg-${color}-100`, `text-${color}-700`);
                const span = btn.querySelector('span');
                if (span) {
                    span.classList.remove('bg-gray-400');
                    span.classList.add(`bg-${color}-600`);
                }
            } else {
                // Désactiver le filtre
                btn.classList.remove(`bg-${color}-100`, `text-${color}-700`);
                btn.classList.add('bg-gray-200', 'text-gray-600');
                const span = btn.querySelector('span');
                if (span) {
                    span.classList.remove(`bg-${color}-600`);
                    span.classList.add('bg-gray-400');
                }
            }
        }
        
        // Mettre à jour la visibilité des datasets dans le graphique
        if (retenueChart) {
            retenueChart.data.datasets.forEach(dataset => {
                if (dataset.label.includes('Niveau')) {
                    dataset.hidden = !retenueFilters.niveau;
                } else if (dataset.label.includes('Stock')) {
                    dataset.hidden = !retenueFilters.stock;
                } else if (dataset.label.includes('Taux')) {
                    dataset.hidden = !retenueFilters.taux;
                } else if (dataset.label.includes('Envasement')) {
                    dataset.hidden = !retenueFilters.envasement;
                } else if (dataset.label.includes('Évaporation')) {
                    dataset.hidden = !retenueFilters.evaporation;
                } else if (dataset.label.includes('Lâchés')) {
                    dataset.hidden = !retenueFilters.laches;
                }
            });
            
            retenueChart.update();
        }
    } catch (error) {
        console.error(`Erreur lors du basculement du filtre ${filterName}:`, error);
    }
}


// Fonction pour obtenir la couleur du filtre
function getFilterColor(filterName) {
    const colors = {
        niveau: 'blue',
        stock: 'teal',
        taux: 'green',
        envasement: 'amber',
        evaporation: 'indigo',
        laches: 'red'
    };
    return colors[filterName] || 'gray';
}

// Fonction pour activer/désactiver tous les filtres
function toggleAllFilters(state) {
    try {
        // Mettre à jour tous les filtres
        Object.keys(retenueFilters).forEach(key => {
            retenueFilters[key] = state;
            
            // Mettre à jour l'apparence du bouton
            const btn = document.getElementById(`filter-${key}`);
            if (btn) {
                const colorMap = {
                    niveau: 'blue',
                    stock: 'teal',
                    taux: 'green',
                    envasement: 'amber',
                    evaporation: 'indigo',
                    laches: 'red'
                };
                const color = colorMap[key] || 'gray';
                
                if (state) {
                    // Activer le filtre
                    btn.classList.remove('bg-gray-200', 'text-gray-600');
                    btn.classList.add(`bg-${color}-100`, `text-${color}-700`);
                    const span = btn.querySelector('span');
                    if (span) {
                        span.classList.remove('bg-gray-400');
                        span.classList.add(`bg-${color}-600`);
                    }
                } else {
                    // Désactiver le filtre
                    btn.classList.remove(`bg-${color}-100`, `text-${color}-700`);
                    btn.classList.add('bg-gray-200', 'text-gray-600');
                    const span = btn.querySelector('span');
                    if (span) {
                        span.classList.remove(`bg-${color}-600`);
                        span.classList.add('bg-gray-400');
                    }
                }
            }
        });
        
        // Mettre à jour la visibilité des datasets dans le graphique
        if (retenueChart) {
            retenueChart.data.datasets.forEach(dataset => {
                if (dataset.label.includes('Niveau')) {
                    dataset.hidden = !retenueFilters.niveau;
                } else if (dataset.label.includes('Stock')) {
                    dataset.hidden = !retenueFilters.stock;
                } else if (dataset.label.includes('Taux')) {
                    dataset.hidden = !retenueFilters.taux;
                } else if (dataset.label.includes('Envasement')) {
                    dataset.hidden = !retenueFilters.envasement;
                } else if (dataset.label.includes('Évaporation')) {
                    dataset.hidden = !retenueFilters.evaporation;
                } else if (dataset.label.includes('Lâchés')) {
                    dataset.hidden = !retenueFilters.laches;
                }
            });
            
            retenueChart.update();
        }
    } catch (error) {
        console.error(`Erreur lors du basculement de tous les filtres:`, error);
    }
}

// Fonction pour mettre à jour le graphique avec les filtres
function updateRetenueChartWithFilters() {

    try {
        if (!retenueChart) return;
        
        // Mise à jour de la visibilité des datasets
        retenueChart.data.datasets.forEach(dataset => {
            if (dataset.label.includes('Niveau')) {
                dataset.hidden = !retenueFilters.niveau;
            } else if (dataset.label.includes('Stock')) {
                dataset.hidden = !retenueFilters.stock;
            } else if (dataset.label.includes('Taux')) {
                dataset.hidden = !retenueFilters.taux;
            }
            // Ajouter d'autres conditions pour les autres datasets si nécessaire
        });
        
        retenueChart.update();
    } catch (error) {
        console.error("Erreur dans updateRetenueChartWithFilters:", error);
    }
}

// Fonction pour ajouter le lien dans le menu latéral
function addRetenueLink() {
   try {
       setTimeout(() => {
           const sideMenu = document.getElementById('side-menu');
           if (!sideMenu) {
               console.error("Menu latéral non trouvé");
               return;
           }
           
           const navList = sideMenu.querySelector('nav ul');
           if (!navList) {
               console.error("Liste de navigation non trouvée");
               return;
           }
           
           // Vérifier si le lien existe déjà
           if (document.querySelector('.nav-link[data-section="retenue-section"]')) {
               console.log("Le lien de retenue existe déjà");
               return;
           }
           
           // Créer le nouvel élément de menu
           const retenueLink = document.createElement('li');
           retenueLink.className = 'w-full';
           retenueLink.innerHTML = `
               <a href="#" class="nav-link group w-full cursor-pointer flex items-center justify-center p-4 md:justify-start md:py-3 md:px-4 rounded-lg transition-all duration-200 ease-in-out text-gray-600 relative overflow-hidden hover:bg-gray-100 hover:text-gray-800" data-section="retenue-section">
                   <div class="absolute left-0 top-0 h-full w-1 bg-transparent rounded-r-sm transition-all duration-200 ease-in-out"></div>
                   <div class="flex items-center justify-center w-9 h-9 rounded-lg mr-0 md:mr-3 bg-white shadow-sm transition-all duration-200 ease-in-out flex-shrink-0 text-teal-500 bg-teal-50"> 
                       <i class="fas fa-water"></i>
                   </div>
                   <span class="text-sm hidden md:inline whitespace-nowrap">Gestion Retenue</span>
               </a>
           `;
           
           // Ajouter l'élément au menu
           navList.appendChild(retenueLink);
           
           // Ajouter l'écouteur d'événement
           retenueLink.querySelector('a').addEventListener('click', (e) => {
               e.preventDefault();
               setActiveSection('retenue-section');
           });
           
           // Mettre à jour la référence dans elements.sections
           elements.sections['retenue-section'] = document.getElementById('retenue-section');
       }, 100);
   } catch (error) {
       console.error("Erreur dans addRetenueLink:", error);
   }
}

// Fonction pour configurer les contrôles de la section retenue
function setupRetenueControls() {
    try {
        // Variables pour le contrôle du panneau
        let clickCount = 0;
        let panelVisible = false;
        let calibrageMode = "standard";
        let simulationActive = false;
        let simulationInterval = null;
        
        // Gestion du clic sur la ligne noire
        const toggleLine = document.getElementById('retenue-toggle-line');
        if (toggleLine) {
            toggleLine.addEventListener('click', () => {
                clickCount++;
                if (clickCount >= 3) {
                    panelVisible = !panelVisible;
                    const panel = document.getElementById('retenue-sliding-panel');
                    if (panel) {
                        panel.style.transform = panelVisible ? 'translateY(0)' : 'translateY(100%)';
                    }
                    clickCount = 0;
                }
            });
        }
        
        // Bouton fermer le panneau
        const closeButton = document.getElementById('retenue-close-panel');
        if (closeButton) {
            closeButton.addEventListener('click', () => {
                panelVisible = false;
                const panel = document.getElementById('retenue-sliding-panel');
                if (panel) {
                    panel.style.transform = 'translateY(100%)';
                }
            });
        }
        
        // Bouton retour au trait noir
        const returnButton = document.getElementById('retenue-return-to-line');
        if (returnButton) {
            returnButton.addEventListener('click', () => {
                panelVisible = false;
                const panel = document.getElementById('retenue-sliding-panel');
                if (panel) {
                    panel.style.transform = 'translateY(100%)';
                }
                const levelSlider = document.getElementById('retenue-level-slider');
                if (levelSlider) {
                    levelSlider.value = '181.18';
                    updateRetenueBasedOnLevel(181.18, true); // Ajout de true pour émettre vers le serveur
                }
            });
        }
        
        // Bouton calibrage
        const calibrageButton = document.getElementById('retenue-calibrage-button');
        const yAxisLabels = document.getElementById('retenue-axis-labels');
        
        if (calibrageButton && yAxisLabels) {
            // S'assurer que le bouton est visible
            calibrageButton.style.display = 'flex';
            
            calibrageButton.addEventListener('click', () => {
                calibrageMode = calibrageMode === "standard" ? "precis" : "standard";
                
                // Mettre à jour les graduations
                const marks = calibrageMode === "standard" 
                    ? [200, 190, 180]
                    : Array.from({ length: 11 }, (_, i) => 200 - i * 2);
                
                yAxisLabels.innerHTML = marks.map(mark => `<span>${mark} m</span>`).join('');
                
                // Mise à jour visuelle du bouton
                calibrageButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                    </svg>
                    ${calibrageMode === "standard" ? "Mode précis" : "Mode standard"}
                `;
                
                // Ajouter une notification pour informer l'utilisateur
                const notification = document.createElement('div');
                notification.textContent = `Mode ${calibrageMode} activé`;
                notification.style.position = 'fixed';
                notification.style.bottom = '20px';
                notification.style.right = '20px';
                notification.style.padding = '10px 15px';
                notification.style.background = '#10b981';
                notification.style.color = 'white';
                notification.style.borderRadius = '4px';
                notification.style.zIndex = '100';
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => document.body.removeChild(notification), 500);
                }, 2000);
            });
        }
        
        // Gestion du curseur de niveau
        const levelSlider = document.getElementById('retenue-level-slider');
        const sliderValue = document.getElementById('retenue-slider-value');
        
        if (levelSlider && sliderValue) {
            // S'assurer que le curseur est visible
            levelSlider.style.width = '100%';
            levelSlider.style.appearance = 'none';
            levelSlider.style.height = '10px';
            levelSlider.style.borderRadius = '5px';
            levelSlider.style.background = 'linear-gradient(to right, #3b82f6, #10b981)';
            
            levelSlider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                sliderValue.textContent = value.toFixed(2);
                updateRetenueBasedOnLevel(value, true);
            });
        }
        
        // Bouton simulation
        const simulationButton = document.getElementById('retenue-simulation-button');
        if (simulationButton) {
            simulationButton.addEventListener('click', () => {
                simulationActive = !simulationActive;
                
                if (simulationActive) {
                    simulationButton.className = "button flex w-full items-center justify-center gap-2 rounded-md px-4 py-2 text-white bg-red-600 hover:bg-red-700";
                    simulationButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                        Arrêter la simulation
                    `;
                    
                    // Démarrer la simulation
                    simulationInterval = setInterval(() => {
                        const currentLevel = parseFloat(levelSlider.value);
                        const newLevel = 177.25 + Math.random() * (200 - 177.25);
                        levelSlider.value = newLevel.toFixed(2);
                        sliderValue.textContent = newLevel.toFixed(2);
                        updateRetenueBasedOnLevel(newLevel, true); // Ajout de true pour émettre vers le serveur
                    }, 4000);
                } else {
                    // Arrêter la simulation
                    if (simulationInterval) {
                        clearInterval(simulationInterval);
                        simulationInterval = null;
                    }
                    
                    simulationButton.className = "button flex w-full items-center justify-center gap-2 rounded-md px-4 py-2 text-white bg-blue-600 hover:bg-blue-700";
                    simulationButton.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                        </svg>
                        Démarrer la simulation
                    `;
                }
            });
        }
    } catch (error) {
        console.error("Erreur dans setupRetenueControls:", error);
    }
}


function renderRetenueChart() {
    const container = document.getElementById('retenue-evolution-chart');
    if (!container) {
        console.error("Conteneur du graphique d'évolution non trouvé");
        return;
    }
    
    // Nettoyer le conteneur
    container.innerHTML = '';
    
    // Créer un canvas pour Chart.js
    const canvas = document.createElement('canvas');
    canvas.id = 'retenueChartCanvas';
    container.appendChild(canvas);
    
    const ctx = canvas.getContext('2d');
    
    // Obtenir les données pour le graphique (y compris envasement, évaporation et lâchés)
    const labels = retenueChartData.map(item => item.date);
    const niveauData = retenueChartData.map(item => item.niveau);
    const stockData = retenueChartData.map(item => item.stock);
    const tauxData = retenueChartData.map(item => item.taux);
    
    // Générer des données cohérentes pour les autres métriques si elles n'existent pas
    const envasementData = retenueChartData.map(item => {
        // Si item.envasement existe, l'utiliser, sinon calculer une valeur
        return item.envasement || (item.taux * 0.95).toFixed(1);
    });
    
    const evaporationData = retenueChartData.map(item => {
        // Si item.evaporation existe, l'utiliser, sinon calculer une valeur
        return item.evaporation || (item.taux * 0.05).toFixed(1);
    });
    
    const lachesData = retenueChartData.map(item => {
        // Si item.laches existe, l'utiliser, sinon calculer une valeur
        return item.laches || (item.stock * 0.03).toFixed(2);
    });
    
    // Configuration des couleurs
    const colors = {
        niveau: {
            line: '#3b82f6',
            background: 'rgba(59, 130, 246, 0.1)'
        },
        stock: {
            line: '#10b981',
            background: 'rgba(16, 185, 129, 0.1)'
        },
        taux: {
            line: '#22c55e',
            background: 'rgba(34, 197, 94, 0.1)'
        },
        envasement: {
            line: '#f59e0b',
            background: 'rgba(245, 158, 11, 0.1)'
        },
        evaporation: {
            line: '#6366f1',
            background: 'rgba(99, 102, 241, 0.1)'
        },
        laches: {
            line: '#ef4444',
            background: 'rgba(239, 68, 68, 0.1)'
        }
    };
    
    // Création du graphique avec Chart.js
    if (retenueChart) retenueChart.destroy();
    
    retenueChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Niveau (m)',
                    data: niveauData,
                    borderColor: colors.niveau.line,
                    backgroundColor: colors.niveau.background,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: colors.niveau.line,
                    pointBorderColor: 'white',
                    tension: 0.2,
                    hidden: !retenueFilters.niveau,
                    yAxisID: 'y'
                },
                {
                    label: 'Stock (Mm³)',
                    data: stockData,
                    borderColor: colors.stock.line,
                    backgroundColor: colors.stock.background,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: colors.stock.line,
                    pointBorderColor: 'white',
                    tension: 0.2,
                    hidden: !retenueFilters.stock,
                    yAxisID: 'y1'
                },
                {
                    label: 'Taux de remplissage (%)',
                    data: tauxData,
                    borderColor: colors.taux.line,
                    backgroundColor: colors.taux.background,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: colors.taux.line,
                    pointBorderColor: 'white',
                    tension: 0.2,
                    hidden: !retenueFilters.taux,
                    yAxisID: 'y2'
                },
                {
                    label: 'Envasement (%)',
                    data: envasementData,
                    borderColor: colors.envasement.line,
                    backgroundColor: colors.envasement.background,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: colors.envasement.line,
                    pointBorderColor: 'white',
                    tension: 0.2,
                    hidden: !retenueFilters.envasement,
                    yAxisID: 'y2'
                },
                {
                    label: 'Évaporation (%)',
                    data: evaporationData,
                    borderColor: colors.evaporation.line,
                    backgroundColor: colors.evaporation.background,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: colors.evaporation.line,
                    pointBorderColor: 'white',
                    tension: 0.2,
                    hidden: !retenueFilters.evaporation,
                    yAxisID: 'y2'
                },
                {
                    label: 'Lâchés d\'eau (Mm³)',
                    data: lachesData,
                    borderColor: colors.laches.line,
                    backgroundColor: colors.laches.background,
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: colors.laches.line,
                    pointBorderColor: 'white',
                    tension: 0.2,
                    hidden: !retenueFilters.laches,
                    yAxisID: 'y1'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        boxWidth: 10,
                        font: {
                            size: 12
                        }
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(255, 255, 255, 0.9)',
                    titleColor: '#1f2937',
                    bodyColor: '#1f2937',
                    borderColor: '#e5e7eb',
                    borderWidth: 1,
                    padding: 12,
                    cornerRadius: 8,
                    titleFont: {
                        size: 14,
                        weight: 'bold'
                    },
                    bodyFont: {
                        size: 13
                    },
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(2);
                                
                                // Ajouter les unités en fonction du type de donnée
                                if (context.dataset.label.includes('Niveau')) {
                                    label += ' m';
                                } else if (context.dataset.label.includes('Stock') || context.dataset.label.includes('Lâchés')) {
                                    label += ' Mm³';
                                } else {
                                    label += ' %';
                                }
                            }
                            return label;
                        }
                    }
                },
                zoom: {
                    zoom: {
                        wheel: {
                            enabled: true,
                        },
                        pinch: {
                            enabled: true
                        },
                        mode: 'xy'
                    },
                    pan: {
                        enabled: true,
                        mode: 'xy'
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Date',
                        font: {
                            size: 14,
                            weight: 'bold'
                        }
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.05)'
                    }
                },
                y: {
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: {
                        display: true,
                        text: 'Niveau (m)',
                        font: {
                            size: 14,
                            weight: 'bold'
                        },
                        color: colors.niveau.line
                    },
                    grid: {
                        display: true,
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(1) + ' m';
                        }
                    }
                },
                y1: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'Volume (Mm³)',
                        font: {
                            size: 14,
                            weight: 'bold'
                        },
                        color: colors.stock.line
                    },
                    grid: {
                        display: false
                    },
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(1) + ' Mm³';
                        }
                    }
                },
                y2: {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: 'Pourcentage (%)',
                        font: {
                            size: 14,
                            weight: 'bold'
                        },
                        color: colors.taux.line
                    },
                    grid: {
                        display: false
                    },
                    ticks: {
                        callback: function(value) {
                            return value.toFixed(1) + '%';
                        }
                    }
                }
            }
        }
    });
    addZoomControls();
}

function updateRetenue3DVisualisation() {
    try {
        const water = document.getElementById('retenue-water');
        const levelMarker = document.getElementById('retenue-level-marker');
        const markerValue = document.getElementById('retenue-marker-value');
        
        if (!water || !levelMarker || !markerValue) return;
        
        // Récupérer le niveau actuel
        const levelInput = document.getElementById('retenue-level-input');
        if (!levelInput) return;
        
        const level = parseFloat(levelInput.value);
        const { stock, rate } = calculateRetenueStockAndRate(level);
        
        // Calculer la hauteur du niveau d'eau visuel
        const minLevel = 177.25;
        const maxLevel = 200;
        const levelRange = maxLevel - minLevel;
        const waterLevelHeight = ((level - minLevel) / levelRange) * 100;
        
        // Mettre à jour les éléments avec animation
        water.style.height = `${waterLevelHeight}%`;
        levelMarker.style.bottom = `${waterLevelHeight}%`;
        markerValue.textContent = level.toFixed(2);
        
        // Mettre à jour les affichages
        const currentLevel = document.getElementById('retenue-current-level');
        const calculatedStock = document.getElementById('retenue-calculated-stock');
        const fillRate = document.getElementById('retenue-fill-rate');
        
        if (currentLevel) currentLevel.textContent = `${level.toFixed(2)} m`;
        if (calculatedStock) calculatedStock.textContent = `${stock.toFixed(2)} million m³`;
        if (fillRate) fillRate.textContent = `${rate.toFixed(1)} %`;
    } catch (error) {
        console.error("Erreur dans updateRetenue3DVisualisation:", error);
    }
}

function updateRetenueCircularGauges(stock, rate) {
    // Mise à jour de la jauge de taux de remplissage
    const fillRateCircle = document.querySelector('#retenue-section .grid-cols-3:nth-child(2) svg circle:nth-child(2)');
    if (fillRateCircle) {
        const circumference = 283;
        const offset = circumference * (1 - rate / 100);
        fillRateCircle.style.strokeDashoffset = offset;
    }
    
    // Mise à jour de la jauge de stock d'eau
    const stockCircle = document.querySelector('#retenue-section .grid-cols-3:nth-child(2) svg circle:nth-child(2)');
    if (stockCircle) {
        const circumference = 283;
        const stockPercent = (stock / RETENUE_MAX_CAPACITY) * 100;
        const offset = circumference * (1 - stockPercent / 100);
        stockCircle.style.strokeDashoffset = offset;
    }
}

function addWaterRipples() {
    try {
        const water = document.getElementById('retenue-water');
        if (!water) return;
        
        // Enlever les anciennes ondulations
        const oldRipples = water.querySelectorAll('.water-ripple');
        oldRipples.forEach(ripple => ripple.remove());
        
        // Créer de nouvelles ondulations
        for (let i = 0; i < 3; i++) {
            const ripple = document.createElement('div');
            ripple.className = 'water-ripple';
            ripple.style.cssText = `
                position: absolute;
                top: -5px;
                left: ${20 + Math.random() * 60}%;
                width: ${40 + Math.random() * 40}px;
                height: ${20 + Math.random() * 20}px;
                background: radial-gradient(circle at center, rgba(255,255,255,0.5) 0%, rgba(255,255,255,0) 70%);
                border-radius: 50%;
                transform: scale(0);
                animation: ripple-effect 4s ease-out ${i * 1.5}s infinite;
                opacity: 0.6;
            `;
            water.appendChild(ripple);
        }
    } catch (error) {
        console.error("Erreur dans addWaterRipples:", error);
    }
}

// Fonction pour mettre à jour les données de la retenue en fonction du niveau
function updateRetenueBasedOnLevel(level, shouldEmit = true) {
    try {
        // Vérifier si le niveau a vraiment changé (optimisation)
        const lastLevel = parseFloat(localStorage.getItem('lastRetenueLevel') || 0);
        if (Math.abs(lastLevel - level) < 0.01) return; // Seuil de 1cm
        
        // Calculer le pourcentage du niveau
        const minLevel = 177.25;
        const maxLevel = 200;
        const percentage = ((level - minLevel) / (maxLevel - minLevel)) * 100;
        
        // Mettre à jour le niveau d'eau
        const waterElement = document.getElementById('retenue-water');
        if (waterElement) {
            waterElement.style.height = `${percentage}%`;
        }
        
        // Mettre à jour le marqueur (TRAIT ROUGE) - S'assurer qu'il est visible
        const levelMarker = document.getElementById('retenue-level-marker');
        if (levelMarker) {
            levelMarker.style.bottom = `${percentage}%`;
            levelMarker.style.display = 'flex'; // S'assurer qu'il est visible
            levelMarker.style.zIndex = '10'; // S'assurer qu'il est au-dessus des autres éléments
            
            // Renforcer la visibilité du trait rouge
            const markerLine = levelMarker.querySelector('div');
            if (markerLine) {
                markerLine.style.height = '2px';
                markerLine.style.backgroundColor = '#ef4444';
                markerLine.style.width = '32px';
            }
        }
        
        // Mettre à jour la valeur affichée
        const markerValue = document.getElementById('retenue-marker-value');
        if (markerValue) {
            markerValue.textContent = level.toFixed(2);
        }
        
        // Calculer et mettre à jour le stock
        const stock = ((level - 177.25) / 0.1367).toFixed(2);
        const fillRate = ((stock / 42.11) * 100).toFixed(1);
        
        // Mettre à jour les affichages dans les cartes
        const currentStock = document.getElementById('current-stock');
        const currentFillRate = document.getElementById('current-fill-rate');
        
        if (currentStock) currentStock.textContent = stock;
        if (currentFillRate) currentFillRate.textContent = fillRate;
        
        // Sauvegarder dans localStorage
        const retenueState = {
            level: parseFloat(level),
            stock: parseFloat(stock),
            fillRate: parseFloat(fillRate),
            siltation: 64.9,
            evaporation: 3.4,
            release: 0.86,
            timestamp: Date.now()
        };
        
        localStorage.setItem('lastRetenueState', JSON.stringify(retenueState));
        localStorage.setItem('lastRetenueLevel', level.toString());
        
        // Envoyer les données au serveur seulement si shouldEmit est true
        if (shouldEmit && socket && socket.connected) {
            // Ajouter un identifiant client unique pour éviter les boucles
            const clientId = localStorage.getItem('clientId') || Math.random().toString(36).substr(2, 9);
            localStorage.setItem('clientId', clientId);
            
            socket.emit('retenueChange', {
                ...retenueState,
                clientId // Permet au serveur d'ignorer les mises à jour du même client
            });
        }
        
    } catch (error) {
        console.error("Erreur dans updateRetenueBasedOnLevel:", error);
    }
}

function renderRetenueVisualization() {
    // Chercher spécifiquement le conteneur de la visualisation 3D existante
    const visualizationContainer = document.querySelector('#retenue-section .w-full');
    if (!visualizationContainer) {
        console.error("Conteneur de visualisation non trouvé");
        return;
    }
    
    // Trouver uniquement la partie qui contient l'animation 3D
    const existingVisualization = visualizationContainer.querySelector('#retenue-visualization');
    
    if (existingVisualization) {
        // Si la visualisation existe déjà, mettre à jour seulement son parent direct
        const parent = existingVisualization.parentElement;
        parent.innerHTML = `
            <!-- Bloc d'animation 3D -->
            <div class="relative rounded-xl border-4 border-gray-300 bg-white shadow-lg"
                 id="retenue-visualization" 
                 style="height: 400px; transform: perspective(600px) rotateX(15deg); transform-style: preserve-3d;">
                <!-- Bordure intérieure -->
                <div class="absolute inset-0 rounded-lg border-2 border-gray-200"></div>
                
                <!-- Niveau d'eau avec animation -->
                <div id="retenue-water" 
                     class="absolute bottom-0 left-0 right-0 overflow-hidden rounded-b-lg"
                     style="height: 68.3%; transition: height 1s ease-in-out;">
                    <div class="wave wave-back bg-blue-400/70" style="animation: waveSlide 10s linear infinite;"></div>
                    <div class="wave wave-front bg-blue-500/90" style="animation: waveSlide 6s linear infinite; mix-blend-mode: multiply;"></div>
                </div>
                
                <!-- Marqueur de niveau - TRAIT ROUGE AMÉLIORÉ -->
                <div id="retenue-level-marker"
                     class="absolute left-4 flex items-center z-10"
                     style="bottom: 68.3%; transition: bottom 0.8s ease-in-out; display: flex !important;">
                    <div class="h-1 w-8 bg-red-600" style="height: 3px !important;"></div>
                    <span class="ml-2 rounded bg-red-100 px-2 py-1 text-xs font-semibold text-red-600">
                        <span id="retenue-marker-value">181.18</span> m
                    </span>
                </div>
                
                <!-- Échelle sur le côté -->
                <div id="retenue-axis-labels" class="pointer-events-none absolute inset-y-0 left-3 flex flex-col justify-between py-4 text-xs text-gray-600">
                    <span>200 m</span>
                    <span>190 m</span>
                    <span>180 m</span>
                </div>
            </div>
            
        
        `;
    }
    
    // Ajouter les styles d'animation
    addWaveAnimation();
}

function addWaveAnimation() {
    const styleId = 'wave-animation-styles';
    
    if (!document.getElementById(styleId)) {
        const style = document.createElement('style');
        style.id = styleId;
        style.textContent = `
            @keyframes waveSlide {
                0% {
                    transform: translateX(0);
                }
                100% {
                    transform: translateX(-50%);
                }
            }
            
            .wave {
                position: absolute;
                bottom: 0;
                left: 0;
                width: 200%;
                height: 100%;
                background-repeat: repeat-x;
            }
            
            .wave-back {
                background: linear-gradient(90deg, #60a5fa70 0%, #3b82f670 50%, #60a5fa70 100%);
                filter: blur(2px);
            }
            
            .wave-front {
                background: linear-gradient(90deg, #3b82f6e6 0%, #2563ebe6 50%, #3b82f6e6 100%);
            }
        `;
        document.head.appendChild(style);
    }
}


// Appeler cette fonction lors de l'initialisation


// Fonction pour mettre à jour tous les éléments visuels
function updateRetenueVisuals(level, stock, rate) {
    try {
        // Mise à jour des affichages de texte avec vérification
        const elements = {
            level: document.getElementById('retenue-current-level'),
            stock: document.getElementById('retenue-calculated-stock'),
            rate: document.getElementById('retenue-fill-rate'),
            currentStock: document.getElementById('current-stock'),
            currentRate: document.getElementById('current-fill-rate'),
            levelValue: document.getElementById('retenue-level-value'),
            capacityDisplay: document.getElementById('retenue-capacity-display'),
            fillRateText: document.getElementById('retenue-fill-rate-text'),
            stockText: document.getElementById('retenue-stock-text')
        };
        
        // Mettre à jour les éléments qui existent
        if (elements.level) elements.level.textContent = `${level.toFixed(2)} m`;
        if (elements.stock) elements.stock.textContent = `${stock.toFixed(2)} million m³`;
        if (elements.rate) elements.rate.textContent = `${rate.toFixed(1)} %`;
        if (elements.currentStock) elements.currentStock.textContent = stock.toFixed(2);
        if (elements.currentRate) elements.currentRate.textContent = rate.toFixed(1);
        if (elements.levelValue) elements.levelValue.textContent = `${level.toFixed(2)}m`;
        if (elements.capacityDisplay) elements.capacityDisplay.textContent = rate.toFixed(1);
        if (elements.fillRateText) elements.fillRateText.textContent = `${rate.toFixed(1)}%`;
        if (elements.stockText) elements.stockText.textContent = stock.toFixed(2);
        
        // Mise à jour de l'entrée de niveau
        const levelInput = document.getElementById('retenue-level-input');
        if (levelInput) levelInput.value = level.toFixed(2);
        
        // Mise à jour des graphiques circulaires
        const fillCircle = document.getElementById('retenue-fill-rate-circle');
        const stockCircle = document.getElementById('retenue-stock-circle');
        
        // Calcul des décalages pour les cercles (strokeDashoffset)
        const fillRateOffset = 283 * (1 - rate / 100);
        const stockOffset = 283 * (1 - (stock / RETENUE_MAX_CAPACITY * 100) / 100);
        
        if (fillCircle) fillCircle.setAttribute('stroke-dashoffset', fillRateOffset);
        if (stockCircle) stockCircle.setAttribute('stroke-dashoffset', stockOffset);
        
        // Mise à jour du niveau d'eau
        const waterLevel = document.getElementById('retenue-water-level');
        if (waterLevel) waterLevel.style.height = `${rate}%`;
        
        // Mise à jour de la visualisation 3D
        const water3D = document.getElementById('retenue-water');
        if (water3D) water3D.style.height = `${rate}%`;
        
        // Mise à jour du marqueur de niveau
        const levelMarker = document.getElementById('retenue-level-marker');
        if (levelMarker) levelMarker.style.bottom = `${rate}%`;
        
        const currentLevelMarker = document.getElementById('retenue-current-level-marker');
        if (currentLevelMarker) currentLevelMarker.style.bottom = `${rate}%`;
    } catch (error) {
        console.error("Erreur dans updateRetenueVisuals:", error);
    }
}

// Fonction pour mettre à jour le tableau de données
function updateRetenueTable() {
    try {
        const tableBody = document.getElementById('retenue-data-table');
        if (!tableBody) return;
        
        tableBody.innerHTML = '';
        
        retenueTableData.forEach(row => {
            const tr = document.createElement('tr');
            tr.className = 'hover:bg-teal-50';
            tr.innerHTML = `
                <td class="p-3 border-b border-teal-100">${row.date}</td>
                <td class="p-3 text-center border-b border-teal-100">${row.level.toFixed(2)}</td>
                <td class="p-3 text-center border-b border-teal-100">${row.stock.toFixed(2)}</td>
                <td class="p-3 text-center border-b border-teal-100">${row.rate.toFixed(1)}</td>
                <td class="p-3 text-center border-b border-teal-100">${row.silt.toFixed(1)}</td>
                <td class="p-3 text-center border-b border-teal-100">${row.evap.toFixed(1)}</td>
                <td class="p-3 text-center border-b border-teal-100">${row.release.toFixed(2)}</td>
            `;
            tableBody.appendChild(tr);
        });
    } catch (error) {
        console.error("Erreur dans updateRetenueTable:", error);
    }
}

// Fonction pour ajouter des ondulations à l'eau

// Fonction pour mettre à jour la rotation 3D
function updateRetenue3DRotation() {
    try {
        const container = document.getElementById('retenue-visualization');
        if (!container) return;
        
        container.style.transform = `perspective(1000px) rotateY(${retenueRotationAngle}deg)`;
        container.style.transition = 'transform 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
        container.style.transformStyle = 'preserve-3d';
        container.style.backfaceVisibility = 'hidden';
    } catch (error) {
        console.error("Erreur dans updateRetenue3DRotation:", error);
    }
}

// Fonction pour mettre à jour la tendance
function updateRetenueTrend() {
    try {
        const trendIcon = document.querySelector('#retenue-trend-indicator svg');
        const trendText = document.getElementById('retenue-trend-text');
        const trendValue = document.getElementById('retenue-trend-value');
        
        if (!trendIcon || !trendText || !trendValue || retenueChartData.length < 2) return;
        
        const currentLevel = retenueChartData[retenueChartData.length - 1].niveau;
        const previousLevel = retenueChartData[retenueChartData.length - 2].niveau;
        const diff = (currentLevel - previousLevel).toFixed(2);
        
        // Configuration des différents cas
        const config = {
            up: {
                icon: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />',
                color: 'text-green-600',
                bgColor: 'bg-green-100',
                text: 'En hausse'
            },
            down: {
                icon: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />',
                color: 'text-red-600',
                bgColor: 'bg-red-100',
                text: 'En baisse'
            },
            stable: {
                icon: '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14" />',
                color: 'text-yellow-600',
                bgColor: 'bg-yellow-100',
                text: 'Stable'
            }
        };
        
        let trend;
        if (diff > 0.1) {
            trend = config.up;
        } else if (diff < -0.1) {
            trend = config.down;
        } else {
            trend = config.stable;
        }
        
        // Mise à jour de l'icône
        trendIcon.innerHTML = trend.icon;
        trendIcon.className = `h-8 w-8 ${trend.color}`;
        
        // Mise à jour du texte
        trendText.textContent = trend.text;
        trendText.className = `text-sm font-medium ${trend.color}`;
        
        // Mise à jour de la valeur
        trendValue.textContent = `${diff > 0 ? '+' : ''}${diff} m`;
        trendValue.className = `text-xs ${trend.color}`;
        
        // Mise à jour du fond de la carte
        const trendCard = document.getElementById('retenue-trend-indicator');
        if (trendCard) {
            trendCard.className = `rounded-lg p-4 flex flex-col items-center ${trend.bgColor}`;
        }
        
    } catch (error) {
        console.error("Erreur dans updateRetenueTrend:", error);
    }
}

function updateRetenueIndicators(level, stock, rate) {
    try {
        // 1. Mise à jour de la jauge de taux de remplissage
        const fillRateCircle = document.querySelector('#retenue-fill-rate-circle');
        const fillRateValue = document.getElementById('retenue-fill-rate-value');
        
        if (fillRateCircle && fillRateValue) {
            const circumference = 283;
            const offset = circumference * (1 - rate / 100);
            fillRateCircle.style.strokeDashoffset = offset;
            fillRateValue.textContent = `${rate.toFixed(1)}%`;
            
            // Changement de couleur en fonction du taux
            if (rate > 80) {
                fillRateCircle.style.stroke = '#10B981'; // Vert
            } else if (rate > 50) {
                fillRateCircle.style.stroke = '#3B82F6'; // Bleu
            } else {
                fillRateCircle.style.stroke = '#EF4444'; // Rouge
            }
        }
        
        // 2. Mise à jour de la jauge de stock d'eau
        const stockCircle = document.querySelector('#retenue-stock-circle');
        const stockValue = document.getElementById('retenue-stock-value');
        
        if (stockCircle && stockValue) {
            const circumference = 283;
            const stockPercent = (stock / RETENUE_MAX_CAPACITY) * 100;
            const offset = circumference * (1 - stockPercent / 100);
            stockCircle.style.strokeDashoffset = offset;
            stockValue.textContent = stock.toFixed(2);
            
            // Changement de couleur en fonction du stock
            if (stock > RETENUE_MAX_CAPACITY * 0.8) {
                stockCircle.style.stroke = '#10B981'; // Vert
            } else if (stock > RETENUE_MAX_CAPACITY * 0.5) {
                stockCircle.style.stroke = '#3B82F6'; // Bleu
            } else {
                stockCircle.style.stroke = '#EF4444'; // Rouge
            }
        }
        
        // 3. Mise à jour de la tendance (intégration de l'ancienne updateRetenueTrend)
        updateTrendIndicator(level);
        
    } catch (error) {
        console.error("Erreur dans updateRetenueIndicators:", error);
    }
}

// Fonction pour observer les changements dans les indicateurs et mettre à jour l'interface
function setupDynamicUpdates() {
    // Observer les changements dans les cartes principales
    const cardsToObserve = [
        { id: 'current-stock', property: 'stock' },
        { id: 'current-fill-rate', property: 'taux' },
        { id: 'current-siltation', property: 'envasement' },
        { id: 'current-evaporation', property: 'evaporation' },
        { id: 'current-release', property: 'laches' }
    ];
    
    cardsToObserve.forEach(cardInfo => {
        const element = document.getElementById(cardInfo.id);
        if (element) {
            const observer = new MutationObserver(() => {
                console.log(`Changement détecté dans ${cardInfo.id}`);
                updateGraphAndIndicators();
            });
            
            observer.observe(element, { 
                childList: true, 
                characterData: true, 
                subtree: true 
            });
        }
    });
    
    // Mettre à jour les jauges et graphiques immédiatement
    updateGraphAndIndicators();
}

// Fonction centrale pour mettre à jour tous les éléments visuels
function updateGraphAndIndicators() {
    // Collecter les données actuelles
    const currentData = collectCurrentData();
    
    // Mettre à jour le graphique avec les nouvelles données
    updateGraphData(currentData);
    
    // Mettre à jour les jauges circulaires
    updateGauges(currentData);
    
    // Mettre à jour l'indicateur de tendance
    updateTrendIndicator(currentData);
}

// Fonction pour collecter toutes les données actuelles des indicateurs
function collectCurrentData() {
    const data = {
        stock: 0,
        taux: 0,
        envasement: 0,
        evaporation: 0,
        laches: 0,
        niveau: 0,
        previousNiveau: 0
    };
    
    // Obtenir les valeurs depuis les éléments DOM
    const stockElement = document.getElementById('current-stock');
    const tauxElement = document.getElementById('current-fill-rate');
    const envasementElement = document.getElementById('current-siltation');
    const evaporationElement = document.getElementById('current-evaporation');
    const lachesElement = document.getElementById('current-release');
    const niveauElement = document.getElementById('retenue-marker-value');
    
    // Extraire les valeurs numériques
    if (stockElement) data.stock = parseFloat(stockElement.textContent);
    if (tauxElement) data.taux = parseFloat(tauxElement.textContent);
    if (envasementElement) data.envasement = parseFloat(envasementElement.textContent);
    if (evaporationElement) data.evaporation = parseFloat(evaporationElement.textContent);
    if (lachesElement) data.laches = parseFloat(lachesElement.textContent);
    if (niveauElement) data.niveau = parseFloat(niveauElement.textContent);
    
    // Obtenir la valeur précédente du niveau depuis les données historiques
    if (retenueChartData && retenueChartData.length > 1) {
        data.previousNiveau = retenueChartData[retenueChartData.length - 2].niveau;
    } else {
        data.previousNiveau = data.niveau; // Pas de changement si pas d'historique
    }
    
    return data;
}

// Mettre à jour le graphique avec les nouvelles données
function updateGraphData(currentData) {
    // Obtenir la date actuelle au format DD/MM
    const now = new Date();
    const dateStr = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}`;
    
    // Créer un nouveau point de données
    const newDataPoint = {
        date: dateStr,
        niveau: currentData.niveau,
        stock: currentData.stock,
        taux: currentData.taux,
        envasement: currentData.envasement,
        evaporation: currentData.evaporation,
        laches: currentData.laches
    };
    
    // Mettre à jour la dernière entrée si elle a la même date, sinon ajouter une nouvelle
    if (retenueChartData.length > 0 && retenueChartData[retenueChartData.length - 1].date === dateStr) {
        retenueChartData[retenueChartData.length - 1] = newDataPoint;
    } else {
        // Limiter à 30 points de données pour éviter une surcharge
        if (retenueChartData.length >= 30) {
            retenueChartData.shift(); // Supprimer le plus ancien
        }
        retenueChartData.push(newDataPoint);
    }
    
    // Mettre à jour le graphique
    renderRetenueChart();
}

// Mettre à jour les jauges circulaires
function updateGauges(data) {
    // Mettre à jour la jauge de taux de remplissage
    const fillRateGauge = document.getElementById('retenue-fill-gauge');
    const fillRateDisplay = document.getElementById('retenue-fill-rate-display');
    
    if (fillRateGauge && fillRateDisplay) {
        // Calculer l'offset pour la jauge circulaire (0-100%)
        const circumference = 283; // 2 * PI * rayon (45)
        const fillOffset = circumference * (1 - data.taux / 100);
        
        // Mettre à jour la jauge avec animation
        fillRateGauge.style.transition = 'stroke-dashoffset 0.8s ease-in-out';
        fillRateGauge.setAttribute('stroke-dashoffset', fillOffset);
        
        // Mettre à jour le texte
        fillRateDisplay.textContent = data.taux.toFixed(1) + '%';
        
        // Changer la couleur en fonction du taux
        if (data.taux < 30) {
            fillRateGauge.setAttribute('stroke', '#ef4444'); // Rouge pour niveau bas
            fillRateDisplay.style.color = '#ef4444';
        } else if (data.taux < 70) {
            fillRateGauge.setAttribute('stroke', '#3b82f6'); // Bleu pour niveau normal
            fillRateDisplay.style.color = '#3b82f6';
        } else {
            fillRateGauge.setAttribute('stroke', '#10b981'); // Vert pour niveau élevé
            fillRateDisplay.style.color = '#10b981';
        }
    }
    
    // Mettre à jour la jauge de stock d'eau
    const stockGauge = document.getElementById('retenue-stock-gauge');
    const stockDisplay = document.getElementById('retenue-stock-display');
    
    if (stockGauge && stockDisplay) {
        // Calculer le pourcentage par rapport à la capacité maximale (42.11 Mm³)
        const maxCapacity = 42.11;
        const stockPercent = (data.stock / maxCapacity) * 100;
        
        // Calculer l'offset
        const circumference = 283;
        const stockOffset = circumference * (1 - stockPercent / 100);
        
        // Mettre à jour la jauge avec animation
        stockGauge.style.transition = 'stroke-dashoffset 0.8s ease-in-out';
        stockGauge.setAttribute('stroke-dashoffset', stockOffset);
        
        // Mettre à jour le texte
        stockDisplay.textContent = data.stock.toFixed(2);
        
        // Changer la couleur en fonction du stock
        if (stockPercent < 30) {
            stockGauge.setAttribute('stroke', '#ef4444'); // Rouge pour niveau bas
            stockDisplay.style.color = '#ef4444';
        } else if (stockPercent < 70) {
            stockGauge.setAttribute('stroke', '#10b981'); // Vert pour niveau normal
            stockDisplay.style.color = '#10b981';
        } else {
            stockGauge.setAttribute('stroke', '#3b82f6'); // Bleu pour niveau élevé
            stockDisplay.style.color = '#3b82f6';
        }
    }
}

// Mettre à jour l'indicateur de tendance
function updateTrendIndicator(data) {
    const trendIcon = document.getElementById('retenue-trend-icon');
    const trendText = document.getElementById('retenue-trend-text');
    const trendValue = document.getElementById('retenue-trend-value');
    
    if (trendIcon && trendText && trendValue) {
        // Calculer la différence de niveau
        const diff = data.niveau - data.previousNiveau;
        const absDiff = Math.abs(diff).toFixed(2);
        
        // Mettre à jour l'affichage de la valeur
        trendValue.textContent = (diff >= 0 ? "+" : "") + diff.toFixed(2) + " m";
        
        // Mettre à jour l'icône et le texte selon la tendance
        if (diff > 0.05) {
            // Tendance à la hausse
            trendIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" />';
            trendIcon.className = 'h-16 w-16 text-green-600';
            trendIcon.style.transform = 'translateY(-2px)';
            trendText.textContent = 'En hausse';
            trendText.className = 'text-sm font-medium text-green-600';
            trendValue.className = 'text-sm font-bold text-green-600';
        } else if (diff < -0.05) {
            // Tendance à la baisse
            trendIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />';
            trendIcon.className = 'h-16 w-16 text-red-600';
            trendIcon.style.transform = 'translateY(2px)';
            trendText.textContent = 'En baisse';
            trendText.className = 'text-sm font-medium text-red-600';
            trendValue.className = 'text-sm font-bold text-red-600';
        } else {
            // Stable
            trendIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14" />';
            trendIcon.className = 'h-16 w-16 text-amber-600';
            trendIcon.style.transform = 'rotate(0deg)';
            trendText.textContent = 'Stable';
            trendText.className = 'text-sm font-medium text-amber-600';
            trendValue.className = 'text-sm font-bold text-amber-600';
        }
        
        // Ajouter une animation fluide
        trendIcon.style.transition = 'transform 0.5s ease-in-out, color 0.5s ease-in-out';
    }
}

// Fonction pour calculer le stock d'eau et le taux de remplissage en fonction du niveau
function calculateRetenueStockAndRate(level) {
    const minLevel = 177.25;
    const maxLevel = 200;
    const maxCapacity = 42.11; // Mm³
    
    // Calculer le pourcentage de la hauteur d'eau par rapport à la gamme possible
    const levelPercentage = Math.max(0, Math.min(100, (level - minLevel) / (maxLevel - minLevel) * 100));
    
    // Relation non linéaire entre le niveau et le volume (approximation)
    // Cette formule est simplifiée et pourrait être ajustée selon les caractéristiques réelles du barrage
    const stock = (levelPercentage / 100) * maxCapacity;
    
    return {
        stock: parseFloat(stock.toFixed(2)),
        rate: parseFloat(levelPercentage.toFixed(1))
    };
}

// Appeler cette fonction lors de l'initialisation
function initDynamicRetenue() {
    // Vérifier si la section retenue est active
    if (document.getElementById('retenue-section') && 
        !document.getElementById('retenue-section').classList.contains('hidden')) {
        
        // Configurer les mises à jour dynamiques
        setupDynamicUpdates();
        
        // Configurer les écouteurs pour les changements de niveau d'eau
        const levelSlider = document.getElementById('retenue-level-slider');
        const sliderValue = document.getElementById('retenue-slider-value');
        
        if (levelSlider && sliderValue) {
            levelSlider.addEventListener('input', function(e) {
                const level = parseFloat(e.target.value);
                
                // Mettre à jour l'affichage du slider
                sliderValue.textContent = level.toFixed(2);
                
                // Calculer les valeurs dérivées
                const minLevel = 177.25;
                const maxLevel = 200;
                const range = maxLevel - minLevel;
                
                // Hauteur d'eau visuelle
                const waterLevelHeight = ((level - minLevel) / range) * 100;
                
                // Mettre à jour le niveau d'eau
                const water = document.getElementById('retenue-water');
                const levelMarker = document.getElementById('retenue-level-marker');
                const markerValue = document.getElementById('retenue-marker-value');
                
                if (water) water.style.height = `${waterLevelHeight}%`;
                if (levelMarker) levelMarker.style.bottom = `${waterLevelHeight}%`;
                if (markerValue) markerValue.textContent = level.toFixed(2);
                
                // Calculer le stock et le taux en fonction du niveau
                const { stock, rate } = calculateRetenueStockAndRate(level);
                
                // Mettre à jour les valeurs des cartes
                const stockElement = document.getElementById('current-stock');
                const fillRateElement = document.getElementById('current-fill-rate');
                
                if (stockElement) stockElement.textContent = stock.toFixed(2);
                if (fillRateElement) fillRateElement.textContent = rate.toFixed(1);
                
                // Calculer les valeurs pour l'envasement et l'évaporation
                const siltation = (rate * 0.95).toFixed(1);
                const evaporation = (rate * 0.05).toFixed(1);
                
                // Mettre à jour les valeurs d'envasement et d'évaporation
                const siltationElement = document.getElementById('current-siltation');
                const evaporationElement = document.getElementById('current-evaporation');
                
                if (siltationElement) siltationElement.textContent = siltation;
                if (evaporationElement) evaporationElement.textContent = evaporation;
                
                // Mettre à jour les lâchés d'eau (fonction du stock)
                const release = (stock * 0.03).toFixed(2);
                const releaseElement = document.getElementById('current-release');
                
                if (releaseElement) releaseElement.textContent = release;
                
                // La mise à jour des graphiques et indicateurs se fera automatiquement
                // grâce aux observateurs configurés dans setupDynamicUpdates
            });
        }
    }
}

// Ajouter à l'initialisation existante
document.addEventListener('DOMContentLoaded', function() {
    const navLinks = document.querySelectorAll('.nav-link');
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            const sectionId = this.getAttribute('data-section');
            if (sectionId === 'retenue-section') {
                setTimeout(() => {
                    fixGraphFilters();
                    renderRetenueChart();
                    addZoomControls();
                    initDynamicRetenue();
                }, 500);
            }
        });
    });
    
    // Exécuter une première fois si on est déjà sur la section de retenue
    if (document.getElementById('retenue-section') && 
        !document.getElementById('retenue-section').classList.contains('hidden')) {
        setTimeout(() => {
            fixGraphFilters();
            renderRetenueChart();
            addZoomControls();
            initDynamicRetenue();
        }, 500);
    }
});

function updateGraphFromCards() {
    // Récupérer les valeurs actuelles
    const currentStock = document.getElementById('current-stock');
    const currentFillRate = document.getElementById('current-fill-rate');
    const currentSiltation = document.getElementById('current-siltation');
    const currentEvaporation = document.getElementById('current-evaporation');
    const currentRelease = document.getElementById('current-release');
    
    // Si les éléments existent et contiennent des valeurs
    if (currentStock && currentFillRate && currentSiltation && currentEvaporation && currentRelease) {
        // Obtenir la date actuelle
        const now = new Date();
        const dateStr = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth() + 1).toString().padStart(2, '0')}`;
        
        // Calculer le niveau à partir du taux de remplissage (formule approximative)
        const fillRate = parseFloat(currentFillRate.textContent);
        const minLevel = 177.25;
        const maxLevel = 200;
        const range = maxLevel - minLevel;
        const niveau = minLevel + (range * fillRate / 100);
        
        // Créer un nouveau point de données
        const newDataPoint = {
            date: dateStr,
            niveau: niveau,
            stock: parseFloat(currentStock.textContent),
            taux: fillRate,
            envasement: parseFloat(currentSiltation.textContent),
            evaporation: parseFloat(currentEvaporation.textContent),
            laches: parseFloat(currentRelease.textContent)
        };
        
        // Mettre à jour la dernière entrée des données ou ajouter si nécessaire
        if (retenueChartData.length > 0 && retenueChartData[retenueChartData.length - 1].date === dateStr) {
            retenueChartData[retenueChartData.length - 1] = newDataPoint;
        } else {
            retenueChartData.push(newDataPoint);
        }
        
        // Mettre à jour le graphique
        renderRetenueChart();
    }
}

// Fonction pour basculer la simulation
function toggleRetenueSimulation() {
    try {
        retenueSimulationActive = !retenueSimulationActive;
        const updateBtn = document.getElementById('retenue-update-btn');
        const simulationBtn = document.getElementById('retenue-simulation-btn');
        
        if (retenueSimulationActive) {
            // Démarrer la simulation
            if (updateBtn) {
                updateBtn.textContent = 'Arrêter';
                updateBtn.classList.remove('bg-blue-600');
                updateBtn.classList.add('bg-red-600');
            }
            
            if (simulationBtn) {
                simulationBtn.innerHTML = '<i class="fas fa-stop"></i><span>Arrêter la simulation</span>';
                simulationBtn.classList.add('bg-red-600');
            }
            
            // Désactiver l'entrée pendant la simulation
            const levelInput = document.getElementById('retenue-level-input');
            if (levelInput) levelInput.setAttribute('readonly', true);
            
            // Démarrer la simulation
            startRetenueSimulation();
        } else {
            // Arrêter la simulation
            if (updateBtn) {
                updateBtn.textContent = 'Mettre à jour';
                updateBtn.classList.remove('bg-red-600');
                updateBtn.classList.add('bg-blue-600');
            }
            
            if (simulationBtn) {
                simulationBtn.innerHTML = '<i class="fas fa-play"></i><span>Mode simulation</span>';
                simulationBtn.classList.remove('bg-red-600');
            }
            
            // Réactiver l'entrée
            const levelInput = document.getElementById('retenue-level-input');
            if (levelInput) levelInput.removeAttribute('readonly');
            
            // Arrêter la simulation
            stopRetenueSimulation();
        }
    } catch (error) {
        console.error("Erreur dans toggleRetenueSimulation:", error);
    }
}

// Démarrer la simulation
function startRetenueSimulation() {
    try {
        let direction = 1; // 1: montée, -1: descente
        let step = 0.05; // Pas de variation du niveau
        
        retenueSimulationInterval = setInterval(() => {
            const levelInput = document.getElementById('retenue-level-input');
            if (!levelInput) return;
            
            let currentLevel = parseFloat(levelInput.value);
            
            // Changer de direction si nécessaire
            if (currentLevel >= 182.5) direction = -1;
            if (currentLevel <= 180.5) direction = 1;
            
            // Calculer le nouveau niveau
            currentLevel += direction * step;
            levelInput.value = currentLevel.toFixed(2);
            
            // Mettre à jour les visualisations
            updateRetenueBasedOnLevel(currentLevel);
            
            // Ajouter une légère variation aléatoire pour plus de réalisme
            step = 0.03 + Math.random() * 0.04;
        }, 1500);
    } catch (error) {
        console.error("Erreur dans startRetenueSimulation:", error);
    }
}

// 14. Arrêter la simulation (suite)
function stopRetenueSimulation() {
    try {
        if (retenueSimulationInterval) {
            clearInterval(retenueSimulationInterval);
            retenueSimulationInterval = null;
        }
    } catch (error) {
        console.error("Erreur dans stopRetenueSimulation:", error);
    }
}

// 15. Fonctions pour le zoom du graphique

function addZoomControlsToChart() {
    const chartContainer = document.getElementById('retenue-evolution-chart');
    if (!chartContainer) return;

    // Créer le conteneur des boutons de zoom
    const zoomControls = document.createElement('div');
    zoomControls.className = 'flex justify-end gap-2 mb-2';
    zoomControls.innerHTML = `
        <button id="zoom-in-btn" class="p-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700">
            <i class="fas fa-search-plus"></i>
        </button>
        <button id="zoom-out-btn" class="p-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700">
            <i class="fas fa-search-minus"></i>
        </button>
        <button id="reset-zoom-btn" class="p-2 rounded-md bg-gray-100 hover:bg-gray-200 text-gray-700">
            <i class="fas fa-expand"></i>
        </button>
    `;

    // Insérer avant le canvas
    chartContainer.insertBefore(zoomControls, chartContainer.firstChild);

    // Ajouter les événements
    document.getElementById('zoom-in-btn').addEventListener('click', () => zoomRetenueChart(0.1));
    document.getElementById('zoom-out-btn').addEventListener('click', () => zoomRetenueChart(-0.1));
    document.getElementById('reset-zoom-btn').addEventListener('click', resetRetenueZoom);
}

// Fonction pour ajouter les boutons de zoom au graphique
function addZoomControls() {
    const container = document.getElementById('retenue-evolution-chart');
    if (!container) return;
    
    // Supprimer les contrôles existants s'il y en a
    const existingControls = container.querySelector('.chart-zoom-controls');
    if (existingControls) existingControls.remove();
    
    // Créer les contrôles de zoom
    const zoomControls = document.createElement('div');
    zoomControls.className = 'chart-zoom-controls';
    zoomControls.style.cssText = `
        position: absolute;
        bottom: 10px;
        right: 10px;
        z-index: 10;
        display: flex;
        gap: 5px;
    `;
    
    // Bouton zoom +
    const zoomInBtn = document.createElement('button');
    zoomInBtn.className = 'chart-zoom-btn';
    zoomInBtn.innerHTML = '<i class="fas fa-search-plus"></i>';
    zoomInBtn.title = 'Zoomer';
    zoomInBtn.style.cssText = `
        background-color: white;
        border: 1px solid #e5e7eb;
        border-radius: 5px;
        padding: 8px 10px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.2s;
    `;
    zoomInBtn.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#f3f4f6';
        this.style.transform = 'translateY(-1px)';
        this.style.boxShadow = '0 3px 6px rgba(0,0,0,0.15)';
    });
    zoomInBtn.addEventListener('mouseout', function() {
        this.style.backgroundColor = 'white';
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    });
    zoomInBtn.addEventListener('click', function() {
        zoomRetenueChart(0.2);
    });
    
    // Bouton zoom -
    const zoomOutBtn = document.createElement('button');
    zoomOutBtn.className = 'chart-zoom-btn';
    zoomOutBtn.innerHTML = '<i class="fas fa-search-minus"></i>';
    zoomOutBtn.title = 'Dézoomer';
    zoomOutBtn.style.cssText = `
        background-color: white;
        border: 1px solid #e5e7eb;
        border-radius: 5px;
        padding: 8px 10px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.2s;
    `;
    zoomOutBtn.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#f3f4f6';
        this.style.transform = 'translateY(-1px)';
        this.style.boxShadow = '0 3px 6px rgba(0,0,0,0.15)';
    });
    zoomOutBtn.addEventListener('mouseout', function() {
        this.style.backgroundColor = 'white';
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    });
    zoomOutBtn.addEventListener('click', function() {
        zoomRetenueChart(-0.2);
    });
    
    // Bouton reset zoom
    const resetZoomBtn = document.createElement('button');
    resetZoomBtn.className = 'chart-zoom-btn';
    resetZoomBtn.innerHTML = '<i class="fas fa-undo-alt"></i>';
    resetZoomBtn.title = 'Réinitialiser le zoom';
    resetZoomBtn.style.cssText = `
        background-color: white;
        border: 1px solid #e5e7eb;
        border-radius: 5px;
        padding: 8px 10px;
        font-size: 14px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.2s;
    `;
    resetZoomBtn.addEventListener('mouseover', function() {
        this.style.backgroundColor = '#f3f4f6';
        this.style.transform = 'translateY(-1px)';
        this.style.boxShadow = '0 3px 6px rgba(0,0,0,0.15)';
    });
    resetZoomBtn.addEventListener('mouseout', function() {
        this.style.backgroundColor = 'white';
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    });
    resetZoomBtn.addEventListener('click', function() {
        resetRetenueZoom();
    });
    
    // Ajouter une info sur le zoom
    const zoomInfo = document.createElement('div');
    zoomInfo.className = 'zoom-info';
    zoomInfo.style.cssText = `
        position: absolute;
        top: 10px;
        left: 10px;
        font-size: 12px;
        color: #6b7280;
        background-color: rgba(255,255,255,0.8);
        padding: 4px 8px;
        border-radius: 4px;
        z-index: 5;
    `;
    zoomInfo.innerHTML = '<i class="fas fa-info-circle"></i> Utiliser la molette pour zoomer, cliquer-glisser pour déplacer';
    
    // Ajouter les boutons au conteneur
    zoomControls.appendChild(zoomInBtn);
    zoomControls.appendChild(zoomOutBtn);
    zoomControls.appendChild(resetZoomBtn);
    container.appendChild(zoomControls);
    container.appendChild(zoomInfo);
}

// Fonction pour zoomer le graphique de la retenue
function zoomRetenueChart(factor) {
    try {
        if (!retenueChart || !retenueChart.zoom) {
            console.warn("Fonction de zoom non disponible pour le graphique retenue");
            return;
        }
        
        retenueChart.zoom(1 + factor);
    } catch (error) {
        console.error("Erreur lors du zoom du graphique retenue:", error);
    }
}

// Fonction pour réinitialiser le zoom
function resetRetenueZoom() {
    try {
        if (!retenueChart || !retenueChart.resetZoom) {
            console.warn("Fonction de réinitialisation de zoom non disponible pour le graphique retenue");
            return;
        }
        
        retenueChart.resetZoom();
    } catch (error) {
        console.error("Erreur lors de la réinitialisation du zoom du graphique retenue:", error);
        // En cas d'erreur, tenter de recréer le graphique
        setTimeout(renderRetenueChart, 100);
    }
}

// 16. Afficher l'historique complet
function showRetenueFullHistory() {
    try {
        // Création d'une modale pour afficher l'historique
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 z-50';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.overflow = 'auto';
        modal.style.padding = '1rem';
        
        // Construire le contenu de la modale
        modal.innerHTML = `
            <div class="bg-white rounded-lg w-11/12 max-w-4xl max-h-[90vh]" style="display: flex; flex-direction: column;">
                <div class="p-4 border-b sticky top-0 bg-white z-10 flex justify-between items-center">
                    <h3 class="text-xl font-bold">Historique complet de la retenue</h3>
                    <button id="close-retenue-history-modal" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div style="overflow-y: auto; flex-grow: 1; max-height: calc(90vh - 130px);">
                    <table class="w-full">
                        <thead class="sticky top-0 bg-gray-100 z-10">
                            <tr>
                                <th class="p-2 text-left border-b border-gray-200">Date</th>
                                <th class="p-2 text-center border-b border-gray-200">Niveau (m)</th>
                                <th class="p-2 text-center border-b border-gray-200">Stock (Mm³)</th>
                                <th class="p-2 text-center border-b border-gray-200">Remplissage (%)</th>
                                <th class="p-2 text-center border-b border-gray-200">Envasement (%)</th>
                                <th class="p-2 text-center border-b border-gray-200">Évaporation (%)</th>
                                <th class="p-2 text-center border-b border-gray-200">Lâchés (Mm³)</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${generateRetenueHistoryRows()}
                        </tbody>
                    </table>
                </div>
                
                <div class="p-4 border-t mt-auto bg-white">
                    <div class="text-sm text-gray-500">
                        <i class="fas fa-info-circle"></i> Les données sont conservées pendant 30 jours
                    </div>
                </div>
            </div>
        `;
        
        // Ajouter la modale au document
        document.body.appendChild(modal);
        document.body.style.overflow = 'hidden';
        
        // Gérer la fermeture de la modale
        const closeBtn = document.getElementById('close-retenue-history-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', function() {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
            });
        }
        
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
            }
        });
    } catch (error) {
        console.error("Erreur dans showRetenueFullHistory:", error);
    }
}

// 17. Générer les lignes pour l'historique
function generateRetenueHistoryRows() {
    try {
        let rows = '';
        
        // Générer 30 jours d'historique avec des données aléatoires mais cohérentes
        const currentDate = new Date();
        let level = 181.18;
        
        for (let i = 0; i < 30; i++) {
            const date = new Date(currentDate);
            date.setDate(date.getDate() - i);
            const dateStr = date.toLocaleDateString('fr-FR');
            
            // Fluctuations aléatoires mais réalistes
            level += (Math.random() - 0.5) * 0.3;
            level = Math.min(200, Math.max(177.25, level));
            
            const { stock, rate } = calculateRetenueStockAndRate(level);
            const silt = (rate * 0.95).toFixed(1);
            const evap = (rate * 0.05).toFixed(1);
            const release = (stock * 0.03).toFixed(2);
            
            rows += `
                <tr class="border-b border-gray-200 hover:bg-teal-50">
                    <td class="p-3">${dateStr}</td>
                    <td class="p-3 text-center">${level.toFixed(2)}</td>
                    <td class="p-3 text-center">${stock.toFixed(2)}</td>
                    <td class="p-3 text-center">${rate.toFixed(1)}</td>
                    <td class="p-3 text-center">${silt}</td>
                    <td class="p-3 text-center">${evap}</td>
                    <td class="p-3 text-center">${release}</td>
                </tr>
            `;
        }
        
        return rows;
    } catch (error) {
        console.error("Erreur dans generateRetenueHistoryRows:", error);
        return '<tr><td colspan="7" class="text-center p-4">Erreur de chargement des données</td></tr>';
    }
}

// 18. Exporter les données au format Excel
function exportRetenueData(format = 'xlsx') {
    try {
        if (format === 'xlsx') {
            exportRetenueToExcel();
        } else {
            exportRetenueToPDF();
        }
    } catch (error) {
        console.error("Erreur dans exportRetenueData:", error);
        alert("Une erreur est survenue lors de l'export");
    }
}

// 19. Exporter en Excel
function exportRetenueToExcel() {
    try {
        if (typeof XLSX === 'undefined') {
            alert("La librairie XLSX n'est pas chargée");
            return;
        }
        
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        
        // Créer un nouveau classeur
        const wb = XLSX.utils.book_new();
        
        // Convertir les données de tableau en feuille de calcul
        const combinedData = retenueTableData.map(item => ({
            'Date': item.date,
            'Niveau (m)': item.level,
            'Stock (Mm³)': item.stock,
            'Remplissage (%)': item.rate,
            'Envasement (%)': item.silt,
            'Évaporation (%)': item.evap,
            'Lâchés d\'eau (Mm³)': item.release
        }));
        
        const ws = XLSX.utils.json_to_sheet(combinedData);
        
        // Ajouter la feuille au classeur
        XLSX.utils.book_append_sheet(wb, ws, "Retenue");
        
        // Générer le fichier Excel
        const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
        
        // Créer un Blob et télécharger le fichier
        const blob = new Blob([wbout], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `retenue_data_${timestamp}.xlsx`;
        document.body.appendChild(a);
        a.click();
        
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        
    } catch (error) {
        console.error("Erreur lors de l'export Excel:", error);
        alert("Une erreur est survenue lors de l'export Excel");
    }
}

// 20. Exporter en PDF
function exportRetenueToPDF() {
    try {
        if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
            alert("La fonction PDF nécessite la librairie jsPDF");
            return;
        }
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        // Titre et date
        doc.setFontSize(18);
        doc.text('Rapport de Gestion de la Retenue', 14, 20);
        
        doc.setFontSize(10);
        doc.text(`Exporté le: ${new Date().toLocaleString()}`, 14, 30);
        
        // En-têtes de tableau
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold');
        doc.text('Date', 14, 40);
        doc.text('Niveau (m)', 50, 40);
        doc.text('Stock (Mm³)', 90, 40);
        doc.text('Remplissage (%)', 130, 40);
        doc.text('Lâchés (Mm³)', 170, 40);
        
        // Données du tableau
        doc.setFont(undefined, 'normal');
        let y = 50;
        
        retenueTableData.forEach((item, index) => {
            doc.text(item.date, 14, y);
            doc.text(item.level.toFixed(2).toString(), 50, y);
            doc.text(item.stock.toFixed(2).toString(), 90, y);
            doc.text(item.rate.toFixed(1).toString(), 130, y);
            doc.text(item.release.toFixed(2).toString(), 170, y);
            y += 10;
        });
        
        // Informations additionnelles
        y += 10;
        doc.setFont(undefined, 'bold');
        doc.text('Informations additionnelles:', 14, y);
        y += 10;
        doc.setFont(undefined, 'normal');
        doc.text(`Capacité maximale de stockage: ${RETENUE_MAX_CAPACITY} millions de m³`, 14, y);
        y += 10;
        doc.text(`Taux d'envasement moyen: 64.9%`, 14, y);
        y += 10;
        doc.text(`Taux d'évaporation moyen: 3.4%`, 14, y);
        
        // Enregistrer le PDF
        doc.save(`retenue_rapport_${new Date().toISOString().slice(0,10)}.pdf`);
        
    } catch (error) {
        console.error("Erreur lors de l'export PDF:", error);
        alert("Une erreur est survenue lors de l'export PDF");
    }
}

// 21. Exporter l'image du graphique
function exportRetenueChartImage() {
    try {
        if (!retenueChart) {
            alert("Le graphique n'est pas disponible pour l'export");
            return;
        }
        
        // Récupérer le canvas
        const canvas = document.getElementById('retenueChartCanvas');
        if (!canvas) {
            alert("Impossible de trouver le canvas du graphique");
            return;
        }
        
        // Convertir en image
        const imageURL = canvas.toDataURL('image/png');
        
        // Télécharger l'image
        const a = document.createElement('a');
        a.href = imageURL;
        a.download = `retenue_graph_${new Date().toISOString().slice(0,10)}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
    } catch (error) {
        console.error("Erreur lors de l'export de l'image:", error);
        alert("Une erreur est survenue lors de l'export de l'image");
    }
}

function resetRetenueData() {
    if(confirm('Voulez-vous vraiment tout réinitialiser ? Toutes les données et l\'historique seront effacés.')) {
        // 1. Réinitialiser TOUTES les données en mémoire
        retenueChartData = [];
        retenueTableData = [];
        
        // 2. Générer un jeu de données vide avec la date actuelle seulement
        const now = new Date();
        const currentDate = `${now.getDate().toString().padStart(2, '0')}/${(now.getMonth()+1).toString().padStart(2, '0')}`;
        
        // 3. Vider complètement le tableau HTML des indicateurs
        const indicatorTable = document.getElementById('retenue-data-table');
        if (indicatorTable) {
            indicatorTable.innerHTML = `
                <tr>
                    <td colspan="7" class="text-center py-4 text-gray-500">
                        Aucune donnée disponible
                    </td>
                </tr>
            `;
        }
        
        // 4. Détruire et recréer le graphique avec un seul point (date actuelle)
        if (retenueChart) {
            retenueChart.destroy();
        }
        
        retenueChart = new Chart(document.getElementById('retenueChartCanvas').getContext('2d'), {
            type: 'line',
            data: {
                labels: [currentDate], // Uniquement la date actuelle
                datasets: [
                    {
                        label: 'Niveau (m)',
                        data: [0],
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        hidden: !retenueFilters.niveau
                    },
                    // ... (autres datasets avec data: [0])
                ]
            },
            options: { /* vos options */ }
        });
        
        // 5. Réinitialiser tous les indicateurs à zéro
        resetAllIndicatorsToZero();
        
        // 6. Réinitialiser la visualisation 3D
        reset3DVisualization();
        
        // 7. Réinitialiser le slider
        resetLevelSlider();
        
        // 8. Nettoyer le stockage local
        localStorage.removeItem('lastRetenueState');
        localStorage.removeItem('lastRetenueLevel');
        
        // 9. Afficher confirmation
        showNotification('Réinitialisation complète effectuée - Toutes les données ont été effacées', 'success');
    }
}

// Fonctions auxiliaires (gardez celles de la réponse précédente)


// 22. Réinitialiser les données
function fixGraphFilters() {
    // Récupérer tous les boutons de filtre
    const filterButtons = document.querySelectorAll('[id^="filter-"]');
    
    // Vérifier si les boutons existent
    if (filterButtons.length === 0) {
        console.log("Aucun bouton de filtre trouvé");
        return;
    }
    
    console.log(`${filterButtons.length} boutons de filtre trouvés`);
    
    // Remplacer les gestionnaires d'événements sur chaque bouton
    filterButtons.forEach(button => {
        const filterId = button.id.replace('filter-', '');
        
        // Supprimer les anciens gestionnaires d'événements
        button.replaceWith(button.cloneNode(true));
        
        // Récupérer le bouton nouvellement cloné
        const newButton = document.getElementById(button.id);
        
        if (newButton) {
            // Ajouter un nouveau gestionnaire d'événements
            newButton.addEventListener('click', function() {
                console.log(`Filtre ${filterId} cliqué`);
                toggleFilter(filterId);
            });
        }
    });
    
    // Si besoin, forcer le rendu initial du graphique après correction des filtres
    setTimeout(renderRetenueChart, 100);
}

function generateDefaultRetenueData() {
    const defaultData = [
        { date: '01/05', niveau: 178.50, stock: 10.25, taux: 24.3, envasement: 23.1, evaporation: 1.2, laches: 0.30 },
        { date: '02/05', niveau: 178.75, stock: 12.40, taux: 29.4, envasement: 27.9, evaporation: 1.5, laches: 0.37 },
        { date: '03/05', niveau: 179.20, stock: 15.70, taux: 37.3, envasement: 35.4, evaporation: 1.9, laches: 0.47 },
        { date: '04/05', niveau: 179.85, stock: 19.30, taux: 45.8, envasement: 43.5, evaporation: 2.3, laches: 0.58 },
        { date: '05/05', niveau: 180.40, stock: 22.90, taux: 54.4, envasement: 51.7, evaporation: 2.7, laches: 0.69 }
    ];
    
    retenueChartData = defaultData;
    
    // Mettre à jour les cartes avec les dernières valeurs
    const latestData = defaultData[defaultData.length - 1];
    
    const elements = {
        currentStock: document.getElementById('current-stock'),
        currentFillRate: document.getElementById('current-fill-rate'),
        currentSiltation: document.getElementById('current-siltation'),
        currentEvaporation: document.getElementById('current-evaporation'),
        currentRelease: document.getElementById('current-release')
    };
    
    if (elements.currentStock) elements.currentStock.textContent = latestData.stock.toFixed(2);
    if (elements.currentFillRate) elements.currentFillRate.textContent = latestData.taux.toFixed(1);
    if (elements.currentSiltation) elements.currentSiltation.textContent = latestData.envasement.toFixed(1);
    if (elements.currentEvaporation) elements.currentEvaporation.textContent = latestData.evaporation.toFixed(1);
    if (elements.currentRelease) elements.currentRelease.textContent = latestData.laches.toFixed(2);
    
    // Mettre à jour le niveau d'eau visuel
    const minLevel = 177.25;
    const maxLevel = 200;
    const range = maxLevel - minLevel;
    const waterLevelHeight = ((latestData.niveau - minLevel) / range) * 100;
    
    const water = document.getElementById('retenue-water');
    const levelMarker = document.getElementById('retenue-level-marker');
    const markerValue = document.getElementById('retenue-marker-value');
    
    if (water) water.style.height = `${waterLevelHeight}%`;
    if (levelMarker) levelMarker.style.bottom = `${waterLevelHeight}%`;
    if (markerValue) markerValue.textContent = latestData.niveau.toFixed(2);
    
    // Mettre à jour le slider
    const levelSlider = document.getElementById('retenue-level-slider');
    if (levelSlider) levelSlider.value = latestData.niveau.toFixed(2);
}

// Observer les changements dans les cartes pour mettre à jour le graphique automatiquement
function setupCardObservers() {
    const cards = [
        document.getElementById('current-stock'),
        document.getElementById('current-fill-rate'),
        document.getElementById('current-siltation'),
        document.getElementById('current-evaporation'),
        document.getElementById('current-release')
    ];
    
    cards.forEach(card => {
        if (card) {
            // Observer les changements de contenu
            const observer = new MutationObserver(() => {
                console.log('Changement détecté dans les cartes, mise à jour du graphique');
                updateGraphFromCards();
            });
            
            observer.observe(card, { childList: true, characterData: true, subtree: true });
        }
    });
}

// Ajouter l'initialisation
document.addEventListener('DOMContentLoaded', function() {
    const navLinks = document.querySelectorAll('.nav-link');
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            const sectionId = this.getAttribute('data-section');
            if (sectionId === 'retenue-section') {
                // Appliquer les corrections après un délai pour permettre le chargement complet de la section
                setTimeout(() => {
                    fixGraphFilters();
                    renderRetenueChart();
                    setupCardObservers(); // Ajouter des observateurs pour les mises à jour automatiques
                }, 500);
            }
        });
    });
    
    // Exécuter une première fois si on est déjà sur la section de retenue
    if (document.getElementById('retenue-section') && 
        !document.getElementById('retenue-section').classList.contains('hidden')) {
        setTimeout(() => {
            fixGraphFilters();
            renderRetenueChart();
            setupCardObservers(); // Ajouter des observateurs pour les mises à jour automatiques
        }, 500);
    }
});


function initRetenueSection() {
    try {
        // Rendre la visualisation avec le nouveau code
        renderRetenueVisualization();
        
        // Ajouter les styles d'animation
        addWaveAnimation();
        
        // Ajouter les contrôles de zoom
        addZoomControlsToChart();
        
        // Initialiser avec la valeur par défaut
        updateRetenueBasedOnLevel(181.18);
        
        // Mettre à jour tous les indicateurs
        updateRetenueIndicators();
        
        // Demander les dernières données au serveur
        if (socket && socket.connected) {
            socket.emit('getRetenueData');
        }
        
        console.log("Section retenue initialisée avec succès");
    } catch (error) {
        console.error("Erreur lors de l'initialisation de la section retenue:", error);
    }
}

// Fonctions d'export pour les données ambiantes
function exportAmbientData(format = 'xlsx') {
    if (state.ambientTempChartData.length === 0 && state.ambientHumidityChartData.length === 0) {
        alert("Aucune donnée à exporter");
        return;
    }
    
    if (format === 'xlsx') {
        exportAmbientToExcel();
    } else if (format === 'pdf') {
        exportAmbientToPDF();
    }
}

function exportAmbientToExcel() {
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        
        // Préparer les données pour l'export
        let data = [];
        
        // Fusionner les données de température et d'humidité
        const maxLength = Math.max(state.ambientTempChartData.length, state.ambientHumidityChartData.length);
        
        for (let i = 0; i < maxLength; i++) {
            const tempData = i < state.ambientTempChartData.length ? state.ambientTempChartData[i] : null;
            const humidityData = i < state.ambientHumidityChartData.length ? state.ambientHumidityChartData[i] : null;
            
            const row = {
                'Heure': tempData ? new Date(tempData.timestamp).toLocaleString() : (humidityData ? new Date(humidityData.timestamp).toLocaleString() : ''),
                'Température (°C)': tempData ? tempData.temperature : '',
                'Humidité (%)': humidityData ? humidityData.humidity : '',
                'Point de Rosée (°C)': tempData && humidityData ? calculateDewPoint(tempData.temperature, humidityData.humidity).toFixed(1) : '',
                'Indice de Chaleur (°C)': tempData && humidityData ? calculateHeatIndex(tempData.temperature, humidityData.humidity).toFixed(1) : ''
            };
            
            data.push(row);
        }
        
        // Créer le fichier Excel
        const worksheet = XLSX.utils.json_to_sheet(data);
        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Climat_Ambiant");
        
        const content = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        
        const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `climat_ambiant_${timestamp}.xlsx`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    } catch (e) {
        console.error("Erreur lors de l'export Excel du climat ambiant", e);
        alert("Une erreur est survenue lors de l'export");
    }
}

function exportAmbientToPDF() {
    try {
        if (state.ambientTempChartData.length === 0 && state.ambientHumidityChartData.length === 0) {
            alert("Aucune donnée à exporter");
            return;
        }

        if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
            alert("La fonction PDF nécessite la librairie jsPDF. Chargement en cours...");
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        doc.setFontSize(18);
        doc.text('Rapport du Climat Ambiant (DHT22)', 14, 15);
        
        doc.setFontSize(10);
        doc.text(`Exporté le: ${new Date().toLocaleString()} (données conservées 24h)`, 14, 25);
        
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold');
        doc.text('Heure', 14, 35);
        doc.text('Temp. (°C)', 50, 35);
        doc.text('Hum. (%)', 80, 35);
        doc.text('P. Rosée (°C)', 115, 35);
        doc.text('Indice (°C)', 155, 35);
        
        doc.setFont(undefined, 'normal');
        let y = 45;
        
        // Fusionner les données de température et d'humidité
        const tempData = state.ambientTempChartData;
        const humidityData = state.ambientHumidityChartData;
        
        const maxLength = Math.max(tempData.length, humidityData.length);
        
        for (let i = 0; i < maxLength; i++) {
            if (y > 280) {
                doc.addPage();
                y = 20;
            }
            
            const temp = i < tempData.length ? tempData[i].temperature : null;
            const humidity = i < humidityData.length ? humidityData[i].humidity : null;
            
            const timeStr = i < tempData.length ? 
                (tempData[i].timestamp ? new Date(tempData[i].timestamp).toLocaleTimeString() : 'N/A') :
                (i < humidityData.length ? new Date(humidityData[i].timestamp).toLocaleTimeString() : 'N/A');
            
            doc.text(timeStr, 14, y);
            doc.text(temp !== null ? temp.toFixed(1) : '-', 50, y);
            doc.text(humidity !== null ? humidity.toFixed(1) : '-', 80, y);
            
            if (temp !== null && humidity !== null) {
                const dewPoint = calculateDewPoint(temp, humidity);
                const heatIndex = calculateHeatIndex(temp, humidity);
                doc.text(dewPoint.toFixed(1), 115, y);
                doc.text(heatIndex.toFixed(1), 155, y);
            } else {
                doc.text('-', 115, y);
                doc.text('-', 155, y);
            }
            
            y += 10;
        }
        
        doc.save(`climat_ambiant_${new Date().toISOString().slice(0,10)}.pdf`);
    } catch (e) {
        console.error("Erreur lors de l'export PDF", e);
        alert("Une erreur est survenue lors de l'export PDF");
    }
}

function exportAmbientChartImage() {
    try {
        const tempCanvas = document.querySelector('#ambient-temp-chart canvas');
        const humidityCanvas = document.querySelector('#ambient-humidity-chart canvas');
        
        if (!tempCanvas && !humidityCanvas) {
            alert("Graphiques non disponibles");
            return;
        }
        
        // Créer un canvas combiné
        const combinedCanvas = document.createElement('canvas');
        const ctx = combinedCanvas.getContext('2d');
        
        // Définir la taille du canvas combiné
        const width = 800;
        const height = tempCanvas && humidityCanvas ? 600 : 300;
        combinedCanvas.width = width;
        combinedCanvas.height = height;
        
        // Fond blanc
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, width, height);
        
        // Titre
        ctx.fillStyle = 'black';
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Rapport Climat Ambiant (DHT22)', width / 2, 30);
        
        // Date d'export
        ctx.font = '12px Arial';
        ctx.fillText(`Exporté le: ${new Date().toLocaleString()}`, width / 2, 50);
        
        // Dessiner les graphiques
        if (tempCanvas && humidityCanvas) {
            // Les deux graphiques
            ctx.drawImage(tempCanvas, 0, 70, width, 230);
            ctx.drawImage(humidityCanvas, 0, 330, width, 230);
            
            // Légendes
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Température Ambiante (°C)', 20, 70);
            ctx.fillText('Humidité Ambiante (%)', 20, 330);
        } else if (tempCanvas) {
            // Seulement température
            ctx.drawImage(tempCanvas, 0, 70, width, 230);
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Température Ambiante (°C)', 20, 70);
        } else {
            // Seulement humidité
            ctx.drawImage(humidityCanvas, 0, 70, width, 230);
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Humidité Ambiante (%)', 20, 70);
        }
        
        // Exporter l'image
        const imageURL = combinedCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = imageURL;
        link.download = 'climat-ambiant-' + new Date().toISOString().slice(0, 10) + '.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } catch (e) {
        console.error("Erreur lors de l'export de l'image:", e);
        alert("Erreur lors de l'export de l'image");
    }
}

function resetAmbientData() {
    if(confirm('Voulez-vous vraiment effacer toutes les données du climat ambiant?')) { 
        state.ambientTempChartData = []; 
        state.ambientTempDataIndex = 0;
        state.ambientHumidityChartData = []; 
        state.ambientHumidityDataIndex = 0;
        state.sensorHistory.ambientTemperature = [];
        state.sensorHistory.ambientHumidity = [];
        
        updateHistoryTable(elements.ambientTempHistory, [], '°C');
        updateHistoryTable(elements.ambientHumidityHistory, [], '%');
        
        saveToLocalStorage();
        
        if (ambientTempChart) {
            ambientTempChart.destroy();
            ambientTempChart = null;
        }
        
        if (ambientHumidityChart) {
            ambientHumidityChart.destroy();
            ambientHumidityChart = null;
        }
        
        // Réinitialiser avec des valeurs par défaut
        updateAmbientTempChartData(22.5);
        updateAmbientHumidityChartData(55);
        
        alert("Données du climat ambiant réinitialisées");
    }
}

function showAmbientFullHistory() {
    if (state.ambientTempChartData.length === 0 && state.ambientHumidityChartData.length === 0) {
        alert("Aucun historique disponible");
        return;
    }

    const now = new Date();
    
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 z-50';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.overflow = 'auto';
    modal.style.padding = '1rem';
    
    modal.innerHTML = `
        <div class="bg-white rounded-lg w-11/12 max-w-4xl" style="max-height: 85vh; display: flex; flex-direction: column;">
            <div class="p-4 border-b sticky top-0 bg-white z-10 flex justify-between items-center">
                <h3 class="text-xl font-bold">Historique complet du Climat Ambiant</h3>
                <button id="close-history-modal" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div style="overflow-y: auto; flex-grow: 1; max-height: calc(85vh - 160px);">
                <table class="w-full">
                    <thead class="sticky top-0 bg-gray-100 z-10">
                        <tr>
                            <th class="p-2 text-left border-b border-gray-200">Heure</th>
                            <th class="p-2 text-left border-b border-gray-200">Temps écoulé</th>
                            <th class="p-2 text-left border-b border-gray-200">Temp. (°C)</th>
                            <th class="p-2 text-left border-b border-gray-200">Hum. (%)</th>
                            <th class="p-2 text-left border-b border-gray-200">P. Rosée (°C)</th>
                            <th class="p-2 text-left border-b border-gray-200">I. Chaleur (°C)</th>
                            <th class="p-2 text-left border-b border-gray-200">Statut</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body">
                    </tbody>
                </table>
            </div>
            
            <div class="p-4 border-t mt-auto bg-white">
                <div class="flex flex-col md:flex-row items-center justify-between mb-2 gap-3">
                    <div class="text-sm text-gray-500">
                        <i class="fas fa-info-circle"></i> Les données sont conservées pendant 24 heures
                    </div>
                    <div class="flex flex-wrap items-center gap-2">
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-emerald-500 mr-1"></span>
                            <span class="text-xs">Confortable</span>
                        </div>
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-amber-500 mr-1"></span>
                            <span class="text-xs">Attention</span>
                        </div>
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-red-500 mr-1"></span>
                            <span class="text-xs">Inconfortable</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
    
    const tableBody = document.getElementById('history-table-body');
    
    let tableContent = '';
    
    // Fusionner les données de température et d'humidité par timestamp
    const mergedData = [];
    const timestamps = new Set();
    
    // Ajouter tous les timestamps disponibles
    state.ambientTempChartData.forEach(d => {
        if (d.timestamp) timestamps.add(d.timestamp);
    });
    
    state.ambientHumidityChartData.forEach(d => {
        if (d.timestamp) timestamps.add(d.timestamp);
    });
    
    // Créer un tableau de données fusionnées
    Array.from(timestamps).sort().forEach(timestamp => {
        const temp = state.ambientTempChartData.find(d => d.timestamp === timestamp);
        const humidity = state.ambientHumidityChartData.find(d => d.timestamp === timestamp);
        
        mergedData.push({
            timestamp,
            temperature: temp ? temp.temperature : null,
            humidity: humidity ? humidity.humidity : null
        });
    });
    
    // Trier par timestamp décroissant (du plus récent au plus ancien)
    mergedData.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    mergedData.forEach(data => {
        let timeElapsed = '';
        const dataTime = new Date(data.timestamp);
        const diffMs = now - dataTime;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMins / 60);
        
        if (diffHours > 0) {
            timeElapsed = `${diffHours}h ${diffMins % 60}m`;
        } else {
            timeElapsed = `${diffMins}m`;
        }
        
        // Calculer les valeurs dérivées si les deux données sont disponibles
        let dewPoint = '-';
        let heatIndex = '-';
        let status = '';
        let statusClass = '';
        
        if (data.temperature !== null && data.humidity !== null) {
            dewPoint = calculateDewPoint(data.temperature, data.humidity).toFixed(1);
            heatIndex = calculateHeatIndex(data.temperature, data.humidity).toFixed(1);
            
            // Déterminer le statut de confort
            const tempStatus = getAmbientTempStatus(data.temperature);
            const humidityStatus = getAmbientHumidityStatus(data.humidity);
            
            if (tempStatus.label === 'Confortable' && humidityStatus.label === 'Optimal') {
                status = 'Confortable';
                statusClass = 'bg-green-100 text-green-700';
            } else if (tempStatus.label === 'Très chaud' || tempStatus.label === 'Froid' || 
                       humidityStatus.label === 'Très humide' || humidityStatus.label === 'Sec') {
                status = 'Inconfortable';
                statusClass = 'bg-red-100 text-red-700';
            } else {
                status = 'Acceptable';
                statusClass = 'bg-amber-100 text-amber-700';
            }
        }
        
        tableContent += `
            <tr class="border-b border-gray-200 hover:bg-gray-50">
                <td class="p-3">${dataTime.toLocaleTimeString()}</td>
                <td class="p-3">${timeElapsed}</td>
                <td class="p-3">${data.temperature !== null ? data.temperature.toFixed(1) : '-'}</td>
                <td class="p-3">${data.humidity !== null ? data.humidity.toFixed(1) : '-'}</td>
                <td class="p-3">${dewPoint}</td>
                <td class="p-3">${heatIndex}</td>
                <td class="p-3">
                    ${status ? `<span class="px-2 py-1 rounded-full text-xs font-medium ${statusClass}">${status}</span>` : '-'}
                </td>
            </tr>
        `;
    });
    
    if (tableContent === '') {
        tableContent = `
            <tr>
                <td colspan="7" class="text-center text-gray-400 p-4">
                    Aucune donnée disponible
                </td>
            </tr>
        `;
    }
    
    tableBody.innerHTML = tableContent;
    
    document.getElementById('close-history-modal').addEventListener('click', function() {
        document.body.removeChild(modal);
        document.body.style.overflow = '';
    });
    
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
        }
    });
}

    function zoomChart(factor) {
        if (!chart || !chart.zoom) {
            console.warn("Fonction de zoom non disponible");
            return;
        }
        
        try {
            chart.zoom(1 + factor);
            state.zoomLevel *= (1 + factor);
        } catch (e) {
            console.warn("Erreur lors du zoom:", e);
        }
    }

    function resetZoom() {
        if (!chart || !chart.resetZoom) {
            console.warn("Fonction de réinitialisation de zoom non disponible");
            return;
        }
        
        try {
            chart.resetZoom();
            state.zoomLevel = 1;
        } catch (e) {
            console.warn("Erreur lors de la réinitialisation du zoom:", e);
            setTimeout(renderChart, 100);
        }
    }

    function zoomTemperatureChart(factor) {
        if (!temperatureChart || !temperatureChart.zoom) {
            console.warn("Fonction de zoom non disponible pour la température");
            return;
        }
        
        try {
            temperatureChart.zoom(1 + factor);
        } catch (e) {
            console.warn("Erreur lors du zoom température:", e);
        }
    }

    function resetTemperatureZoom() {
        if (!temperatureChart || !temperatureChart.resetZoom) {
            console.warn("Fonction de réinitialisation de zoom non disponible pour la température");
            return;
        }
        
        try {
            temperatureChart.resetZoom();
        } catch (e) {
            console.warn("Erreur lors de la réinitialisation du zoom température:", e);
            setTimeout(renderTemperatureChart, 100);
        }
    }

    function zoomHumidityChart(factor) {
        if (!humidityChart || !humidityChart.zoom) {
            console.warn("Fonction de zoom non disponible pour l'humidité");
            return;
        }
        
        try {
            humidityChart.zoom(1 + factor);
        } catch (e) {
            console.warn("Erreur lors du zoom humidité:", e);
        }
    }

    function resetHumidityZoom() {
        if (!humidityChart || !humidityChart.resetZoom) {
            console.warn("Fonction de réinitialisation de zoom non disponible pour l'humidité");
            return;
        }
        
        try {
            humidityChart.resetZoom();
        } catch (e) {
            console.warn("Erreur lors de la réinitialisation du zoom humidité:", e);
            setTimeout(renderHumidityChart, 100);
        }
    }

    function populateRainDataTable() {
    const tableBody = document.getElementById('rain-data-table');
    if (!tableBody) return;
    
    let tableContent = '';
    
    // Parcourir les données de pluie en ordre inverse (plus récentes d'abord)
    const dataPoints = state.rainChartData.slice();
    dataPoints.reverse();
    
    dataPoints.forEach((dataPoint, index, array) => {
        const rain = dataPoint.rainAmount;
        const intensity = getRainIntensity(rain);
        
        // Calculer la variation par rapport à la mesure précédente
        let variation = '';
        let variationClass = '';
        
        if (index < array.length - 1) {
            const prevRain = array[index + 1].rainAmount;
            const diff = rain - prevRain;
            
            if (diff > 0.5) {
                variation = `+${diff.toFixed(1)} mm`;
                variationClass = 'text-blue-600';
            } else if (diff < -0.5) {
                variation = `${diff.toFixed(1)} mm`;
                variationClass = 'text-gray-600';
            } else {
                variation = 'Stable';
                variationClass = 'text-gray-600';
            }
        } else {
            variation = '-';
            variationClass = 'text-gray-400';
        }
        
        // Formatter l'heure
        let timeStr = 'N/A';
        if (dataPoint.timestamp) {
            const date = new Date(dataPoint.timestamp);
            timeStr = date.toLocaleTimeString();
        }
        
        // Couleur d'arrière-plan alternée
        const rowBg = index % 2 === 0 ? 'bg-indigo-50' : 'bg-white';
        
        tableContent += `
            <tr class="${rowBg} hover:bg-indigo-100 transition-colors duration-150">
                <td class="p-2 border-b border-indigo-100">${timeStr}</td>
                <td class="p-2 text-center border-b border-indigo-100 font-semibold" style="color: ${intensity.color}">
                    ${rain.toFixed(1)} mm
                </td>
                <td class="p-2 text-center border-b border-indigo-100">
                    <span class="px-2 py-1 rounded-full text-xs font-medium" 
                          style="background-color: ${intensity.color}1A; color: ${intensity.color}">
                        ${intensity.status}
                    </span>
                </td>
                <td class="p-2 text-center border-b border-indigo-100 ${variationClass}">
                    ${variation}
                </td>
            </tr>
        `;
    });
    
    if (tableContent === '') {
        tableContent = `
            <tr>
                <td colspan="4" class="text-center text-gray-400 p-4">
                    Aucune donnée disponible
                </td>
            </tr>
        `;
    }
    
    tableBody.innerHTML = tableContent;
}

// Fonction pour créer la visualisation 3D des précipitations
function createRain3DVisualization() {
    const container = document.getElementById('rain-3d-visualization');
    
    // Vérifier si le conteneur existe
    if (!container) {
        console.warn("Conteneur rain-3d-visualization non trouvé");
        return;
    }
    
    const rainLayers = container.querySelector('.rain-layers');
    const indicators = container.querySelector('.rain-indicators');
    
    if (!rainLayers || !indicators) {
        console.warn("Sous-éléments de rain-3d-visualization non trouvés");
        return;
    }
    
    // Récupérer la dernière valeur de précipitations
    const currentRain = state.rainChartData.length > 0 ? 
        state.rainChartData[state.rainChartData.length - 1].rainAmount : 0;
    
    // Générer les couches de pluie
    rainLayers.innerHTML = '';
    indicators.innerHTML = '';
    
    // Créer le fond de ciel
    const skyLayer = document.createElement('div');
    skyLayer.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(to bottom, #f0f9ff 0%, #dbeafe 100%);
        transition: all 0.5s ease;
    `;
    rainLayers.appendChild(skyLayer);
    
    // Créer des nuages selon l'intensité (limité pour de meilleures performances)
    const numClouds = Math.min(8, Math.max(2, Math.ceil(currentRain)));
    
    // Créer les nuages
    for (let i = 0; i < numClouds; i++) {
        const cloudSize = 30 + Math.random() * 50; // Taille entre 30 et 80
        const top = Math.random() * 40; // Position entre 0 et 40%
        const left = (i * (100 / numClouds)) + (Math.random() * 10 - 5); // Répartis avec un peu d'aléatoire
        
        // Opacité selon l'intensité
        const opacity = 0.5 + (currentRain / 20);
        
        const cloud = document.createElement('div');
        cloud.className = 'rain-cloud';
        cloud.style.cssText = `
            position: absolute;
            top: ${top}%;
            left: ${left}%;
            width: ${cloudSize}px;
            height: ${cloudSize * 0.6}px;
            background-color: rgba(255, 255, 255, ${opacity});
            border-radius: 50%;
            box-shadow: 
                ${cloudSize * 0.3}px ${-cloudSize * 0.1}px 0 rgba(255, 255, 255, ${opacity}),
                ${-cloudSize * 0.3}px ${-cloudSize * 0.1}px 0 rgba(255, 255, 255, ${opacity}),
                0 0 ${cloudSize * 0.5}px rgba(255, 255, 255, ${opacity * 0.5});
            transform: scale(${0.8 + Math.random() * 0.4});
            z-index: 5;
        `;
        rainLayers.appendChild(cloud);
    }
    
    // Le nombre de gouttes dépend de l'intensité de la pluie (limité pour de meilleures performances)
    const maxDrops = 100; // Limite maximale pour éviter les problèmes de performance
    const numDrops = Math.min(maxDrops, Math.ceil(currentRain * 5));
    const intensity = getRainIntensity(currentRain);
    
    // Ajouter un indicateur textuel
    indicators.innerHTML += `
        <div style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); 
                   text-align: center; color: ${intensity.color}; font-weight: bold; z-index: 10;">
            <i class="fas fa-cloud-rain" style="font-size: 24px;"></i>
            <div style="font-size: 12px; margin-top: 5px; text-shadow: 0 0 2px white;">
                Précipitations ${intensity.status}s
            </div>
        </div>
    `;
    
    // Créer les gouttes de pluie
    for (let i = 0; i < numDrops; i++) {
        const dropSize = 3 + (currentRain / 10) * 3; // Taille entre 3 et 6px selon l'intensité
        const left = Math.random() * 95;
        const top = 20 + Math.random() * 50; // Commence après les nuages
        const delay = Math.random() * 2;
        const duration = 1 + Math.random();
        
        const drop = document.createElement('div');
        drop.className = 'rain-drop';
        drop.style.cssText = `
            position: absolute;
            top: ${top}%;
            left: ${left}%;
            width: ${dropSize / 3}px;
            height: ${dropSize}px;
            background-color: ${intensity.color};
            border-radius: 50% 50% 0 50%;
            transform: rotate(45deg);
            opacity: 0.7;
            z-index: 6;
            animation: rainDrop ${duration}s linear ${delay}s infinite;
        `;
        indicators.appendChild(drop);
    }
    
    // Ajouter un sol ou une accumulation d'eau au bas
    const groundHeight = Math.min(30, currentRain * 3); // La hauteur augmente avec l'intensité, max 30%
    const ground = document.createElement('div');
    ground.style.cssText = `
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: ${groundHeight}%;
        background: linear-gradient(to bottom, ${intensity.color}33, ${intensity.color}66);
        border-top: 1px solid ${intensity.color}99;
        z-index: 4;
        transition: all 0.5s ease;
    `;
    
    // Ajouter des ondulations à la surface de l'eau
    for (let i = 0; i < 5; i++) {
        const ripple = document.createElement('div');
        const size = 10 + Math.random() * 20;
        const left = Math.random() * 90;
        
        ripple.style.cssText = `
            position: absolute;
            top: -5px;
            left: ${left}%;
            width: ${size}px;
            height: ${size}px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.4);
            animation: ripple 2s ease-out infinite;
            animation-delay: ${Math.random() * 2}s;
        `;
        ground.appendChild(ripple);
    }
    
    rainLayers.appendChild(ground);
    
    // Ajouter une animation CSS pour les gouttes et ondulations sans duplication
    const styleId = 'rain-animation-styles';
    
    // Vérifier si le style existe déjà
    if (!document.getElementById(styleId)) {
        const styleElement = document.createElement('style');
        styleElement.id = styleId;
        styleElement.textContent = `
            @keyframes rainDrop {
                0% {
                    transform: rotate(45deg) translateY(0);
                    opacity: 0.7;
                }
                80% {
                    opacity: 0.7;
                }
                100% {
                    transform: rotate(45deg) translateY(${80 - groundHeight}px);
                    opacity: 0;
                }
            }
            
            @keyframes ripple {
                0% {
                    transform: scale(0.2);
                    opacity: 1;
                }
                100% {
                    transform: scale(2);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(styleElement);
    } else {
        // Mettre à jour les animations existantes pour la nouvelle hauteur de sol
        const existingStyle = document.getElementById(styleId);
        existingStyle.textContent = `
            @keyframes rainDrop {
                0% {
                    transform: rotate(45deg) translateY(0);
                    opacity: 0.7;
                }
                80% {
                    opacity: 0.7;
                }
                100% {
                    transform: rotate(45deg) translateY(${80 - groundHeight}px);
                    opacity: 0;
                }
            }
            
            @keyframes ripple {
                0% {
                    transform: scale(0.2);
                    opacity: 1;
                }
                100% {
                    transform: scale(2);
                    opacity: 0;
                }
            }
        `;
    }
    
    // Animation des nuages
    try {
        animateClouds();
    } catch (error) {
        console.error("Erreur lors de l'animation des nuages:", error);
    }
}

// Animation des nuages
function animateClouds() {
    const clouds = document.querySelectorAll('.rain-cloud');
    
    clouds.forEach(cloud => {
        const duration = 20 + Math.random() * 30; // Entre 20 et 50 secondes
        const direction = Math.random() > 0.5 ? 1 : -1; // Gauche ou droite
        const distance = 5 + Math.random() * 10; // Distance de déplacement
        
        const currentLeft = parseFloat(cloud.style.left);
        const targetLeft = Math.max(0, Math.min(95, currentLeft + (direction * distance)));
        
        cloud.style.transition = `left ${duration}s linear`;
        
        setTimeout(() => {
            cloud.style.left = `${targetLeft}%`;
            
            // Recommencer l'animation quand terminée
            setTimeout(() => {
                cloud.style.transition = 'none';
                cloud.style.left = `${currentLeft}%`;
                setTimeout(() => {
                    animateClouds();
                }, 100);
            }, duration * 1000);
        }, 100);
    });
}

// Fonctions de zoom pour le graphique de pluie
function zoomRainChart(factor) {
    if (!rainChart || !rainChart.zoom) {
        console.warn("Fonction de zoom non disponible pour la pluie");
        return;
    }
    
    try {
        rainChart.zoom(1 + factor);
    } catch (e) {
        console.warn("Erreur lors du zoom pluie:", e);
    }
}

function resetRainZoom() {
    if (!rainChart || !rainChart.resetZoom) {
        console.warn("Fonction de réinitialisation de zoom non disponible pour la pluie");
        return;
    }
    
    try {
        rainChart.resetZoom();
    } catch (e) {
        console.warn("Erreur lors de la réinitialisation du zoom pluie:", e);
        setTimeout(renderRainChart, 100);
    }
}

    function exportData(format = 'xlsx') {
        if (state.chartData.length === 0) {
            alert("Aucune donnée à exporter");
            return;
        }
        
        if (format === 'xlsx') {
            exportToExcel();
        } else if (format === 'pdf') {
            exportToPDF();
        }
    }

    function exportToExcel() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const content = convertToExcel(state.chartData);
            
            if (!content) {
                alert("Erreur lors de la génération du fichier Excel");
                return;
            }
        
            const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `mesures_eau_${timestamp}.xlsx`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        } catch (e) {
            console.error("Erreur lors de l'export Excel", e);
            alert("Une erreur est survenue lors de l'export");
        }
    }

    function exportToPDF() {
        try {
            if (state.chartData.length === 0) {
                alert("Aucune donnée à exporter");
                return;
            }

            if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
                alert("La fonction PDF nécessite la librairie jsPDF. Chargement en cours...");
                return;
            }

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            doc.setFontSize(18);
            doc.text('Historique des mesures hydrométriques', 14, 15);
            
            doc.setFontSize(10);
            doc.text(`Exporté le: ${new Date().toLocaleString()} (données conservées 24h)`, 14, 25);
            
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text('Index', 14, 35);
            doc.text('Heure', 40, 35);
            doc.text('Canal 1 (cm)', 80, 35);
            doc.text('Canal 2 (cm)', 120, 35);
            
            doc.setFont(undefined, 'normal');
            let y = 45;
            state.chartData.forEach(item => {
                if (y > 280) {
                    doc.addPage();
                    y = 20;
                }
                doc.text(item.index.toString(), 14, y);
                doc.text(item.timestamp ? new Date(item.timestamp).toLocaleTimeString() : 'N/A', 40, y);
                doc.text(item.distance1.toFixed(1), 80, y);
                doc.text(item.distance2.toFixed(1), 120, y);
                y += 10;
            });
            
            doc.save(`mesures_eau_${new Date().toISOString().slice(0,10)}.pdf`);
        } catch (e) {
            console.error("Erreur lors de l'export PDF", e);
            alert("Une erreur est survenue lors de l'export PDF");
        }
    }

    function convertToExcel(data) {
        if (!data || data.length === 0) return null;
        
        try {
            const worksheet = XLSX.utils.json_to_sheet(data.map(item => ({
                'Index': item.index,
                'Heure': item.timestamp || '',
                'Canal 1 (cm)': item.distance1,
                'Canal 2 (cm)': item.distance2
            })));
        
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Mesures_eau");
            
            return XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        } catch (e) {
            console.error("Erreur de conversion Excel", e);
            return null;
        }
    }

    function exportChartImage() {
        if (!chart) {
            alert("Graphique non disponible");
            return;
        }
        
        try {
            const canvas = document.querySelector('#water-level-chart canvas');
            const imageURL = canvas.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.href = imageURL;
            link.download = 'niveau-eau-' + new Date().toISOString().slice(0, 10) + '.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (e) {
            console.error("Erreur lors de l'export de l'image:", e);
            alert("Erreur lors de l'export de l'image");
        }
    }

    function showTemperatureFullHistory() {
    if (state.temperatureChartData.length === 0) {
        alert("Aucun historique disponible");
        return;
    }

    const now = new Date();
    
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 z-50';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.overflow = 'auto';
    modal.style.padding = '1rem';
    
    modal.innerHTML = `
        <div class="bg-white rounded-lg w-11/12 max-w-4xl" style="max-height: 85vh; display: flex; flex-direction: column;">
            <div class="p-4 border-b sticky top-0 bg-white z-10 flex justify-between items-center">
                <h3 class="text-xl font-bold">Historique complet de température (${state.temperatureChartData.length} mesures)</h3>
                <button id="close-history-modal" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div style="overflow-y: auto; flex-grow: 1; max-height: calc(85vh - 160px);">
                <table class="w-full">
                    <thead class="sticky top-0 bg-gray-100 z-10">
                        <tr>
                            <th class="p-2 text-left border-b border-gray-200">#</th>
                            <th class="p-2 text-left border-b border-gray-200">Heure</th>
                            <th class="p-2 text-left border-b border-gray-200">Temps écoulé</th>
                            <th class="p-2 text-left border-b border-gray-200">Température (°C)</th>
                            <th class="p-2 text-left border-b border-gray-200">Statut</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body">
                    </tbody>
                </table>
            </div>
            
            <div class="p-4 border-t mt-auto bg-white">
                <div class="flex items-center justify-between mb-2">
                    <div class="text-sm text-gray-500">
                        <i class="fas fa-info-circle"></i> Les données sont conservées pendant 24 heures
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-blue-500 mr-1"></span>
                            <span class="text-xs">Froid</span>
                        </div>
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-emerald-500 mr-1"></span>
                            <span class="text-xs">Optimal</span>
                        </div>
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-red-500 mr-1"></span>
                            <span class="text-xs">Chaud</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
    
    const tableBody = document.getElementById('history-table-body');
    
    let tableContent = '';
    state.temperatureChartData.forEach(d => {
        let timeElapsed = '';
        if (d.timestamp) {
            const dataTime = new Date(d.timestamp);
            const diffMs = now - dataTime;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMins / 60);
            
            if (diffHours > 0) {
                timeElapsed = `${diffHours}h ${diffMins % 60}m`;
            } else {
                timeElapsed = `${diffMins}m`;
            }
        }
        
        const tempAlert = getTemperatureLevel(d.temperature);
        
        tableContent += `
            <tr class="border-b border-gray-200 hover:bg-gray-50">
                <td class="p-3">${d.index}</td>
                <td class="p-3">${d.timestamp ? new Date(d.timestamp).toLocaleTimeString() : 'N/A'}</td>
                <td class="p-3">${timeElapsed}</td>
                <td class="p-3">${d.temperature.toFixed(1)}</td>
                <td class="p-3">
                    <span class="px-2 py-1 rounded-full text-xs font-medium ${tempAlert.bgColor} ${tempAlert.textColor}">
                        ${tempAlert.status}
                    </span>
                </td>
            </tr>
        `;
    });
    
    tableBody.innerHTML = tableContent;
    
    document.getElementById('close-history-modal').addEventListener('click', function() {
        document.body.removeChild(modal);
        document.body.style.overflow = '';
    });
    
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
        }
    });
}


    function exportTemperatureData(format = 'xlsx') {
    if (state.temperatureChartData.length === 0) {
        alert("Aucune donnée de température à exporter");
        return;
    }
    
    if (format === 'xlsx') {
        exportTemperatureToExcel();
    } else if (format === 'pdf') {
        exportTemperatureToPDF();
    }
}

function exportTemperatureToExcel() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const content = convertTemperatureToExcel(state.temperatureChartData);
            
            if (!content) {
                alert("Erreur lors de la génération du fichier Excel");
                return;
            }

            const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `mesures_temperature_${timestamp}.xlsx`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        } catch (e) {
            console.error("Erreur lors de l'export Excel de température", e);
            alert("Une erreur est survenue lors de l'export");
        }
    }

    function convertTemperatureToExcel(data) {
        if (!data || data.length === 0) return null;
        
        try {
            const worksheet = XLSX.utils.json_to_sheet(data.map(item => ({
                'Index': item.index,
                'Heure': item.timestamp || '',
                'Température (°C)': item.temperature
            })));

            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Mesures_température");
            
            return XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        } catch (e) {
            console.error("Erreur de conversion Excel température", e);
            return null;
        }
    }

    function exportTemperatureChartImage() {
        if (!temperatureChart) {
            alert("Graphique de température non disponible");
            return;
        }
        try {
            const canvas = document.querySelector('#temperature-chart canvas');
            const imageURL = canvas.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.href = imageURL;
            link.download = 'temperature-sol-' + new Date().toISOString().slice(0, 10) + '.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (e) {
            console.error("Erreur lors de l'export de l'image de température:", e);
            alert("Erreur lors de l'export de l'image");
        }
    }

    function exportTemperatureToPDF() {
    try {
        if (state.temperatureChartData.length === 0) {
            alert("Aucune donnée à exporter");
            return;
        }

        if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
            alert("La fonction PDF nécessite la librairie jsPDF. Chargement en cours...");
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        doc.setFontSize(18);
        doc.text('Historique des mesures de température du sol', 14, 15);
        
        doc.setFontSize(10);
        doc.text(`Exporté le: ${new Date().toLocaleString()} (données conservées 24h)`, 14, 25);
        
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold');
        doc.text('Index', 14, 35);
        doc.text('Heure', 40, 35);
        doc.text('Température (°C)', 80, 35);
        doc.text('Statut', 120, 35);
        
        doc.setFont(undefined, 'normal');
        let y = 45;
        state.temperatureChartData.forEach(item => {
            if (y > 280) {
                doc.addPage();
                y = 20;
            }
            const tempLevel = getTemperatureLevel(item.temperature);
            doc.text(item.index.toString(), 14, y);
            doc.text(item.timestamp ? new Date(item.timestamp).toLocaleTimeString() : 'N/A', 40, y);
            doc.text(item.temperature.toFixed(1), 80, y);
            doc.text(tempLevel.status, 120, y);
            y += 10;
        });
        
        doc.save(`mesures_temperature_${new Date().toISOString().slice(0,10)}.pdf`);
    } catch (e) {
        console.error("Erreur lors de l'export PDF", e);
        alert("Une erreur est survenue lors de l'export PDF");
    }
}

function resetTemperatureData() {
    if(confirm('Voulez-vous vraiment effacer toutes les données de température?')) { 
        state.temperatureChartData = []; 
        state.temperatureDataIndex = 0;
        state.sensorHistory.soilTemperature = [];
        updateHistoryTable(elements.temperatureHistory, [], '°C');
        saveToLocalStorage();
        if (temperatureChart) {
            temperatureChart.destroy();
            temperatureChart = null;
        }
        updateTemperatureChartData(20); // Valeur par défaut
        alert("Données de température réinitialisées");
    }
}


function showHumidityFullHistory() {
    if (state.humidityChartData.length === 0) {
        alert("Aucun historique disponible");
        return;
    }

    const now = new Date();
    
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 z-50';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.overflow = 'auto';
    modal.style.padding = '1rem';
    
    modal.innerHTML = `
        <div class="bg-white rounded-lg w-11/12 max-w-4xl" style="max-height: 85vh; display: flex; flex-direction: column;">
            <div class="p-4 border-b sticky top-0 bg-white z-10 flex justify-between items-center">
                <h3 class="text-xl font-bold">Historique complet d'humidité (${state.humidityChartData.length} mesures)</h3>
                <button id="close-history-modal" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div style="overflow-y: auto; flex-grow: 1; max-height: calc(85vh - 160px);">
                <table class="w-full">
                    <thead class="sticky top-0 bg-gray-100 z-10">
                        <tr>
                            <th class="p-2 text-left border-b border-gray-200">#</th>
                            <th class="p-2 text-left border-b border-gray-200">Heure</th>
                            <th class="p-2 text-left border-b border-gray-200">Temps écoulé</th>
                            <th class="p-2 text-left border-b border-gray-200">Humidité (%)</th>
                            <th class="p-2 text-left border-b border-gray-200">Statut</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body">
                    </tbody>
                </table>
            </div>
            
            <div class="p-4 border-t mt-auto bg-white">
                <div class="flex items-center justify-between mb-2">
                    <div class="text-sm text-gray-500">
                        <i class="fas fa-info-circle"></i> Les données sont conservées pendant 24 heures
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
    
    const tableBody = document.getElementById('history-table-body');
    
    let tableContent = '';
    state.humidityChartData.forEach(d => {
        let timeElapsed = '';
        if (d.timestamp) {
            const dataTime = new Date(d.timestamp);
            const diffMs = now - dataTime;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMins / 60);
            
            if (diffHours > 0) {
                timeElapsed = `${diffHours}h ${diffMins % 60}m`;
            } else {
                timeElapsed = `${diffMins}m`;
            }
        }
        
        const humidityAlert = getHumidityLevel(d.humidity);
        
        tableContent += `
            <tr class="border-b border-gray-200 hover:bg-gray-50">
                <td class="p-3">${d.index}</td>
                <td class="p-3">${d.timestamp ? new Date(d.timestamp).toLocaleTimeString() : 'N/A'}</td>
                <td class="p-3">${timeElapsed}</td>
                <td class="p-3">${d.humidity.toFixed(1)}</td>
                <td class="p-3">
                    <span class="px-2 py-1 rounded-full text-xs font-medium ${humidityAlert.bgColor} ${humidityAlert.textColor}">
                        ${humidityAlert.status}
                    </span>
                </td>
            </tr>
        `;
    });
    
    tableBody.innerHTML = tableContent;
    
    document.getElementById('close-history-modal').addEventListener('click', function() {
        document.body.removeChild(modal);
        document.body.style.overflow = '';
    });
    
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
        }
    });
}


function resetHumidityData() {
    if(confirm('Voulez-vous vraiment effacer toutes les données d\'humidité?')) { 
        state.humidityChartData = []; 
        state.humidityDataIndex = 0;
        state.sensorHistory.soilHumidity = [];
        updateHistoryTable(elements.humidityHistory, [], '%');
        saveToLocalStorage();
        if (humidityChart) {
            humidityChart.destroy();
            humidityChart = null;
        }
        updateHumidityChartData(50); // Valeur par défaut
        alert("Données d'humidité réinitialisées");
    }
}


function exportHumidityData(format = 'xlsx') {
    if (state.humidityChartData.length === 0) {
        alert("Aucune donnée d'humidité à exporter");
        return;
    }
    
    if (format === 'xlsx') {
        exportHumidityToExcel();
    } else if (format === 'pdf') {
        exportHumidityToPDF();
    }
}
 
function exportHumidityToExcel() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const content = convertHumidityToExcel(state.humidityChartData);
            
            if (!content) {
                alert("Erreur lors de la génération du fichier Excel");
                return;
            }

            const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `mesures_humidite_${timestamp}.xlsx`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        } catch (e) {
            console.error("Erreur lors de l'export Excel d'humidité", e);
            alert("Une erreur est survenue lors de l'export");
        }
    }

    function convertHumidityToExcel(data) {
        if (!data || data.length === 0) return null;
        
        try {
            const worksheet = XLSX.utils.json_to_sheet(data.map(item => ({
                'Index': item.index,
                'Heure': item.timestamp || '',
                'Humidité (%)': item.humidity
            })));

            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "Mesures_humidité");
            
            return XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
        } catch (e) {
            console.error("Erreur de conversion Excel humidité", e);
            return null;
        }
    }

    function exportHumidityChartImage() {
        if (!humidityChart) {
            alert("Graphique d'humidité non disponible");
            return;
        }
        
        try {
            const canvas = document.querySelector('#humidity-chart canvas');
            const imageURL = canvas.toDataURL('image/png');
            
            const link = document.createElement('a');
            link.href = imageURL;
            link.download = 'humidite-sol-' + new Date().toISOString().slice(0, 10) + '.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } catch (e) {
            console.error("Erreur lors de l'export de l'image d'humidité:", e);
            alert("Erreur lors de l'export de l'image");
        }
    }

    function exportRainData(format = 'xlsx') {
    if (state.rainChartData.length === 0) {
        alert("Aucune donnée de précipitations à exporter");
        return;
    }
    
    if (format === 'xlsx') {
        exportRainToExcel();
    } else if (format === 'pdf') {
        exportRainToPDF();
    }
}

function exportRainToExcel() {
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const content = convertRainToExcel(state.rainChartData);
        
        if (!content) {
            alert("Erreur lors de la génération du fichier Excel");
            return;
        }

        const blob = new Blob([content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `mesures_precipitations_${timestamp}.xlsx`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
    } catch (e) {
        console.error("Erreur lors de l'export Excel des précipitations", e);
        alert("Une erreur est survenue lors de l'export");
    }
}

function convertRainToExcel(data) {
    if (!data || data.length === 0) return null;
    
    try {
        const worksheet = XLSX.utils.json_to_sheet(data.map(item => ({
            'Index': item.index,
            'Heure': item.timestamp || '',
            'Précipitations (mm)': item.rainAmount,
            'Intensité': getRainIntensity(item.rainAmount).status
        })));

        const workbook = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(workbook, worksheet, "Mesures_precipitations");
        
        return XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    } catch (e) {
        console.error("Erreur de conversion Excel précipitations", e);
        return null;
    }
}

function exportRainToPDF() {
    try {
        if (state.rainChartData.length === 0) {
            alert("Aucune donnée à exporter");
            return;
        }

        if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
            alert("La fonction PDF nécessite la librairie jsPDF. Chargement en cours...");
            return;
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        doc.setFontSize(18);
        doc.text('Historique des mesures de précipitations', 14, 15);
        
        doc.setFontSize(10);
        doc.text(`Exporté le: ${new Date().toLocaleString()} (données conservées 24h)`, 14, 25);
        
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold');
        doc.text('Index', 14, 35);
        doc.text('Heure', 40, 35);
        doc.text('Précipitations (mm)', 80, 35);
        doc.text('Intensité', 120, 35);
        
        doc.setFont(undefined, 'normal');
        let y = 45;
        state.rainChartData.forEach(item => {
            if (y > 280) {
                doc.addPage();
                y = 20;
            }
            const rainIntensity = getRainIntensity(item.rainAmount);
            doc.text(item.index.toString(), 14, y);
            doc.text(item.timestamp ? new Date(item.timestamp).toLocaleTimeString() : 'N/A', 40, y);
            doc.text(item.rainAmount.toFixed(1), 80, y);
            doc.text(rainIntensity.status, 120, y);
            y += 10;
        });
        
        doc.save(`mesures_precipitations_${new Date().toISOString().slice(0,10)}.pdf`);
    } catch (e) {
        console.error("Erreur lors de l'export PDF", e);
        alert("Une erreur est survenue lors de l'export PDF");
    }
}

function exportRainChartImage() {
    if (!rainChart) {
        alert("Graphique de précipitations non disponible");
        return;
    }
    
    try {
        const canvas = document.querySelector('#rain-chart canvas');
        const imageURL = canvas.toDataURL('image/png');
        
        const link = document.createElement('a');
        link.href = imageURL;
        link.download = 'precipitations-' + new Date().toISOString().slice(0, 10) + '.png';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    } catch (e) {
        console.error("Erreur lors de l'export de l'image de précipitations:", e);
        alert("Erreur lors de l'export de l'image");
    }
}

function resetRainData() {
    if(confirm('Voulez-vous vraiment effacer toutes les données de précipitations?')) { 
        state.rainChartData = []; 
        state.rainDataIndex = 0;
        state.sensorHistory.rainAmount = [];
        updateHistoryTable(elements.rainHistory, [], 'mm');
        saveToLocalStorage();
        if (rainChart) {
            rainChart.destroy();
            rainChart = null;
        }
        updateRainChartData(0); // Valeur par défaut
        alert("Données de précipitations réinitialisées");
    }
}

function showRainFullHistory() {
    if (state.rainChartData.length === 0) {
        alert("Aucun historique disponible");
        return;
    }

    const now = new Date();
    
    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 z-50';
    modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.overflow = 'auto';
    modal.style.padding = '1rem';
    
    modal.innerHTML = `
        <div class="bg-white rounded-lg w-11/12 max-w-4xl" style="max-height: 85vh; display: flex; flex-direction: column;">
            <div class="p-4 border-b sticky top-0 bg-white z-10 flex justify-between items-center">
                <h3 class="text-xl font-bold">Historique complet des précipitations (${state.rainChartData.length} mesures)</h3>
                <button id="close-history-modal" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <div style="overflow-y: auto; flex-grow: 1; max-height: calc(85vh - 160px);">
                <table class="w-full">
                    <thead class="sticky top-0 bg-gray-100 z-10">
                        <tr>
                            <th class="p-2 text-left border-b border-gray-200">#</th>
                            <th class="p-2 text-left border-b border-gray-200">Heure</th>
                            <th class="p-2 text-left border-b border-gray-200">Temps écoulé</th>
                            <th class="p-2 text-left border-b border-gray-200">Précipitations (mm)</th>
                            <th class="p-2 text-left border-b border-gray-200">Intensité</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body">
                    </tbody>
                </table>
            </div>
            
            <div class="p-4 border-t mt-auto bg-white">
                <div class="flex items-center justify-between mb-2">
                    <div class="text-sm text-gray-500">
                        <i class="fas fa-info-circle"></i> Les données sont conservées pendant 24 heures
                    </div>
                    <div class="flex items-center gap-3">
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-blue-300 mr-1"></span>
                            <span class="text-xs">Faible</span>
                        </div>
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-blue-400 mr-1"></span>
                            <span class="text-xs">Modérée</span>
                        </div>
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-blue-500 mr-1"></span>
                            <span class="text-xs">Forte</span>
                        </div>
                        <div class="flex items-center">
                            <span class="inline-block w-3 h-3 rounded-full bg-blue-600 mr-1"></span>
                            <span class="text-xs">Intense</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
    
    const tableBody = document.getElementById('history-table-body');
    
    let tableContent = '';
    state.rainChartData.forEach(d => {
        let timeElapsed = '';
        if (d.timestamp) {
            const dataTime = new Date(d.timestamp);
            const diffMs = now - dataTime;
            const diffMins = Math.floor(diffMs / (1000 * 60));
            const diffHours = Math.floor(diffMins / 60);
            
            if (diffHours > 0) {
                timeElapsed = `${diffHours}h ${diffMins % 60}m`;
            } else {
                timeElapsed = `${diffMins}m`;
            }
        }
        
        const intensityInfo = getRainIntensity(d.rainAmount);
        
        tableContent += `
            <tr class="border-b border-gray-200 hover:bg-gray-50">
                <td class="p-3">${d.index}</td>
                <td class="p-3">${d.timestamp ? new Date(d.timestamp).toLocaleTimeString() : 'N/A'}</td>
                <td class="p-3">${timeElapsed}</td>
                <td class="p-3">${d.rainAmount.toFixed(1)}</td>
                <td class="p-3">
                    <span class="px-2 py-1 rounded-full text-xs font-medium ${intensityInfo.bgColor} ${intensityInfo.textColor}">
                        ${intensityInfo.status}
                    </span>
                </td>
            </tr>
        `;
    });
    
    tableBody.innerHTML = tableContent;
    
    document.getElementById('close-history-modal').addEventListener('click', function() {
        document.body.removeChild(modal);
        document.body.style.overflow = '';
    });
    
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
        }
    }); 
  }

 
    function showFullHistory() {
        if (state.chartData.length === 0) {
            alert("Aucun historique disponible");
            return;
        }

        const now = new Date();
        
        const modal = document.createElement('div');
        modal.className = 'fixed inset-0 z-50';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.75)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.overflow = 'auto';
        modal.style.padding = '1rem';
        
        modal.innerHTML = `
            <div class="bg-white rounded-lg w-11/12 max-w-4xl" style="max-height: 85vh; display: flex; flex-direction: column;">
                <div class="p-4 border-b sticky top-0 bg-white z-10 flex justify-between items-center">
                    <h3 class="text-xl font-bold">Historique complet (${state.chartData.length} mesures)</h3>
                    <button id="close-history-modal" class="text-gray-500 hover:text-gray-700 p-2 rounded-full hover:bg-gray-100">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div style="overflow-y: auto; flex-grow: 1; max-height: calc(85vh - 160px);">
                    <table class="w-full">
                        <thead class="sticky top-0 bg-gray-100 z-10">
                            <tr>
                                <th class="p-2 text-left border-b border-gray-200">#</th>
                                <th class="p-2 text-left border-b border-gray-200">Heure</th>
                                <th class="p-2 text-left border-b border-gray-200">Temps écoulé</th>
                                <th class="p-2 text-left border-b border-gray-200">Canal 1 (cm)</th>
                                <th class="p-2 text-left border-b border-gray-200">Niveau 1</th>
                                <th class="p-2 text-left border-b border-gray-200">Débit 1 (m³/s)</th>
                                <th class="p-2 text-left border-b border-gray-200">Canal 2 (cm)</th>
                                <th class="p-2 text-left border-b border-gray-200">Niveau 2</th>
                                <th class="p-2 text-left border-b border-gray-200">Débit 2 (m³/s)</th>
                            </tr>
                        </thead>
                        <tbody id="history-table-body">
                        </tbody>
                    </table>
                </div>
                
                <div class="p-4 border-t mt-auto bg-white">
                    <div class="flex items-center justify-between mb-2">
                        <div class="text-sm text-gray-500">
                            <i class="fas fa-info-circle"></i> Les données sont conservées pendant 24 heures
                        </div>
            
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        document.body.style.overflow = 'hidden';
        
        const tableBody = document.getElementById('history-table-body');
        
        let tableContent = '';
        state.chartData.forEach(d => {
            let timeElapsed = '';
            if (d.timestamp) {
                const dataTime = new Date(d.timestamp);
                const diffMs = now - dataTime;
                const diffMins = Math.floor(diffMs / (1000 * 60));
                const diffHours = Math.floor(diffMins / 60);
                
                if (diffHours > 0) {
                    timeElapsed = `${diffHours}h ${diffMins % 60}m`;
                } else {
                    timeElapsed = `${diffMins}m`;
                }
            }
            
            const flow1 = calculateFlow(d.distance1);
            const flow2 = calculateFlow(d.distance2);
            
            const alert1 = getWaterLevelAlert(d.distance1);
            const alert2 = getWaterLevelAlert(d.distance2);
            
            tableContent += `
                <tr class="border-b border-gray-200 hover:bg-gray-50">
                    <td class="p-3">${d.index}</td>
                    <td class="p-3">${d.timestamp ? new Date(d.timestamp).toLocaleTimeString() : 'N/A'}</td>
                    <td class="p-3">${timeElapsed}</td>
                    <td class="p-3">${d.distance1.toFixed(1)}</td>
                    <td class="p-3">
                        <span class="px-2 py-1 rounded-full text-xs font-medium ${alert1.bgColor} ${alert1.textColor}">
                            ${alert1.status} (${alert1.value.toFixed(1)} cm)
                        </span>
                    </td>
                    <td class="p-3">${flow1.toFixed(1)}</td>
                    <td class="p-3">${d.distance2.toFixed(1)}</td>
                    <td class="p-3">
                        <span class="px-2 py-1 rounded-full text-xs font-medium ${alert2.bgColor} ${alert2.textColor}">
                            ${alert2.status} (${alert2.value.toFixed(1)} cm)
                        </span>
                    </td>
                    <td class="p-3">${flow2.toFixed(1)}</td>
                </tr>
            `;
        });
        
        tableBody.innerHTML = tableContent;
        
        document.getElementById('close-history-modal').addEventListener('click', function() {
            document.body.removeChild(modal);
            document.body.style.overflow = '';
        });
        
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                document.body.removeChild(modal);
                document.body.style.overflow = '';
            }
        });
    }

// Fonction pour corriger immédiatement les problèmes de visibilité
function fixRetenueVisibility() {
  console.log("Correction des problèmes de visibilité de la retenue...");
  
  // 1. Corriger les graduations pour le mode précis
  const axisLabels = document.getElementById('retenue-axis-labels');
  if (axisLabels) {
    // Créer toutes les graduations détaillées (mode précis)
    const preciseLabels = Array.from({ length: 12 }, (_, i) => 200 - i * 2);
    axisLabels.innerHTML = preciseLabels.map(mark => `<span>${mark} m</span>`).join('');
    console.log("Graduations précises créées");
  }
  
  // 2. Gérer le trait rouge - MODIFICATION POUR SUPPRIMER LE DOUBLON
  const levelMarkers = document.querySelectorAll('#retenue-level-marker');
  
  // S'il y a plus d'un marqueur, supprimer tous sauf le premier
  if (levelMarkers.length > 1) {
    console.log(`${levelMarkers.length} traits détectés, suppression des doublons...`);
    for (let i = 1; i < levelMarkers.length; i++) {
      if (levelMarkers[i] && levelMarkers[i].parentNode) {
        levelMarkers[i].parentNode.removeChild(levelMarkers[i]);
      }
    }
  }
  
  // Maintenant, travaillons uniquement avec le premier marqueur
  const levelMarker = document.getElementById('retenue-level-marker');
  if (levelMarker) {
    // Style agressif pour le trait rouge
    levelMarker.style.display = 'flex';
    levelMarker.style.position = 'absolute';
    levelMarker.style.zIndex = '9999';
    levelMarker.style.left = '4px';
    
    // Récupérer la valeur actuelle si disponible, sinon utiliser 68.3% par défaut
    const waterElement = document.getElementById('retenue-water');
    const percentage = waterElement ? waterElement.style.height : '68.3%';
    levelMarker.style.bottom = percentage;
    
    // Vider le marqueur et créer un nouveau trait rouge
    levelMarker.innerHTML = '';
    
    // Créer le trait horizontal
    const newMarkerLine = document.createElement('div');
    newMarkerLine.style.height = '4px';
    newMarkerLine.style.width = '40px';
    newMarkerLine.style.backgroundColor = '#ff0000';
    levelMarker.appendChild(newMarkerLine);
    
    // Créer l'étiquette de valeur
    const valueSpan = document.createElement('span');
    valueSpan.className = 'ml-2 rounded text-xs font-semibold';
    valueSpan.style.backgroundColor = '#fee2e2';
    valueSpan.style.padding = '4px 8px';
    valueSpan.style.borderRadius = '4px';
    valueSpan.style.fontWeight = 'bold';
    valueSpan.style.color = '#dc2626';
    valueSpan.style.marginLeft = '8px';
    
    // Créer l'élément pour la valeur numérique
    const markerValue = document.createElement('span');
    markerValue.id = 'retenue-marker-value';
    markerValue.textContent = '181.18';
    valueSpan.appendChild(markerValue);
    valueSpan.appendChild(document.createTextNode(' m'));
    
    levelMarker.appendChild(valueSpan);
    
    console.log("Trait rouge rendu visible (doublons supprimés)");
  }
  
  // 3. S'assurer que le bouton de mode précis est visible et fonctionne
  const calibrageButton = document.getElementById('retenue-calibrage-button');
  if (calibrageButton) {
    calibrageButton.style.display = 'flex';
    calibrageButton.style.alignItems = 'center';
    calibrageButton.style.justifyContent = 'center';
    calibrageButton.style.backgroundColor = '#4f46e5';
    calibrageButton.style.color = 'white';
    calibrageButton.style.borderRadius = '0.375rem';
    calibrageButton.style.padding = '0.5rem 1rem';
    calibrageButton.style.fontWeight = '500';
    calibrageButton.style.width = '100%';
    
    // Ajouter un gestionnaire d'événements spécial
    calibrageButton.onclick = function() {
      const currentMode = calibrageButton.getAttribute('data-mode') || 'standard';
      const newMode = currentMode === 'standard' ? 'precis' : 'standard';
      
      // Mettre à jour l'attribut
      calibrageButton.setAttribute('data-mode', newMode);
      
      // Mettre à jour le texte du bouton
      calibrageButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" class="h-5 w-5 mr-2">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
        </svg>
        Mode ${newMode === 'standard' ? 'précis' : 'standard'}
      `;
      
      // Actualiser les graduations selon le mode
      if (axisLabels) {
        if (newMode === 'precis') {
          // Mode précis: graduations tous les 2 mètres
          const preciseLabels = Array.from({ length: 12 }, (_, i) => 200 - i * 2);
          axisLabels.innerHTML = preciseLabels.map(mark => `<span>${mark} m</span>`).join('');
        } else {
          // Mode standard: graduations principales seulement
          axisLabels.innerHTML = `
            <span>200 m</span>
            <span>190 m</span>
            <span>180 m</span>
          `;
        }
      }
      
      // Notification pour confirmer le changement
      const notification = document.createElement('div');
      notification.textContent = `Mode ${newMode} activé`;
      notification.style.position = 'fixed';
      notification.style.bottom = '20px';
      notification.style.right = '20px';
      notification.style.padding = '10px 15px';
      notification.style.background = '#4f46e5';
      notification.style.color = 'white';
      notification.style.borderRadius = '4px';
      notification.style.zIndex = '100';
      notification.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
      document.body.appendChild(notification);
      
      // Faire disparaître la notification après 2 secondes
      setTimeout(() => {
        notification.style.opacity = '0';
        notification.style.transition = 'opacity 0.5s ease';
        setTimeout(() => document.body.removeChild(notification), 500);
      }, 2000);
    };
    
    console.log("Bouton de calibrage configuré");
  }
  
  // 4. S'assurer que le panneau coulissant est correctement configuré
  const toggleLine = document.getElementById('retenue-toggle-line');
  const slidingPanel = document.getElementById('retenue-sliding-panel');
  
  if (toggleLine && slidingPanel) {
    toggleLine.style.height = '4px';
    toggleLine.style.backgroundColor = '#000000';
    toggleLine.style.cursor = 'pointer';
    toggleLine.style.marginTop = '16px';
    toggleLine.style.width = '100%';
    
    let clickCount = 0;
    let panelVisible = false;
    
    toggleLine.onclick = function() {
      clickCount++;
      console.log(`Clic sur la ligne noire: ${clickCount}`);
      
      if (clickCount >= 3) {
        panelVisible = !panelVisible;
        slidingPanel.style.transform = panelVisible ? 'translateY(0)' : 'translateY(100%)';
        clickCount = 0;
        
        console.log(`Panneau ${panelVisible ? 'affiché' : 'masqué'}`);
      }
    };
    
    console.log("Ligne de bascule configurée");
  }
  
  console.log("Correction terminée");
}

// Ajouter ces lignes après la fonction pour l'exécuter
setTimeout(fixRetenueVisibility, 2000);

// Exécuter la correction lors du changement de section
const navLinks = document.querySelectorAll('.nav-link');
navLinks.forEach(link => {
  link.addEventListener('click', function(e) {
    const sectionId = this.getAttribute('data-section');
    if (sectionId === 'retenue-section') {
      setTimeout(fixRetenueVisibility, 1000);
    }
  });
});



    // Démarrer l'application quand le DOM est prêt
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM chargé, démarrage de l'application...");
        setTimeout(initApp, 300);
    });
</script>  

    </body>
</html>